"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@reduxjs";
exports.ids = ["vendor-chunks/@reduxjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/dist/query/react/rtk-query-react.modern.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/query/react/rtk-query-react.modern.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiProvider: () => (/* binding */ ApiProvider),\n/* harmony export */   QueryStatus: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.QueryStatus),\n/* harmony export */   buildCreateApi: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.buildCreateApi),\n/* harmony export */   copyWithStructuralSharing: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.copyWithStructuralSharing),\n/* harmony export */   coreModule: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.coreModule),\n/* harmony export */   coreModuleName: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.coreModuleName),\n/* harmony export */   createApi: () => (/* binding */ createApi),\n/* harmony export */   defaultSerializeQueryArgs: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.defaultSerializeQueryArgs),\n/* harmony export */   fakeBaseQuery: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.fakeBaseQuery),\n/* harmony export */   fetchBaseQuery: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.fetchBaseQuery),\n/* harmony export */   reactHooksModule: () => (/* binding */ reactHooksModule),\n/* harmony export */   reactHooksModuleName: () => (/* binding */ reactHooksModuleName),\n/* harmony export */   retry: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.retry),\n/* harmony export */   setupListeners: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.setupListeners),\n/* harmony export */   skipToken: () => (/* reexport safe */ _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.skipToken)\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @reduxjs/toolkit/query */ \"(ssr)/./node_modules/@reduxjs/toolkit/dist/query/rtk-query.modern.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-redux */ \"(ssr)/./node_modules/react-redux/dist/react-redux.mjs\");\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(ssr)/./node_modules/redux/dist/redux.mjs\");\n/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! reselect */ \"(ssr)/./node_modules/reselect/dist/reselect.mjs\");\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\");\n// src/query/react/index.ts\n\n// src/query/react/module.ts\n\n// src/query/react/buildHooks.ts\n\n\n\n\n\n// src/query/react/useSerializedStableValue.ts\n\nfunction useStableQueryArgs(queryArgs, serialize, endpointDefinition, endpointName) {\n    const incoming = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            queryArgs,\n            serialized: typeof queryArgs == \"object\" ? serialize({\n                queryArgs,\n                endpointDefinition,\n                endpointName\n            }) : queryArgs\n        }), [\n        queryArgs,\n        serialize,\n        endpointDefinition,\n        endpointName\n    ]);\n    const cache2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(incoming);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (cache2.current.serialized !== incoming.serialized) {\n            cache2.current = incoming;\n        }\n    }, [\n        incoming\n    ]);\n    return cache2.current.serialized === incoming.serialized ? cache2.current.queryArgs : queryArgs;\n}\n// src/query/react/constants.ts\nvar UNINITIALIZED_VALUE = Symbol();\n// src/query/react/useShallowStableValue.ts\n\n\nfunction useShallowStableValue(value) {\n    const cache2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!(0,react_redux__WEBPACK_IMPORTED_MODULE_1__.shallowEqual)(cache2.current, value)) {\n            cache2.current = value;\n        }\n    }, [\n        value\n    ]);\n    return (0,react_redux__WEBPACK_IMPORTED_MODULE_1__.shallowEqual)(cache2.current, value) ? cache2.current : value;\n}\n// src/query/core/rtkImports.ts\n\n// src/query/defaultSerializeQueryArgs.ts\nvar cache = WeakMap ? /* @__PURE__ */ new WeakMap() : void 0;\nvar defaultSerializeQueryArgs = ({ endpointName, queryArgs })=>{\n    let serialized = \"\";\n    const cached = cache?.get(queryArgs);\n    if (typeof cached === \"string\") {\n        serialized = cached;\n    } else {\n        const stringified = JSON.stringify(queryArgs, (key, value)=>(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPlainObject)(value) ? Object.keys(value).sort().reduce((acc, key2)=>{\n                acc[key2] = value[key2];\n                return acc;\n            }, {}) : value);\n        if ((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_2__.isPlainObject)(queryArgs)) {\n            cache?.set(queryArgs, stringified);\n        }\n        serialized = stringified;\n    }\n    return `${endpointName}(${serialized})`;\n};\n// src/query/react/buildHooks.ts\nvar useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nvar noPendingQueryStateSelector = (selected)=>{\n    if (selected.isUninitialized) {\n        return {\n            ...selected,\n            isUninitialized: false,\n            isFetching: true,\n            isLoading: selected.data !== void 0 ? false : true,\n            status: _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.QueryStatus.pending\n        };\n    }\n    return selected;\n};\nfunction buildHooks({ api, moduleOptions: { batch, hooks: { useDispatch, useSelector, useStore }, unstable__sideEffectsInRender, createSelector: createSelector2 }, serializeQueryArgs, context }) {\n    const usePossiblyImmediateEffect = unstable__sideEffectsInRender ? (cb)=>cb() : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n    return {\n        buildQueryHooks,\n        buildMutationHook,\n        usePrefetch\n    };\n    function queryStatePreSelector(currentState, lastResult, queryArgs) {\n        if (lastResult?.endpointName && currentState.isUninitialized) {\n            const { endpointName } = lastResult;\n            const endpointDefinition = context.endpointDefinitions[endpointName];\n            if (serializeQueryArgs({\n                queryArgs: lastResult.originalArgs,\n                endpointDefinition,\n                endpointName\n            }) === serializeQueryArgs({\n                queryArgs,\n                endpointDefinition,\n                endpointName\n            })) lastResult = void 0;\n        }\n        let data = currentState.isSuccess ? currentState.data : lastResult?.data;\n        if (data === void 0) data = currentState.data;\n        const hasData = data !== void 0;\n        const isFetching = currentState.isLoading;\n        const isLoading = !hasData && isFetching;\n        const isSuccess = currentState.isSuccess || isFetching && hasData;\n        return {\n            ...currentState,\n            data,\n            currentData: currentState.data,\n            isFetching,\n            isLoading,\n            isSuccess\n        };\n    }\n    function usePrefetch(endpointName, defaultOptions) {\n        const dispatch = useDispatch();\n        const stableDefaultOptions = useShallowStableValue(defaultOptions);\n        return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((arg, options)=>dispatch(api.util.prefetch(endpointName, arg, {\n                ...stableDefaultOptions,\n                ...options\n            })), [\n            endpointName,\n            dispatch,\n            stableDefaultOptions\n        ]);\n    }\n    function buildQueryHooks(name) {\n        const useQuerySubscription = (arg, { refetchOnReconnect, refetchOnFocus, refetchOnMountOrArgChange, skip = false, pollingInterval = 0, skipPollingIfUnfocused = false } = {})=>{\n            const { initiate } = api.endpoints[name];\n            const dispatch = useDispatch();\n            const subscriptionSelectorsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n            if (!subscriptionSelectorsRef.current) {\n                const returnedValue = dispatch(api.internalActions.internal_getRTKQSubscriptions());\n                if (true) {\n                    if (typeof returnedValue !== \"object\" || typeof returnedValue?.type === \"string\") {\n                        throw new Error( false ? 0 : `Warning: Middleware for RTK-Query API at reducerPath \"${api.reducerPath}\" has not been added to the store.\n    You must add the middleware for RTK-Query to function correctly!`);\n                    }\n                }\n                subscriptionSelectorsRef.current = returnedValue;\n            }\n            const stableArg = useStableQueryArgs(skip ? _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.skipToken : arg, // Even if the user provided a per-endpoint `serializeQueryArgs` with\n            // a consistent return value, _here_ we want to use the default behavior\n            // so we can tell if _anything_ actually changed. Otherwise, we can end up\n            // with a case where the query args did change but the serialization doesn't,\n            // and then we never try to initiate a refetch.\n            defaultSerializeQueryArgs, context.endpointDefinitions[name], name);\n            const stableSubscriptionOptions = useShallowStableValue({\n                refetchOnReconnect,\n                refetchOnFocus,\n                pollingInterval,\n                skipPollingIfUnfocused\n            });\n            const lastRenderHadSubscription = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n            const promiseRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n            let { queryCacheKey, requestId } = promiseRef.current || {};\n            let currentRenderHasSubscription = false;\n            if (queryCacheKey && requestId) {\n                currentRenderHasSubscription = subscriptionSelectorsRef.current.isRequestSubscribed(queryCacheKey, requestId);\n            }\n            const subscriptionRemoved = !currentRenderHasSubscription && lastRenderHadSubscription.current;\n            usePossiblyImmediateEffect(()=>{\n                lastRenderHadSubscription.current = currentRenderHasSubscription;\n            });\n            usePossiblyImmediateEffect(()=>{\n                if (subscriptionRemoved) {\n                    promiseRef.current = void 0;\n                }\n            }, [\n                subscriptionRemoved\n            ]);\n            usePossiblyImmediateEffect(()=>{\n                const lastPromise = promiseRef.current;\n                if (typeof process !== \"undefined\" && \"development\" === \"removeMeOnCompilation\") {}\n                if (stableArg === _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.skipToken) {\n                    lastPromise?.unsubscribe();\n                    promiseRef.current = void 0;\n                    return;\n                }\n                const lastSubscriptionOptions = promiseRef.current?.subscriptionOptions;\n                if (!lastPromise || lastPromise.arg !== stableArg) {\n                    lastPromise?.unsubscribe();\n                    const promise = dispatch(initiate(stableArg, {\n                        subscriptionOptions: stableSubscriptionOptions,\n                        forceRefetch: refetchOnMountOrArgChange\n                    }));\n                    promiseRef.current = promise;\n                } else if (stableSubscriptionOptions !== lastSubscriptionOptions) {\n                    lastPromise.updateSubscriptionOptions(stableSubscriptionOptions);\n                }\n            }, [\n                dispatch,\n                initiate,\n                refetchOnMountOrArgChange,\n                stableArg,\n                stableSubscriptionOptions,\n                subscriptionRemoved\n            ]);\n            (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n                return ()=>{\n                    promiseRef.current?.unsubscribe();\n                    promiseRef.current = void 0;\n                };\n            }, []);\n            return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n                    /**\n         * A method to manually refetch data for the query\n         */ refetch: ()=>{\n                        if (!promiseRef.current) throw new Error( false ? 0 : \"Cannot refetch a query that has not been started yet.\");\n                        return promiseRef.current?.refetch();\n                    }\n                }), []);\n        };\n        const useLazyQuerySubscription = ({ refetchOnReconnect, refetchOnFocus, pollingInterval = 0, skipPollingIfUnfocused = false } = {})=>{\n            const { initiate } = api.endpoints[name];\n            const dispatch = useDispatch();\n            const [arg, setArg] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(UNINITIALIZED_VALUE);\n            const promiseRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n            const stableSubscriptionOptions = useShallowStableValue({\n                refetchOnReconnect,\n                refetchOnFocus,\n                pollingInterval,\n                skipPollingIfUnfocused\n            });\n            usePossiblyImmediateEffect(()=>{\n                const lastSubscriptionOptions = promiseRef.current?.subscriptionOptions;\n                if (stableSubscriptionOptions !== lastSubscriptionOptions) {\n                    promiseRef.current?.updateSubscriptionOptions(stableSubscriptionOptions);\n                }\n            }, [\n                stableSubscriptionOptions\n            ]);\n            const subscriptionOptionsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(stableSubscriptionOptions);\n            usePossiblyImmediateEffect(()=>{\n                subscriptionOptionsRef.current = stableSubscriptionOptions;\n            }, [\n                stableSubscriptionOptions\n            ]);\n            const trigger = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(arg2, preferCacheValue = false) {\n                let promise;\n                batch(()=>{\n                    promiseRef.current?.unsubscribe();\n                    promiseRef.current = promise = dispatch(initiate(arg2, {\n                        subscriptionOptions: subscriptionOptionsRef.current,\n                        forceRefetch: !preferCacheValue\n                    }));\n                    setArg(arg2);\n                });\n                return promise;\n            }, [\n                dispatch,\n                initiate\n            ]);\n            (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n                return ()=>{\n                    promiseRef?.current?.unsubscribe();\n                };\n            }, []);\n            (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n                if (arg !== UNINITIALIZED_VALUE && !promiseRef.current) {\n                    trigger(arg, true);\n                }\n            }, [\n                arg,\n                trigger\n            ]);\n            return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>[\n                    trigger,\n                    arg\n                ], [\n                trigger,\n                arg\n            ]);\n        };\n        const useQueryState = (arg, { skip = false, selectFromResult } = {})=>{\n            const { select } = api.endpoints[name];\n            const stableArg = useStableQueryArgs(skip ? _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.skipToken : arg, serializeQueryArgs, context.endpointDefinitions[name], name);\n            const lastValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n            const selectDefaultResult = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>createSelector2([\n                    select(stableArg),\n                    (_, lastResult)=>lastResult,\n                    (_)=>stableArg\n                ], queryStatePreSelector, {\n                    memoizeOptions: {\n                        resultEqualityCheck: react_redux__WEBPACK_IMPORTED_MODULE_1__.shallowEqual\n                    }\n                }), [\n                select,\n                stableArg\n            ]);\n            const querySelector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>selectFromResult ? createSelector2([\n                    selectDefaultResult\n                ], selectFromResult, {\n                    devModeChecks: {\n                        identityFunctionCheck: \"never\"\n                    }\n                }) : selectDefaultResult, [\n                selectDefaultResult,\n                selectFromResult\n            ]);\n            const currentState = useSelector((state)=>querySelector(state, lastValue.current), react_redux__WEBPACK_IMPORTED_MODULE_1__.shallowEqual);\n            const store = useStore();\n            const newLastValue = selectDefaultResult(store.getState(), lastValue.current);\n            useIsomorphicLayoutEffect(()=>{\n                lastValue.current = newLastValue;\n            }, [\n                newLastValue\n            ]);\n            return currentState;\n        };\n        return {\n            useQueryState,\n            useQuerySubscription,\n            useLazyQuerySubscription,\n            useLazyQuery (options) {\n                const [trigger, arg] = useLazyQuerySubscription(options);\n                const queryStateResults = useQueryState(arg, {\n                    ...options,\n                    skip: arg === UNINITIALIZED_VALUE\n                });\n                const info = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n                        lastArg: arg\n                    }), [\n                    arg\n                ]);\n                return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>[\n                        trigger,\n                        queryStateResults,\n                        info\n                    ], [\n                    trigger,\n                    queryStateResults,\n                    info\n                ]);\n            },\n            useQuery (arg, options) {\n                const querySubscriptionResults = useQuerySubscription(arg, options);\n                const queryStateResults = useQueryState(arg, {\n                    selectFromResult: arg === _reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.skipToken || options?.skip ? void 0 : noPendingQueryStateSelector,\n                    ...options\n                });\n                const { data, status, isLoading, isSuccess, isError, error } = queryStateResults;\n                (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)({\n                    data,\n                    status,\n                    isLoading,\n                    isSuccess,\n                    isError,\n                    error\n                });\n                return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n                        ...queryStateResults,\n                        ...querySubscriptionResults\n                    }), [\n                    queryStateResults,\n                    querySubscriptionResults\n                ]);\n            }\n        };\n    }\n    function buildMutationHook(name) {\n        return ({ selectFromResult, fixedCacheKey } = {})=>{\n            const { select, initiate } = api.endpoints[name];\n            const dispatch = useDispatch();\n            const [promise, setPromise] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n            (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>()=>{\n                    if (!promise?.arg.fixedCacheKey) {\n                        promise?.reset();\n                    }\n                }, [\n                promise\n            ]);\n            const triggerMutation = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(arg) {\n                const promise2 = dispatch(initiate(arg, {\n                    fixedCacheKey\n                }));\n                setPromise(promise2);\n                return promise2;\n            }, [\n                dispatch,\n                initiate,\n                fixedCacheKey\n            ]);\n            const { requestId } = promise || {};\n            const selectDefaultResult = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>select({\n                    fixedCacheKey,\n                    requestId: promise?.requestId\n                }), [\n                fixedCacheKey,\n                promise,\n                select\n            ]);\n            const mutationSelector = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>selectFromResult ? createSelector2([\n                    selectDefaultResult\n                ], selectFromResult) : selectDefaultResult, [\n                selectFromResult,\n                selectDefaultResult\n            ]);\n            const currentState = useSelector(mutationSelector, react_redux__WEBPACK_IMPORTED_MODULE_1__.shallowEqual);\n            const originalArgs = fixedCacheKey == null ? promise?.arg.originalArgs : void 0;\n            const reset = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n                batch(()=>{\n                    if (promise) {\n                        setPromise(void 0);\n                    }\n                    if (fixedCacheKey) {\n                        dispatch(api.internalActions.removeMutationResult({\n                            requestId,\n                            fixedCacheKey\n                        }));\n                    }\n                });\n            }, [\n                dispatch,\n                fixedCacheKey,\n                promise,\n                requestId\n            ]);\n            const { endpointName, data, status, isLoading, isSuccess, isError, error } = currentState;\n            (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)({\n                endpointName,\n                data,\n                status,\n                isLoading,\n                isSuccess,\n                isError,\n                error\n            });\n            const finalState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n                    ...currentState,\n                    originalArgs,\n                    reset\n                }), [\n                currentState,\n                originalArgs,\n                reset\n            ]);\n            return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>[\n                    triggerMutation,\n                    finalState\n                ], [\n                triggerMutation,\n                finalState\n            ]);\n        };\n    }\n}\n// src/query/endpointDefinitions.ts\nfunction isQueryDefinition(e) {\n    return e.type === \"query\" /* query */ ;\n}\nfunction isMutationDefinition(e) {\n    return e.type === \"mutation\" /* mutation */ ;\n}\n// src/query/utils/capitalize.ts\nfunction capitalize(str) {\n    return str.replace(str[0], str[0].toUpperCase());\n}\n// src/query/tsHelpers.ts\nfunction safeAssign(target, ...args) {\n    return Object.assign(target, ...args);\n}\n// src/query/react/module.ts\n\n// src/query/utils/countObjectKeys.ts\nfunction countObjectKeys(obj) {\n    let count = 0;\n    for(const _key in obj){\n        count++;\n    }\n    return count;\n}\n// src/query/react/module.ts\n\nvar reactHooksModuleName = /* @__PURE__ */ Symbol();\nvar reactHooksModule = ({ batch = react_redux__WEBPACK_IMPORTED_MODULE_1__.batch, hooks = {\n    useDispatch: react_redux__WEBPACK_IMPORTED_MODULE_1__.useDispatch,\n    useSelector: react_redux__WEBPACK_IMPORTED_MODULE_1__.useSelector,\n    useStore: react_redux__WEBPACK_IMPORTED_MODULE_1__.useStore\n}, createSelector: createSelector2 = reselect__WEBPACK_IMPORTED_MODULE_4__.createSelector, unstable__sideEffectsInRender = false, ...rest } = {})=>{\n    if (true) {\n        const hookNames = [\n            \"useDispatch\",\n            \"useSelector\",\n            \"useStore\"\n        ];\n        let warned = false;\n        for (const hookName of hookNames){\n            if (countObjectKeys(rest) > 0) {\n                if (rest[hookName]) {\n                    if (!warned) {\n                        console.warn(\"As of RTK 2.0, the hooks now need to be specified as one object, provided under a `hooks` key:\\n`reactHooksModule({ hooks: { useDispatch, useSelector, useStore } })`\");\n                        warned = true;\n                    }\n                }\n                hooks[hookName] = rest[hookName];\n            }\n            if (typeof hooks[hookName] !== \"function\") {\n                throw new Error( false ? 0 : `When using custom hooks for context, all ${hookNames.length} hooks need to be provided: ${hookNames.join(\", \")}.\nHook ${hookName} was either not provided or not a function.`);\n            }\n        }\n    }\n    return {\n        name: reactHooksModuleName,\n        init (api, { serializeQueryArgs }, context) {\n            const anyApi = api;\n            const { buildQueryHooks, buildMutationHook, usePrefetch } = buildHooks({\n                api,\n                moduleOptions: {\n                    batch,\n                    hooks,\n                    unstable__sideEffectsInRender,\n                    createSelector: createSelector2\n                },\n                serializeQueryArgs,\n                context\n            });\n            safeAssign(anyApi, {\n                usePrefetch\n            });\n            safeAssign(context, {\n                batch\n            });\n            return {\n                injectEndpoint (endpointName, definition) {\n                    if (isQueryDefinition(definition)) {\n                        const { useQuery, useLazyQuery, useLazyQuerySubscription, useQueryState, useQuerySubscription } = buildQueryHooks(endpointName);\n                        safeAssign(anyApi.endpoints[endpointName], {\n                            useQuery,\n                            useLazyQuery,\n                            useLazyQuerySubscription,\n                            useQueryState,\n                            useQuerySubscription\n                        });\n                        api[`use${capitalize(endpointName)}Query`] = useQuery;\n                        api[`useLazy${capitalize(endpointName)}Query`] = useLazyQuery;\n                    } else if (isMutationDefinition(definition)) {\n                        const useMutation = buildMutationHook(endpointName);\n                        safeAssign(anyApi.endpoints[endpointName], {\n                            useMutation\n                        });\n                        api[`use${capitalize(endpointName)}Mutation`] = useMutation;\n                    }\n                }\n            };\n        }\n    };\n};\n// src/query/react/index.ts\n\n// src/query/react/ApiProvider.tsx\n\n\n\n\n\n\n\nfunction ApiProvider(props) {\n    const context = props.context || react_redux__WEBPACK_IMPORTED_MODULE_1__.ReactReduxContext;\n    const existingContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(context);\n    if (existingContext) {\n        throw new Error( false ? 0 : \"Existing Redux context detected. If you already have a store set up, please use the traditional Redux setup.\");\n    }\n    const [store] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_5__.configureStore)({\n            reducer: {\n                [props.api.reducerPath]: props.api.reducer\n            },\n            middleware: (gDM)=>gDM().concat(props.api.middleware)\n        }));\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>props.setupListeners === false ? void 0 : (0,_reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.setupListeners)(store.dispatch, props.setupListeners), [\n        props.setupListeners,\n        store.dispatch\n    ]);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_redux__WEBPACK_IMPORTED_MODULE_1__.Provider, {\n        store,\n        context\n    }, props.children);\n}\n// src/query/react/index.ts\nvar createApi = /* @__PURE__ */ (0,_reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.buildCreateApi)((0,_reduxjs_toolkit_query__WEBPACK_IMPORTED_MODULE_3__.coreModule)(), reactHooksModule());\n //# sourceMappingURL=rtk-query-react.modern.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L3F1ZXJ5L3JlYWN0L3J0ay1xdWVyeS1yZWFjdC5tb2Rlcm4ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDJCQUEyQjtBQUN5QztBQUVwRSw0QkFBNEI7QUFDMEQ7QUFFdEYsZ0NBQWdDO0FBQ3NEO0FBQ0Q7QUFDMEQ7QUFDL0U7QUFDSjtBQUU1RCw4Q0FBOEM7QUFDSztBQUNuRCxTQUFTb0IsbUJBQW1CQyxTQUFTLEVBQUVDLFNBQVMsRUFBRUMsa0JBQWtCLEVBQUVDLFlBQVk7SUFDaEYsTUFBTUMsV0FBV2QsOENBQU9BLENBQUMsSUFBTztZQUM5QlU7WUFDQUssWUFBWSxPQUFPTCxhQUFhLFdBQVdDLFVBQVU7Z0JBQ25ERDtnQkFDQUU7Z0JBQ0FDO1lBQ0YsS0FBS0g7UUFDUCxJQUFJO1FBQUNBO1FBQVdDO1FBQVdDO1FBQW9CQztLQUFhO0lBQzVELE1BQU1HLFNBQVNkLDZDQUFNQSxDQUFDWTtJQUN0QmpCLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSW1CLE9BQU9DLE9BQU8sQ0FBQ0YsVUFBVSxLQUFLRCxTQUFTQyxVQUFVLEVBQUU7WUFDckRDLE9BQU9DLE9BQU8sR0FBR0g7UUFDbkI7SUFDRixHQUFHO1FBQUNBO0tBQVM7SUFDYixPQUFPRSxPQUFPQyxPQUFPLENBQUNGLFVBQVUsS0FBS0QsU0FBU0MsVUFBVSxHQUFHQyxPQUFPQyxPQUFPLENBQUNQLFNBQVMsR0FBR0E7QUFDeEY7QUFFQSwrQkFBK0I7QUFDL0IsSUFBSVEsc0JBQXNCQztBQUUxQiwyQ0FBMkM7QUFDd0I7QUFDeEI7QUFDM0MsU0FBU0csc0JBQXNCQyxLQUFLO0lBQ2xDLE1BQU1QLFNBQVNLLDZDQUFPQSxDQUFDRTtJQUN2QkgsZ0RBQVVBLENBQUM7UUFDVCxJQUFJLENBQUNiLHlEQUFZQSxDQUFDUyxPQUFPQyxPQUFPLEVBQUVNLFFBQVE7WUFDeENQLE9BQU9DLE9BQU8sR0FBR007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QU8sSUFBSXVJLDBEQUFpQkE7SUFDbEQsTUFBTUksa0JBQWtCUixpREFBVUEsQ0FBQ25JO0lBQ25DLElBQUkySSxpQkFBaUI7UUFDbkIsTUFBTSxJQUFJdEcsTUFBTUYsTUFBcUMsR0FBRzhGLENBQTRCLEdBQUc7SUFDekY7SUFDQSxNQUFNLENBQUNyRCxNQUFNLEdBQUd5RCwyQ0FBYyxDQUFDLElBQU1ILGdFQUFjQSxDQUFDO1lBQ2xEVSxTQUFTO2dCQUNQLENBQUNGLE1BQU1wSixHQUFHLENBQUNnRCxXQUFXLENBQUMsRUFBRW9HLE1BQU1wSixHQUFHLENBQUNzSixPQUFPO1lBQzVDO1lBQ0FDLFlBQVksQ0FBQ0MsTUFBUUEsTUFBTUMsTUFBTSxDQUFDTCxNQUFNcEosR0FBRyxDQUFDdUosVUFBVTtRQUN4RDtJQUNBVCxnREFBVUEsQ0FBQyxJQUFNTSxNQUFNRixjQUFjLEtBQUssUUFBUSxLQUFLLElBQUlBLHNFQUFjQSxDQUFDNUQsTUFBTTdELFFBQVEsRUFBRTJILE1BQU1GLGNBQWMsR0FBRztRQUFDRSxNQUFNRixjQUFjO1FBQUU1RCxNQUFNN0QsUUFBUTtLQUFDO0lBQ3ZKLE9BQU8sYUFBYSxpQkFBR3NILGdEQUFtQixDQUFDQyxpREFBUUEsRUFBRTtRQUFFMUQ7UUFBTzVFO0lBQVEsR0FBRzBJLE1BQU1NLFFBQVE7QUFDekY7QUFFQSwyQkFBMkI7QUFDM0IsSUFBSUMsWUFBWSxhQUFhLEdBQUc1TyxzRUFBY0EsQ0FBQ0Qsa0VBQVVBLElBQUlnTjtBQU0zRCxDQUNGLG1EQUFtRCIsInNvdXJjZXMiOlsid2VicGFjazovL2FuY2hvcnMuaW5fYXNzaWdubWVudC8uL25vZGVfbW9kdWxlcy9AcmVkdXhqcy90b29sa2l0L2Rpc3QvcXVlcnkvcmVhY3QvcnRrLXF1ZXJ5LXJlYWN0Lm1vZGVybi5tanM/Yzg0MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvcXVlcnkvcmVhY3QvaW5kZXgudHNcbmltcG9ydCB7IGNvcmVNb2R1bGUsIGJ1aWxkQ3JlYXRlQXBpIH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXQvcXVlcnlcIjtcblxuLy8gc3JjL3F1ZXJ5L3JlYWN0L21vZHVsZS50c1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTMgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xuXG4vLyBzcmMvcXVlcnkvcmVhY3QvYnVpbGRIb29rcy50c1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTIgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xuaW1wb3J0IHsgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSBhcyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRGVidWdWYWx1ZSwgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDMsIHVzZUxheW91dEVmZmVjdCwgdXNlTWVtbyBhcyB1c2VNZW1vMiwgdXNlUmVmIGFzIHVzZVJlZjMsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBRdWVyeVN0YXR1cywgc2tpcFRva2VuIH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXQvcXVlcnlcIjtcbmltcG9ydCB7IHNoYWxsb3dFcXVhbCBhcyBzaGFsbG93RXF1YWwyIH0gZnJvbSBcInJlYWN0LXJlZHV4XCI7XG5cbi8vIHNyYy9xdWVyeS9yZWFjdC91c2VTZXJpYWxpemVkU3RhYmxlVmFsdWUudHNcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VNZW1vIH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VTdGFibGVRdWVyeUFyZ3MocXVlcnlBcmdzLCBzZXJpYWxpemUsIGVuZHBvaW50RGVmaW5pdGlvbiwgZW5kcG9pbnROYW1lKSB7XG4gIGNvbnN0IGluY29taW5nID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIHF1ZXJ5QXJncyxcbiAgICBzZXJpYWxpemVkOiB0eXBlb2YgcXVlcnlBcmdzID09IFwib2JqZWN0XCIgPyBzZXJpYWxpemUoe1xuICAgICAgcXVlcnlBcmdzLFxuICAgICAgZW5kcG9pbnREZWZpbml0aW9uLFxuICAgICAgZW5kcG9pbnROYW1lXG4gICAgfSkgOiBxdWVyeUFyZ3NcbiAgfSksIFtxdWVyeUFyZ3MsIHNlcmlhbGl6ZSwgZW5kcG9pbnREZWZpbml0aW9uLCBlbmRwb2ludE5hbWVdKTtcbiAgY29uc3QgY2FjaGUyID0gdXNlUmVmKGluY29taW5nKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoY2FjaGUyLmN1cnJlbnQuc2VyaWFsaXplZCAhPT0gaW5jb21pbmcuc2VyaWFsaXplZCkge1xuICAgICAgY2FjaGUyLmN1cnJlbnQgPSBpbmNvbWluZztcbiAgICB9XG4gIH0sIFtpbmNvbWluZ10pO1xuICByZXR1cm4gY2FjaGUyLmN1cnJlbnQuc2VyaWFsaXplZCA9PT0gaW5jb21pbmcuc2VyaWFsaXplZCA/IGNhY2hlMi5jdXJyZW50LnF1ZXJ5QXJncyA6IHF1ZXJ5QXJncztcbn1cblxuLy8gc3JjL3F1ZXJ5L3JlYWN0L2NvbnN0YW50cy50c1xudmFyIFVOSU5JVElBTElaRURfVkFMVUUgPSBTeW1ib2woKTtcblxuLy8gc3JjL3F1ZXJ5L3JlYWN0L3VzZVNoYWxsb3dTdGFibGVWYWx1ZS50c1xuaW1wb3J0IHsgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDIsIHVzZVJlZiBhcyB1c2VSZWYyIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBzaGFsbG93RXF1YWwgfSBmcm9tIFwicmVhY3QtcmVkdXhcIjtcbmZ1bmN0aW9uIHVzZVNoYWxsb3dTdGFibGVWYWx1ZSh2YWx1ZSkge1xuICBjb25zdCBjYWNoZTIgPSB1c2VSZWYyKHZhbHVlKTtcbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgaWYgKCFzaGFsbG93RXF1YWwoY2FjaGUyLmN1cnJlbnQsIHZhbHVlKSkge1xuICAgICAgY2FjaGUyLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICB9XG4gIH0sIFt2YWx1ZV0pO1xuICByZXR1cm4gc2hhbGxvd0VxdWFsKGNhY2hlMi5jdXJyZW50LCB2YWx1ZSkgPyBjYWNoZTIuY3VycmVudCA6IHZhbHVlO1xufVxuXG4vLyBzcmMvcXVlcnkvY29yZS9ydGtJbXBvcnRzLnRzXG5pbXBvcnQgeyBjcmVhdGVBY3Rpb24sIGNyZWF0ZVNsaWNlLCBjcmVhdGVTZWxlY3RvciwgY3JlYXRlQXN5bmNUaHVuaywgY29tYmluZVJlZHVjZXJzLCBjcmVhdGVOZXh0U3RhdGUsIGlzQW55T2YsIGlzQWxsT2YsIGlzQWN0aW9uLCBpc1BlbmRpbmcsIGlzUmVqZWN0ZWQsIGlzRnVsZmlsbGVkLCBpc1JlamVjdGVkV2l0aFZhbHVlLCBpc0FzeW5jVGh1bmtBY3Rpb24sIHByZXBhcmVBdXRvQmF0Y2hlZCwgU0hPVUxEX0FVVE9CQVRDSCwgaXNQbGFpbk9iamVjdCwgbmFub2lkIH0gZnJvbSBcIkByZWR1eGpzL3Rvb2xraXRcIjtcblxuLy8gc3JjL3F1ZXJ5L2RlZmF1bHRTZXJpYWxpemVRdWVyeUFyZ3MudHNcbnZhciBjYWNoZSA9IFdlYWtNYXAgPyAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSA6IHZvaWQgMDtcbnZhciBkZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzID0gKHtcbiAgZW5kcG9pbnROYW1lLFxuICBxdWVyeUFyZ3Ncbn0pID0+IHtcbiAgbGV0IHNlcmlhbGl6ZWQgPSBcIlwiO1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZT8uZ2V0KHF1ZXJ5QXJncyk7XG4gIGlmICh0eXBlb2YgY2FjaGVkID09PSBcInN0cmluZ1wiKSB7XG4gICAgc2VyaWFsaXplZCA9IGNhY2hlZDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzdHJpbmdpZmllZCA9IEpTT04uc3RyaW5naWZ5KHF1ZXJ5QXJncywgKGtleSwgdmFsdWUpID0+IGlzUGxhaW5PYmplY3QodmFsdWUpID8gT2JqZWN0LmtleXModmFsdWUpLnNvcnQoKS5yZWR1Y2UoKGFjYywga2V5MikgPT4ge1xuICAgICAgYWNjW2tleTJdID0gdmFsdWVba2V5Ml07XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KSA6IHZhbHVlKTtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChxdWVyeUFyZ3MpKSB7XG4gICAgICBjYWNoZT8uc2V0KHF1ZXJ5QXJncywgc3RyaW5naWZpZWQpO1xuICAgIH1cbiAgICBzZXJpYWxpemVkID0gc3RyaW5naWZpZWQ7XG4gIH1cbiAgcmV0dXJuIGAke2VuZHBvaW50TmFtZX0oJHtzZXJpYWxpemVkfSlgO1xufTtcblxuLy8gc3JjL3F1ZXJ5L3JlYWN0L2J1aWxkSG9va3MudHNcbnZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhIXdpbmRvdy5kb2N1bWVudCAmJiAhIXdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0MztcbnZhciBub1BlbmRpbmdRdWVyeVN0YXRlU2VsZWN0b3IgPSAoc2VsZWN0ZWQpID0+IHtcbiAgaWYgKHNlbGVjdGVkLmlzVW5pbml0aWFsaXplZCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zZWxlY3RlZCxcbiAgICAgIGlzVW5pbml0aWFsaXplZDogZmFsc2UsXG4gICAgICBpc0ZldGNoaW5nOiB0cnVlLFxuICAgICAgaXNMb2FkaW5nOiBzZWxlY3RlZC5kYXRhICE9PSB2b2lkIDAgPyBmYWxzZSA6IHRydWUsXG4gICAgICBzdGF0dXM6IFF1ZXJ5U3RhdHVzLnBlbmRpbmdcbiAgICB9O1xuICB9XG4gIHJldHVybiBzZWxlY3RlZDtcbn07XG5mdW5jdGlvbiBidWlsZEhvb2tzKHtcbiAgYXBpLFxuICBtb2R1bGVPcHRpb25zOiB7XG4gICAgYmF0Y2gsXG4gICAgaG9va3M6IHtcbiAgICAgIHVzZURpc3BhdGNoLFxuICAgICAgdXNlU2VsZWN0b3IsXG4gICAgICB1c2VTdG9yZVxuICAgIH0sXG4gICAgdW5zdGFibGVfX3NpZGVFZmZlY3RzSW5SZW5kZXIsXG4gICAgY3JlYXRlU2VsZWN0b3I6IGNyZWF0ZVNlbGVjdG9yMlxuICB9LFxuICBzZXJpYWxpemVRdWVyeUFyZ3MsXG4gIGNvbnRleHRcbn0pIHtcbiAgY29uc3QgdXNlUG9zc2libHlJbW1lZGlhdGVFZmZlY3QgPSB1bnN0YWJsZV9fc2lkZUVmZmVjdHNJblJlbmRlciA/IChjYikgPT4gY2IoKSA6IHVzZUVmZmVjdDM7XG4gIHJldHVybiB7XG4gICAgYnVpbGRRdWVyeUhvb2tzLFxuICAgIGJ1aWxkTXV0YXRpb25Ib29rLFxuICAgIHVzZVByZWZldGNoXG4gIH07XG4gIGZ1bmN0aW9uIHF1ZXJ5U3RhdGVQcmVTZWxlY3RvcihjdXJyZW50U3RhdGUsIGxhc3RSZXN1bHQsIHF1ZXJ5QXJncykge1xuICAgIGlmIChsYXN0UmVzdWx0Py5lbmRwb2ludE5hbWUgJiYgY3VycmVudFN0YXRlLmlzVW5pbml0aWFsaXplZCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbmRwb2ludE5hbWVcbiAgICAgIH0gPSBsYXN0UmVzdWx0O1xuICAgICAgY29uc3QgZW5kcG9pbnREZWZpbml0aW9uID0gY29udGV4dC5lbmRwb2ludERlZmluaXRpb25zW2VuZHBvaW50TmFtZV07XG4gICAgICBpZiAoc2VyaWFsaXplUXVlcnlBcmdzKHtcbiAgICAgICAgcXVlcnlBcmdzOiBsYXN0UmVzdWx0Lm9yaWdpbmFsQXJncyxcbiAgICAgICAgZW5kcG9pbnREZWZpbml0aW9uLFxuICAgICAgICBlbmRwb2ludE5hbWVcbiAgICAgIH0pID09PSBzZXJpYWxpemVRdWVyeUFyZ3Moe1xuICAgICAgICBxdWVyeUFyZ3MsXG4gICAgICAgIGVuZHBvaW50RGVmaW5pdGlvbixcbiAgICAgICAgZW5kcG9pbnROYW1lXG4gICAgICB9KSlcbiAgICAgICAgbGFzdFJlc3VsdCA9IHZvaWQgMDtcbiAgICB9XG4gICAgbGV0IGRhdGEgPSBjdXJyZW50U3RhdGUuaXNTdWNjZXNzID8gY3VycmVudFN0YXRlLmRhdGEgOiBsYXN0UmVzdWx0Py5kYXRhO1xuICAgIGlmIChkYXRhID09PSB2b2lkIDApXG4gICAgICBkYXRhID0gY3VycmVudFN0YXRlLmRhdGE7XG4gICAgY29uc3QgaGFzRGF0YSA9IGRhdGEgIT09IHZvaWQgMDtcbiAgICBjb25zdCBpc0ZldGNoaW5nID0gY3VycmVudFN0YXRlLmlzTG9hZGluZztcbiAgICBjb25zdCBpc0xvYWRpbmcgPSAhaGFzRGF0YSAmJiBpc0ZldGNoaW5nO1xuICAgIGNvbnN0IGlzU3VjY2VzcyA9IGN1cnJlbnRTdGF0ZS5pc1N1Y2Nlc3MgfHwgaXNGZXRjaGluZyAmJiBoYXNEYXRhO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5jdXJyZW50U3RhdGUsXG4gICAgICBkYXRhLFxuICAgICAgY3VycmVudERhdGE6IGN1cnJlbnRTdGF0ZS5kYXRhLFxuICAgICAgaXNGZXRjaGluZyxcbiAgICAgIGlzTG9hZGluZyxcbiAgICAgIGlzU3VjY2Vzc1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gdXNlUHJlZmV0Y2goZW5kcG9pbnROYW1lLCBkZWZhdWx0T3B0aW9ucykge1xuICAgIGNvbnN0IGRpc3BhdGNoID0gdXNlRGlzcGF0Y2goKTtcbiAgICBjb25zdCBzdGFibGVEZWZhdWx0T3B0aW9ucyA9IHVzZVNoYWxsb3dTdGFibGVWYWx1ZShkZWZhdWx0T3B0aW9ucyk7XG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKChhcmcsIG9wdGlvbnMpID0+IGRpc3BhdGNoKGFwaS51dGlsLnByZWZldGNoKGVuZHBvaW50TmFtZSwgYXJnLCB7XG4gICAgICAuLi5zdGFibGVEZWZhdWx0T3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KSksIFtlbmRwb2ludE5hbWUsIGRpc3BhdGNoLCBzdGFibGVEZWZhdWx0T3B0aW9uc10pO1xuICB9XG4gIGZ1bmN0aW9uIGJ1aWxkUXVlcnlIb29rcyhuYW1lKSB7XG4gICAgY29uc3QgdXNlUXVlcnlTdWJzY3JpcHRpb24gPSAoYXJnLCB7XG4gICAgICByZWZldGNoT25SZWNvbm5lY3QsXG4gICAgICByZWZldGNoT25Gb2N1cyxcbiAgICAgIHJlZmV0Y2hPbk1vdW50T3JBcmdDaGFuZ2UsXG4gICAgICBza2lwID0gZmFsc2UsXG4gICAgICBwb2xsaW5nSW50ZXJ2YWwgPSAwLFxuICAgICAgc2tpcFBvbGxpbmdJZlVuZm9jdXNlZCA9IGZhbHNlXG4gICAgfSA9IHt9KSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGluaXRpYXRlXG4gICAgICB9ID0gYXBpLmVuZHBvaW50c1tuYW1lXTtcbiAgICAgIGNvbnN0IGRpc3BhdGNoID0gdXNlRGlzcGF0Y2goKTtcbiAgICAgIGNvbnN0IHN1YnNjcmlwdGlvblNlbGVjdG9yc1JlZiA9IHVzZVJlZjMoKTtcbiAgICAgIGlmICghc3Vic2NyaXB0aW9uU2VsZWN0b3JzUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY29uc3QgcmV0dXJuZWRWYWx1ZSA9IGRpc3BhdGNoKGFwaS5pbnRlcm5hbEFjdGlvbnMuaW50ZXJuYWxfZ2V0UlRLUVN1YnNjcmlwdGlvbnMoKSk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHJldHVybmVkVmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHJldHVybmVkVmFsdWU/LnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzNykgOiBgV2FybmluZzogTWlkZGxld2FyZSBmb3IgUlRLLVF1ZXJ5IEFQSSBhdCByZWR1Y2VyUGF0aCBcIiR7YXBpLnJlZHVjZXJQYXRofVwiIGhhcyBub3QgYmVlbiBhZGRlZCB0byB0aGUgc3RvcmUuXG4gICAgWW91IG11c3QgYWRkIHRoZSBtaWRkbGV3YXJlIGZvciBSVEstUXVlcnkgdG8gZnVuY3Rpb24gY29ycmVjdGx5IWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpcHRpb25TZWxlY3RvcnNSZWYuY3VycmVudCA9IHJldHVybmVkVmFsdWU7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGFibGVBcmcgPSB1c2VTdGFibGVRdWVyeUFyZ3MoXG4gICAgICAgIHNraXAgPyBza2lwVG9rZW4gOiBhcmcsXG4gICAgICAgIC8vIEV2ZW4gaWYgdGhlIHVzZXIgcHJvdmlkZWQgYSBwZXItZW5kcG9pbnQgYHNlcmlhbGl6ZVF1ZXJ5QXJnc2Agd2l0aFxuICAgICAgICAvLyBhIGNvbnNpc3RlbnQgcmV0dXJuIHZhbHVlLCBfaGVyZV8gd2Ugd2FudCB0byB1c2UgdGhlIGRlZmF1bHQgYmVoYXZpb3JcbiAgICAgICAgLy8gc28gd2UgY2FuIHRlbGwgaWYgX2FueXRoaW5nXyBhY3R1YWxseSBjaGFuZ2VkLiBPdGhlcndpc2UsIHdlIGNhbiBlbmQgdXBcbiAgICAgICAgLy8gd2l0aCBhIGNhc2Ugd2hlcmUgdGhlIHF1ZXJ5IGFyZ3MgZGlkIGNoYW5nZSBidXQgdGhlIHNlcmlhbGl6YXRpb24gZG9lc24ndCxcbiAgICAgICAgLy8gYW5kIHRoZW4gd2UgbmV2ZXIgdHJ5IHRvIGluaXRpYXRlIGEgcmVmZXRjaC5cbiAgICAgICAgZGVmYXVsdFNlcmlhbGl6ZVF1ZXJ5QXJncyxcbiAgICAgICAgY29udGV4dC5lbmRwb2ludERlZmluaXRpb25zW25hbWVdLFxuICAgICAgICBuYW1lXG4gICAgICApO1xuICAgICAgY29uc3Qgc3RhYmxlU3Vic2NyaXB0aW9uT3B0aW9ucyA9IHVzZVNoYWxsb3dTdGFibGVWYWx1ZSh7XG4gICAgICAgIHJlZmV0Y2hPblJlY29ubmVjdCxcbiAgICAgICAgcmVmZXRjaE9uRm9jdXMsXG4gICAgICAgIHBvbGxpbmdJbnRlcnZhbCxcbiAgICAgICAgc2tpcFBvbGxpbmdJZlVuZm9jdXNlZFxuICAgICAgfSk7XG4gICAgICBjb25zdCBsYXN0UmVuZGVySGFkU3Vic2NyaXB0aW9uID0gdXNlUmVmMyhmYWxzZSk7XG4gICAgICBjb25zdCBwcm9taXNlUmVmID0gdXNlUmVmMygpO1xuICAgICAgbGV0IHtcbiAgICAgICAgcXVlcnlDYWNoZUtleSxcbiAgICAgICAgcmVxdWVzdElkXG4gICAgICB9ID0gcHJvbWlzZVJlZi5jdXJyZW50IHx8IHt9O1xuICAgICAgbGV0IGN1cnJlbnRSZW5kZXJIYXNTdWJzY3JpcHRpb24gPSBmYWxzZTtcbiAgICAgIGlmIChxdWVyeUNhY2hlS2V5ICYmIHJlcXVlc3RJZCkge1xuICAgICAgICBjdXJyZW50UmVuZGVySGFzU3Vic2NyaXB0aW9uID0gc3Vic2NyaXB0aW9uU2VsZWN0b3JzUmVmLmN1cnJlbnQuaXNSZXF1ZXN0U3Vic2NyaWJlZChxdWVyeUNhY2hlS2V5LCByZXF1ZXN0SWQpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uUmVtb3ZlZCA9ICFjdXJyZW50UmVuZGVySGFzU3Vic2NyaXB0aW9uICYmIGxhc3RSZW5kZXJIYWRTdWJzY3JpcHRpb24uY3VycmVudDtcbiAgICAgIHVzZVBvc3NpYmx5SW1tZWRpYXRlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgbGFzdFJlbmRlckhhZFN1YnNjcmlwdGlvbi5jdXJyZW50ID0gY3VycmVudFJlbmRlckhhc1N1YnNjcmlwdGlvbjtcbiAgICAgIH0pO1xuICAgICAgdXNlUG9zc2libHlJbW1lZGlhdGVFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uUmVtb3ZlZCkge1xuICAgICAgICAgIHByb21pc2VSZWYuY3VycmVudCA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfSwgW3N1YnNjcmlwdGlvblJlbW92ZWRdKTtcbiAgICAgIHVzZVBvc3NpYmx5SW1tZWRpYXRlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgbGFzdFByb21pc2UgPSBwcm9taXNlUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJyZW1vdmVNZU9uQ29tcGlsYXRpb25cIikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKHN1YnNjcmlwdGlvblJlbW92ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFibGVBcmcgPT09IHNraXBUb2tlbikge1xuICAgICAgICAgIGxhc3RQcm9taXNlPy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIHByb21pc2VSZWYuY3VycmVudCA9IHZvaWQgMDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFzdFN1YnNjcmlwdGlvbk9wdGlvbnMgPSBwcm9taXNlUmVmLmN1cnJlbnQ/LnN1YnNjcmlwdGlvbk9wdGlvbnM7XG4gICAgICAgIGlmICghbGFzdFByb21pc2UgfHwgbGFzdFByb21pc2UuYXJnICE9PSBzdGFibGVBcmcpIHtcbiAgICAgICAgICBsYXN0UHJvbWlzZT8udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICBjb25zdCBwcm9taXNlID0gZGlzcGF0Y2goaW5pdGlhdGUoc3RhYmxlQXJnLCB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25PcHRpb25zOiBzdGFibGVTdWJzY3JpcHRpb25PcHRpb25zLFxuICAgICAgICAgICAgZm9yY2VSZWZldGNoOiByZWZldGNoT25Nb3VudE9yQXJnQ2hhbmdlXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHByb21pc2VSZWYuY3VycmVudCA9IHByb21pc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhYmxlU3Vic2NyaXB0aW9uT3B0aW9ucyAhPT0gbGFzdFN1YnNjcmlwdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgICBsYXN0UHJvbWlzZS51cGRhdGVTdWJzY3JpcHRpb25PcHRpb25zKHN0YWJsZVN1YnNjcmlwdGlvbk9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9LCBbZGlzcGF0Y2gsIGluaXRpYXRlLCByZWZldGNoT25Nb3VudE9yQXJnQ2hhbmdlLCBzdGFibGVBcmcsIHN0YWJsZVN1YnNjcmlwdGlvbk9wdGlvbnMsIHN1YnNjcmlwdGlvblJlbW92ZWRdKTtcbiAgICAgIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIHByb21pc2VSZWYuY3VycmVudD8udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICBwcm9taXNlUmVmLmN1cnJlbnQgPSB2b2lkIDA7XG4gICAgICAgIH07XG4gICAgICB9LCBbXSk7XG4gICAgICByZXR1cm4gdXNlTWVtbzIoKCkgPT4gKHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbWV0aG9kIHRvIG1hbnVhbGx5IHJlZmV0Y2ggZGF0YSBmb3IgdGhlIHF1ZXJ5XG4gICAgICAgICAqL1xuICAgICAgICByZWZldGNoOiAoKSA9PiB7XG4gICAgICAgICAgaWYgKCFwcm9taXNlUmVmLmN1cnJlbnQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UyKDM4KSA6IFwiQ2Fubm90IHJlZmV0Y2ggYSBxdWVyeSB0aGF0IGhhcyBub3QgYmVlbiBzdGFydGVkIHlldC5cIik7XG4gICAgICAgICAgcmV0dXJuIHByb21pc2VSZWYuY3VycmVudD8ucmVmZXRjaCgpO1xuICAgICAgICB9XG4gICAgICB9KSwgW10pO1xuICAgIH07XG4gICAgY29uc3QgdXNlTGF6eVF1ZXJ5U3Vic2NyaXB0aW9uID0gKHtcbiAgICAgIHJlZmV0Y2hPblJlY29ubmVjdCxcbiAgICAgIHJlZmV0Y2hPbkZvY3VzLFxuICAgICAgcG9sbGluZ0ludGVydmFsID0gMCxcbiAgICAgIHNraXBQb2xsaW5nSWZVbmZvY3VzZWQgPSBmYWxzZVxuICAgIH0gPSB7fSkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBpbml0aWF0ZVxuICAgICAgfSA9IGFwaS5lbmRwb2ludHNbbmFtZV07XG4gICAgICBjb25zdCBkaXNwYXRjaCA9IHVzZURpc3BhdGNoKCk7XG4gICAgICBjb25zdCBbYXJnLCBzZXRBcmddID0gdXNlU3RhdGUoVU5JTklUSUFMSVpFRF9WQUxVRSk7XG4gICAgICBjb25zdCBwcm9taXNlUmVmID0gdXNlUmVmMygpO1xuICAgICAgY29uc3Qgc3RhYmxlU3Vic2NyaXB0aW9uT3B0aW9ucyA9IHVzZVNoYWxsb3dTdGFibGVWYWx1ZSh7XG4gICAgICAgIHJlZmV0Y2hPblJlY29ubmVjdCxcbiAgICAgICAgcmVmZXRjaE9uRm9jdXMsXG4gICAgICAgIHBvbGxpbmdJbnRlcnZhbCxcbiAgICAgICAgc2tpcFBvbGxpbmdJZlVuZm9jdXNlZFxuICAgICAgfSk7XG4gICAgICB1c2VQb3NzaWJseUltbWVkaWF0ZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxhc3RTdWJzY3JpcHRpb25PcHRpb25zID0gcHJvbWlzZVJlZi5jdXJyZW50Py5zdWJzY3JpcHRpb25PcHRpb25zO1xuICAgICAgICBpZiAoc3RhYmxlU3Vic2NyaXB0aW9uT3B0aW9ucyAhPT0gbGFzdFN1YnNjcmlwdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgICBwcm9taXNlUmVmLmN1cnJlbnQ/LnVwZGF0ZVN1YnNjcmlwdGlvbk9wdGlvbnMoc3RhYmxlU3Vic2NyaXB0aW9uT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0sIFtzdGFibGVTdWJzY3JpcHRpb25PcHRpb25zXSk7XG4gICAgICBjb25zdCBzdWJzY3JpcHRpb25PcHRpb25zUmVmID0gdXNlUmVmMyhzdGFibGVTdWJzY3JpcHRpb25PcHRpb25zKTtcbiAgICAgIHVzZVBvc3NpYmx5SW1tZWRpYXRlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc3Vic2NyaXB0aW9uT3B0aW9uc1JlZi5jdXJyZW50ID0gc3RhYmxlU3Vic2NyaXB0aW9uT3B0aW9ucztcbiAgICAgIH0sIFtzdGFibGVTdWJzY3JpcHRpb25PcHRpb25zXSk7XG4gICAgICBjb25zdCB0cmlnZ2VyID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24oYXJnMiwgcHJlZmVyQ2FjaGVWYWx1ZSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBwcm9taXNlO1xuICAgICAgICBiYXRjaCgoKSA9PiB7XG4gICAgICAgICAgcHJvbWlzZVJlZi5jdXJyZW50Py51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIHByb21pc2VSZWYuY3VycmVudCA9IHByb21pc2UgPSBkaXNwYXRjaChpbml0aWF0ZShhcmcyLCB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25PcHRpb25zOiBzdWJzY3JpcHRpb25PcHRpb25zUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBmb3JjZVJlZmV0Y2g6ICFwcmVmZXJDYWNoZVZhbHVlXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHNldEFyZyhhcmcyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgfSwgW2Rpc3BhdGNoLCBpbml0aWF0ZV0pO1xuICAgICAgdXNlRWZmZWN0MygoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgcHJvbWlzZVJlZj8uY3VycmVudD8udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfTtcbiAgICAgIH0sIFtdKTtcbiAgICAgIHVzZUVmZmVjdDMoKCkgPT4ge1xuICAgICAgICBpZiAoYXJnICE9PSBVTklOSVRJQUxJWkVEX1ZBTFVFICYmICFwcm9taXNlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICB0cmlnZ2VyKGFyZywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIFthcmcsIHRyaWdnZXJdKTtcbiAgICAgIHJldHVybiB1c2VNZW1vMigoKSA9PiBbdHJpZ2dlciwgYXJnXSwgW3RyaWdnZXIsIGFyZ10pO1xuICAgIH07XG4gICAgY29uc3QgdXNlUXVlcnlTdGF0ZSA9IChhcmcsIHtcbiAgICAgIHNraXAgPSBmYWxzZSxcbiAgICAgIHNlbGVjdEZyb21SZXN1bHRcbiAgICB9ID0ge30pID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2VsZWN0XG4gICAgICB9ID0gYXBpLmVuZHBvaW50c1tuYW1lXTtcbiAgICAgIGNvbnN0IHN0YWJsZUFyZyA9IHVzZVN0YWJsZVF1ZXJ5QXJncyhza2lwID8gc2tpcFRva2VuIDogYXJnLCBzZXJpYWxpemVRdWVyeUFyZ3MsIGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9uc1tuYW1lXSwgbmFtZSk7XG4gICAgICBjb25zdCBsYXN0VmFsdWUgPSB1c2VSZWYzKCk7XG4gICAgICBjb25zdCBzZWxlY3REZWZhdWx0UmVzdWx0ID0gdXNlTWVtbzIoKCkgPT4gY3JlYXRlU2VsZWN0b3IyKFtzZWxlY3Qoc3RhYmxlQXJnKSwgKF8sIGxhc3RSZXN1bHQpID0+IGxhc3RSZXN1bHQsIChfKSA9PiBzdGFibGVBcmddLCBxdWVyeVN0YXRlUHJlU2VsZWN0b3IsIHtcbiAgICAgICAgbWVtb2l6ZU9wdGlvbnM6IHtcbiAgICAgICAgICByZXN1bHRFcXVhbGl0eUNoZWNrOiBzaGFsbG93RXF1YWwyXG4gICAgICAgIH1cbiAgICAgIH0pLCBbc2VsZWN0LCBzdGFibGVBcmddKTtcbiAgICAgIGNvbnN0IHF1ZXJ5U2VsZWN0b3IgPSB1c2VNZW1vMigoKSA9PiBzZWxlY3RGcm9tUmVzdWx0ID8gY3JlYXRlU2VsZWN0b3IyKFtzZWxlY3REZWZhdWx0UmVzdWx0XSwgc2VsZWN0RnJvbVJlc3VsdCwge1xuICAgICAgICBkZXZNb2RlQ2hlY2tzOiB7XG4gICAgICAgICAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrOiBcIm5ldmVyXCJcbiAgICAgICAgfVxuICAgICAgfSkgOiBzZWxlY3REZWZhdWx0UmVzdWx0LCBbc2VsZWN0RGVmYXVsdFJlc3VsdCwgc2VsZWN0RnJvbVJlc3VsdF0pO1xuICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gdXNlU2VsZWN0b3IoKHN0YXRlKSA9PiBxdWVyeVNlbGVjdG9yKHN0YXRlLCBsYXN0VmFsdWUuY3VycmVudCksIHNoYWxsb3dFcXVhbDIpO1xuICAgICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZSgpO1xuICAgICAgY29uc3QgbmV3TGFzdFZhbHVlID0gc2VsZWN0RGVmYXVsdFJlc3VsdChzdG9yZS5nZXRTdGF0ZSgpLCBsYXN0VmFsdWUuY3VycmVudCk7XG4gICAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgbGFzdFZhbHVlLmN1cnJlbnQgPSBuZXdMYXN0VmFsdWU7XG4gICAgICB9LCBbbmV3TGFzdFZhbHVlXSk7XG4gICAgICByZXR1cm4gY3VycmVudFN0YXRlO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZVF1ZXJ5U3RhdGUsXG4gICAgICB1c2VRdWVyeVN1YnNjcmlwdGlvbixcbiAgICAgIHVzZUxhenlRdWVyeVN1YnNjcmlwdGlvbixcbiAgICAgIHVzZUxhenlRdWVyeShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IFt0cmlnZ2VyLCBhcmddID0gdXNlTGF6eVF1ZXJ5U3Vic2NyaXB0aW9uKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBxdWVyeVN0YXRlUmVzdWx0cyA9IHVzZVF1ZXJ5U3RhdGUoYXJnLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICBza2lwOiBhcmcgPT09IFVOSU5JVElBTElaRURfVkFMVUVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGluZm8gPSB1c2VNZW1vMigoKSA9PiAoe1xuICAgICAgICAgIGxhc3RBcmc6IGFyZ1xuICAgICAgICB9KSwgW2FyZ10pO1xuICAgICAgICByZXR1cm4gdXNlTWVtbzIoKCkgPT4gW3RyaWdnZXIsIHF1ZXJ5U3RhdGVSZXN1bHRzLCBpbmZvXSwgW3RyaWdnZXIsIHF1ZXJ5U3RhdGVSZXN1bHRzLCBpbmZvXSk7XG4gICAgICB9LFxuICAgICAgdXNlUXVlcnkoYXJnLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5U3Vic2NyaXB0aW9uUmVzdWx0cyA9IHVzZVF1ZXJ5U3Vic2NyaXB0aW9uKGFyZywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHF1ZXJ5U3RhdGVSZXN1bHRzID0gdXNlUXVlcnlTdGF0ZShhcmcsIHtcbiAgICAgICAgICBzZWxlY3RGcm9tUmVzdWx0OiBhcmcgPT09IHNraXBUb2tlbiB8fCBvcHRpb25zPy5za2lwID8gdm9pZCAwIDogbm9QZW5kaW5nUXVlcnlTdGF0ZVNlbGVjdG9yLFxuICAgICAgICAgIC4uLm9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICBpc0xvYWRpbmcsXG4gICAgICAgICAgaXNTdWNjZXNzLFxuICAgICAgICAgIGlzRXJyb3IsXG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgfSA9IHF1ZXJ5U3RhdGVSZXN1bHRzO1xuICAgICAgICB1c2VEZWJ1Z1ZhbHVlKHtcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICBpc0xvYWRpbmcsXG4gICAgICAgICAgaXNTdWNjZXNzLFxuICAgICAgICAgIGlzRXJyb3IsXG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB1c2VNZW1vMigoKSA9PiAoe1xuICAgICAgICAgIC4uLnF1ZXJ5U3RhdGVSZXN1bHRzLFxuICAgICAgICAgIC4uLnF1ZXJ5U3Vic2NyaXB0aW9uUmVzdWx0c1xuICAgICAgICB9KSwgW3F1ZXJ5U3RhdGVSZXN1bHRzLCBxdWVyeVN1YnNjcmlwdGlvblJlc3VsdHNdKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGJ1aWxkTXV0YXRpb25Ib29rKG5hbWUpIHtcbiAgICByZXR1cm4gKHtcbiAgICAgIHNlbGVjdEZyb21SZXN1bHQsXG4gICAgICBmaXhlZENhY2hlS2V5XG4gICAgfSA9IHt9KSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNlbGVjdCxcbiAgICAgICAgaW5pdGlhdGVcbiAgICAgIH0gPSBhcGkuZW5kcG9pbnRzW25hbWVdO1xuICAgICAgY29uc3QgZGlzcGF0Y2ggPSB1c2VEaXNwYXRjaCgpO1xuICAgICAgY29uc3QgW3Byb21pc2UsIHNldFByb21pc2VdID0gdXNlU3RhdGUoKTtcbiAgICAgIHVzZUVmZmVjdDMoKCkgPT4gKCkgPT4ge1xuICAgICAgICBpZiAoIXByb21pc2U/LmFyZy5maXhlZENhY2hlS2V5KSB7XG4gICAgICAgICAgcHJvbWlzZT8ucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgfSwgW3Byb21pc2VdKTtcbiAgICAgIGNvbnN0IHRyaWdnZXJNdXRhdGlvbiA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uKGFyZykge1xuICAgICAgICBjb25zdCBwcm9taXNlMiA9IGRpc3BhdGNoKGluaXRpYXRlKGFyZywge1xuICAgICAgICAgIGZpeGVkQ2FjaGVLZXlcbiAgICAgICAgfSkpO1xuICAgICAgICBzZXRQcm9taXNlKHByb21pc2UyKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2UyO1xuICAgICAgfSwgW2Rpc3BhdGNoLCBpbml0aWF0ZSwgZml4ZWRDYWNoZUtleV0pO1xuICAgICAgY29uc3Qge1xuICAgICAgICByZXF1ZXN0SWRcbiAgICAgIH0gPSBwcm9taXNlIHx8IHt9O1xuICAgICAgY29uc3Qgc2VsZWN0RGVmYXVsdFJlc3VsdCA9IHVzZU1lbW8yKCgpID0+IHNlbGVjdCh7XG4gICAgICAgIGZpeGVkQ2FjaGVLZXksXG4gICAgICAgIHJlcXVlc3RJZDogcHJvbWlzZT8ucmVxdWVzdElkXG4gICAgICB9KSwgW2ZpeGVkQ2FjaGVLZXksIHByb21pc2UsIHNlbGVjdF0pO1xuICAgICAgY29uc3QgbXV0YXRpb25TZWxlY3RvciA9IHVzZU1lbW8yKCgpID0+IHNlbGVjdEZyb21SZXN1bHQgPyBjcmVhdGVTZWxlY3RvcjIoW3NlbGVjdERlZmF1bHRSZXN1bHRdLCBzZWxlY3RGcm9tUmVzdWx0KSA6IHNlbGVjdERlZmF1bHRSZXN1bHQsIFtzZWxlY3RGcm9tUmVzdWx0LCBzZWxlY3REZWZhdWx0UmVzdWx0XSk7XG4gICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSB1c2VTZWxlY3RvcihtdXRhdGlvblNlbGVjdG9yLCBzaGFsbG93RXF1YWwyKTtcbiAgICAgIGNvbnN0IG9yaWdpbmFsQXJncyA9IGZpeGVkQ2FjaGVLZXkgPT0gbnVsbCA/IHByb21pc2U/LmFyZy5vcmlnaW5hbEFyZ3MgOiB2b2lkIDA7XG4gICAgICBjb25zdCByZXNldCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgYmF0Y2goKCkgPT4ge1xuICAgICAgICAgIGlmIChwcm9taXNlKSB7XG4gICAgICAgICAgICBzZXRQcm9taXNlKHZvaWQgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmaXhlZENhY2hlS2V5KSB7XG4gICAgICAgICAgICBkaXNwYXRjaChhcGkuaW50ZXJuYWxBY3Rpb25zLnJlbW92ZU11dGF0aW9uUmVzdWx0KHtcbiAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICBmaXhlZENhY2hlS2V5XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sIFtkaXNwYXRjaCwgZml4ZWRDYWNoZUtleSwgcHJvbWlzZSwgcmVxdWVzdElkXSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVuZHBvaW50TmFtZSxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBpc0xvYWRpbmcsXG4gICAgICAgIGlzU3VjY2VzcyxcbiAgICAgICAgaXNFcnJvcixcbiAgICAgICAgZXJyb3JcbiAgICAgIH0gPSBjdXJyZW50U3RhdGU7XG4gICAgICB1c2VEZWJ1Z1ZhbHVlKHtcbiAgICAgICAgZW5kcG9pbnROYW1lLFxuICAgICAgICBkYXRhLFxuICAgICAgICBzdGF0dXMsXG4gICAgICAgIGlzTG9hZGluZyxcbiAgICAgICAgaXNTdWNjZXNzLFxuICAgICAgICBpc0Vycm9yLFxuICAgICAgICBlcnJvclxuICAgICAgfSk7XG4gICAgICBjb25zdCBmaW5hbFN0YXRlID0gdXNlTWVtbzIoKCkgPT4gKHtcbiAgICAgICAgLi4uY3VycmVudFN0YXRlLFxuICAgICAgICBvcmlnaW5hbEFyZ3MsXG4gICAgICAgIHJlc2V0XG4gICAgICB9KSwgW2N1cnJlbnRTdGF0ZSwgb3JpZ2luYWxBcmdzLCByZXNldF0pO1xuICAgICAgcmV0dXJuIHVzZU1lbW8yKCgpID0+IFt0cmlnZ2VyTXV0YXRpb24sIGZpbmFsU3RhdGVdLCBbdHJpZ2dlck11dGF0aW9uLCBmaW5hbFN0YXRlXSk7XG4gICAgfTtcbiAgfVxufVxuXG4vLyBzcmMvcXVlcnkvZW5kcG9pbnREZWZpbml0aW9ucy50c1xuZnVuY3Rpb24gaXNRdWVyeURlZmluaXRpb24oZSkge1xuICByZXR1cm4gZS50eXBlID09PSBcInF1ZXJ5XCIgLyogcXVlcnkgKi87XG59XG5mdW5jdGlvbiBpc011dGF0aW9uRGVmaW5pdGlvbihlKSB7XG4gIHJldHVybiBlLnR5cGUgPT09IFwibXV0YXRpb25cIiAvKiBtdXRhdGlvbiAqLztcbn1cblxuLy8gc3JjL3F1ZXJ5L3V0aWxzL2NhcGl0YWxpemUudHNcbmZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShzdHJbMF0sIHN0clswXS50b1VwcGVyQ2FzZSgpKTtcbn1cblxuLy8gc3JjL3F1ZXJ5L3RzSGVscGVycy50c1xuZnVuY3Rpb24gc2FmZUFzc2lnbih0YXJnZXQsIC4uLmFyZ3MpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24odGFyZ2V0LCAuLi5hcmdzKTtcbn1cblxuLy8gc3JjL3F1ZXJ5L3JlYWN0L21vZHVsZS50c1xuaW1wb3J0IHsgdXNlRGlzcGF0Y2ggYXMgcnJVc2VEaXNwYXRjaCwgdXNlU2VsZWN0b3IgYXMgcnJVc2VTZWxlY3RvciwgdXNlU3RvcmUgYXMgcnJVc2VTdG9yZSwgYmF0Y2ggYXMgcnJCYXRjaCB9IGZyb20gXCJyZWFjdC1yZWR1eFwiO1xuXG4vLyBzcmMvcXVlcnkvdXRpbHMvY291bnRPYmplY3RLZXlzLnRzXG5mdW5jdGlvbiBjb3VudE9iamVjdEtleXMob2JqKSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGZvciAoY29uc3QgX2tleSBpbiBvYmopIHtcbiAgICBjb3VudCsrO1xuICB9XG4gIHJldHVybiBjb3VudDtcbn1cblxuLy8gc3JjL3F1ZXJ5L3JlYWN0L21vZHVsZS50c1xuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3IgYXMgX2NyZWF0ZVNlbGVjdG9yIH0gZnJvbSBcInJlc2VsZWN0XCI7XG52YXIgcmVhY3RIb29rc01vZHVsZU5hbWUgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sKCk7XG52YXIgcmVhY3RIb29rc01vZHVsZSA9ICh7XG4gIGJhdGNoID0gcnJCYXRjaCxcbiAgaG9va3MgPSB7XG4gICAgdXNlRGlzcGF0Y2g6IHJyVXNlRGlzcGF0Y2gsXG4gICAgdXNlU2VsZWN0b3I6IHJyVXNlU2VsZWN0b3IsXG4gICAgdXNlU3RvcmU6IHJyVXNlU3RvcmVcbiAgfSxcbiAgY3JlYXRlU2VsZWN0b3I6IGNyZWF0ZVNlbGVjdG9yMiA9IF9jcmVhdGVTZWxlY3RvcixcbiAgdW5zdGFibGVfX3NpZGVFZmZlY3RzSW5SZW5kZXIgPSBmYWxzZSxcbiAgLi4ucmVzdFxufSA9IHt9KSA9PiB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zdCBob29rTmFtZXMgPSBbXCJ1c2VEaXNwYXRjaFwiLCBcInVzZVNlbGVjdG9yXCIsIFwidXNlU3RvcmVcIl07XG4gICAgbGV0IHdhcm5lZCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgaG9va05hbWUgb2YgaG9va05hbWVzKSB7XG4gICAgICBpZiAoY291bnRPYmplY3RLZXlzKHJlc3QpID4gMCkge1xuICAgICAgICBpZiAocmVzdFtob29rTmFtZV0pIHtcbiAgICAgICAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQXMgb2YgUlRLIDIuMCwgdGhlIGhvb2tzIG5vdyBuZWVkIHRvIGJlIHNwZWNpZmllZCBhcyBvbmUgb2JqZWN0LCBwcm92aWRlZCB1bmRlciBhIGBob29rc2Aga2V5OlxcbmByZWFjdEhvb2tzTW9kdWxlKHsgaG9va3M6IHsgdXNlRGlzcGF0Y2gsIHVzZVNlbGVjdG9yLCB1c2VTdG9yZSB9IH0pYFwiKTtcbiAgICAgICAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGhvb2tzW2hvb2tOYW1lXSA9IHJlc3RbaG9va05hbWVdO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBob29rc1tob29rTmFtZV0gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UzKDM2KSA6IGBXaGVuIHVzaW5nIGN1c3RvbSBob29rcyBmb3IgY29udGV4dCwgYWxsICR7aG9va05hbWVzLmxlbmd0aH0gaG9va3MgbmVlZCB0byBiZSBwcm92aWRlZDogJHtob29rTmFtZXMuam9pbihcIiwgXCIpfS5cbkhvb2sgJHtob29rTmFtZX0gd2FzIGVpdGhlciBub3QgcHJvdmlkZWQgb3Igbm90IGEgZnVuY3Rpb24uYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogcmVhY3RIb29rc01vZHVsZU5hbWUsXG4gICAgaW5pdChhcGksIHtcbiAgICAgIHNlcmlhbGl6ZVF1ZXJ5QXJnc1xuICAgIH0sIGNvbnRleHQpIHtcbiAgICAgIGNvbnN0IGFueUFwaSA9IGFwaTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYnVpbGRRdWVyeUhvb2tzLFxuICAgICAgICBidWlsZE11dGF0aW9uSG9vayxcbiAgICAgICAgdXNlUHJlZmV0Y2hcbiAgICAgIH0gPSBidWlsZEhvb2tzKHtcbiAgICAgICAgYXBpLFxuICAgICAgICBtb2R1bGVPcHRpb25zOiB7XG4gICAgICAgICAgYmF0Y2gsXG4gICAgICAgICAgaG9va3MsXG4gICAgICAgICAgdW5zdGFibGVfX3NpZGVFZmZlY3RzSW5SZW5kZXIsXG4gICAgICAgICAgY3JlYXRlU2VsZWN0b3I6IGNyZWF0ZVNlbGVjdG9yMlxuICAgICAgICB9LFxuICAgICAgICBzZXJpYWxpemVRdWVyeUFyZ3MsXG4gICAgICAgIGNvbnRleHRcbiAgICAgIH0pO1xuICAgICAgc2FmZUFzc2lnbihhbnlBcGksIHtcbiAgICAgICAgdXNlUHJlZmV0Y2hcbiAgICAgIH0pO1xuICAgICAgc2FmZUFzc2lnbihjb250ZXh0LCB7XG4gICAgICAgIGJhdGNoXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluamVjdEVuZHBvaW50KGVuZHBvaW50TmFtZSwgZGVmaW5pdGlvbikge1xuICAgICAgICAgIGlmIChpc1F1ZXJ5RGVmaW5pdGlvbihkZWZpbml0aW9uKSkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICB1c2VRdWVyeSxcbiAgICAgICAgICAgICAgdXNlTGF6eVF1ZXJ5LFxuICAgICAgICAgICAgICB1c2VMYXp5UXVlcnlTdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgIHVzZVF1ZXJ5U3RhdGUsXG4gICAgICAgICAgICAgIHVzZVF1ZXJ5U3Vic2NyaXB0aW9uXG4gICAgICAgICAgICB9ID0gYnVpbGRRdWVyeUhvb2tzKGVuZHBvaW50TmFtZSk7XG4gICAgICAgICAgICBzYWZlQXNzaWduKGFueUFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXSwge1xuICAgICAgICAgICAgICB1c2VRdWVyeSxcbiAgICAgICAgICAgICAgdXNlTGF6eVF1ZXJ5LFxuICAgICAgICAgICAgICB1c2VMYXp5UXVlcnlTdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgIHVzZVF1ZXJ5U3RhdGUsXG4gICAgICAgICAgICAgIHVzZVF1ZXJ5U3Vic2NyaXB0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFwaVtgdXNlJHtjYXBpdGFsaXplKGVuZHBvaW50TmFtZSl9UXVlcnlgXSA9IHVzZVF1ZXJ5O1xuICAgICAgICAgICAgYXBpW2B1c2VMYXp5JHtjYXBpdGFsaXplKGVuZHBvaW50TmFtZSl9UXVlcnlgXSA9IHVzZUxhenlRdWVyeTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTXV0YXRpb25EZWZpbml0aW9uKGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgICBjb25zdCB1c2VNdXRhdGlvbiA9IGJ1aWxkTXV0YXRpb25Ib29rKGVuZHBvaW50TmFtZSk7XG4gICAgICAgICAgICBzYWZlQXNzaWduKGFueUFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXSwge1xuICAgICAgICAgICAgICB1c2VNdXRhdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhcGlbYHVzZSR7Y2FwaXRhbGl6ZShlbmRwb2ludE5hbWUpfU11dGF0aW9uYF0gPSB1c2VNdXRhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufTtcblxuLy8gc3JjL3F1ZXJ5L3JlYWN0L2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdC9xdWVyeVwiO1xuXG4vLyBzcmMvcXVlcnkvcmVhY3QvQXBpUHJvdmlkZXIudHN4XG5pbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNCB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5pbXBvcnQgeyBjb25maWd1cmVTdG9yZSB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0NCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgUHJvdmlkZXIsIFJlYWN0UmVkdXhDb250ZXh0IH0gZnJvbSBcInJlYWN0LXJlZHV4XCI7XG5pbXBvcnQgeyBzZXR1cExpc3RlbmVycyB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0L3F1ZXJ5XCI7XG5mdW5jdGlvbiBBcGlQcm92aWRlcihwcm9wcykge1xuICBjb25zdCBjb250ZXh0ID0gcHJvcHMuY29udGV4dCB8fCBSZWFjdFJlZHV4Q29udGV4dDtcbiAgY29uc3QgZXhpc3RpbmdDb250ZXh0ID0gdXNlQ29udGV4dChjb250ZXh0KTtcbiAgaWYgKGV4aXN0aW5nQ29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTQoMzUpIDogXCJFeGlzdGluZyBSZWR1eCBjb250ZXh0IGRldGVjdGVkLiBJZiB5b3UgYWxyZWFkeSBoYXZlIGEgc3RvcmUgc2V0IHVwLCBwbGVhc2UgdXNlIHRoZSB0cmFkaXRpb25hbCBSZWR1eCBzZXR1cC5cIik7XG4gIH1cbiAgY29uc3QgW3N0b3JlXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IGNvbmZpZ3VyZVN0b3JlKHtcbiAgICByZWR1Y2VyOiB7XG4gICAgICBbcHJvcHMuYXBpLnJlZHVjZXJQYXRoXTogcHJvcHMuYXBpLnJlZHVjZXJcbiAgICB9LFxuICAgIG1pZGRsZXdhcmU6IChnRE0pID0+IGdETSgpLmNvbmNhdChwcm9wcy5hcGkubWlkZGxld2FyZSlcbiAgfSkpO1xuICB1c2VFZmZlY3Q0KCgpID0+IHByb3BzLnNldHVwTGlzdGVuZXJzID09PSBmYWxzZSA/IHZvaWQgMCA6IHNldHVwTGlzdGVuZXJzKHN0b3JlLmRpc3BhdGNoLCBwcm9wcy5zZXR1cExpc3RlbmVycyksIFtwcm9wcy5zZXR1cExpc3RlbmVycywgc3RvcmUuZGlzcGF0Y2hdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFByb3ZpZGVyLCB7IHN0b3JlLCBjb250ZXh0IH0sIHByb3BzLmNoaWxkcmVuKTtcbn1cblxuLy8gc3JjL3F1ZXJ5L3JlYWN0L2luZGV4LnRzXG52YXIgY3JlYXRlQXBpID0gLyogQF9fUFVSRV9fICovIGJ1aWxkQ3JlYXRlQXBpKGNvcmVNb2R1bGUoKSwgcmVhY3RIb29rc01vZHVsZSgpKTtcbmV4cG9ydCB7XG4gIEFwaVByb3ZpZGVyLFxuICBjcmVhdGVBcGksXG4gIHJlYWN0SG9va3NNb2R1bGUsXG4gIHJlYWN0SG9va3NNb2R1bGVOYW1lXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnRrLXF1ZXJ5LXJlYWN0Lm1vZGVybi5tanMubWFwIl0sIm5hbWVzIjpbImNvcmVNb2R1bGUiLCJidWlsZENyZWF0ZUFwaSIsImZvcm1hdFByb2RFcnJvck1lc3NhZ2UiLCJfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTMiLCJfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTIiLCJfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSIsInVzZUNhbGxiYWNrIiwidXNlRGVidWdWYWx1ZSIsInVzZUVmZmVjdCIsInVzZUVmZmVjdDMiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VNZW1vIiwidXNlTWVtbzIiLCJ1c2VSZWYiLCJ1c2VSZWYzIiwidXNlU3RhdGUiLCJRdWVyeVN0YXR1cyIsInNraXBUb2tlbiIsInNoYWxsb3dFcXVhbCIsInNoYWxsb3dFcXVhbDIiLCJ1c2VTdGFibGVRdWVyeUFyZ3MiLCJxdWVyeUFyZ3MiLCJzZXJpYWxpemUiLCJlbmRwb2ludERlZmluaXRpb24iLCJlbmRwb2ludE5hbWUiLCJpbmNvbWluZyIsInNlcmlhbGl6ZWQiLCJjYWNoZTIiLCJjdXJyZW50IiwiVU5JTklUSUFMSVpFRF9WQUxVRSIsIlN5bWJvbCIsInVzZUVmZmVjdDIiLCJ1c2VSZWYyIiwidXNlU2hhbGxvd1N0YWJsZVZhbHVlIiwidmFsdWUiLCJjcmVhdGVBY3Rpb24iLCJjcmVhdGVTbGljZSIsImNyZWF0ZVNlbGVjdG9yIiwiY3JlYXRlQXN5bmNUaHVuayIsImNvbWJpbmVSZWR1Y2VycyIsImNyZWF0ZU5leHRTdGF0ZSIsImlzQW55T2YiLCJpc0FsbE9mIiwiaXNBY3Rpb24iLCJpc1BlbmRpbmciLCJpc1JlamVjdGVkIiwiaXNGdWxmaWxsZWQiLCJpc1JlamVjdGVkV2l0aFZhbHVlIiwiaXNBc3luY1RodW5rQWN0aW9uIiwicHJlcGFyZUF1dG9CYXRjaGVkIiwiU0hPVUxEX0FVVE9CQVRDSCIsImlzUGxhaW5PYmplY3QiLCJuYW5vaWQiLCJjYWNoZSIsIldlYWtNYXAiLCJkZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzIiwiY2FjaGVkIiwiZ2V0Iiwic3RyaW5naWZpZWQiLCJKU09OIiwic3RyaW5naWZ5Iiwia2V5IiwiT2JqZWN0Iiwia2V5cyIsInNvcnQiLCJyZWR1Y2UiLCJhY2MiLCJrZXkyIiwic2V0IiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsIndpbmRvdyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIm5vUGVuZGluZ1F1ZXJ5U3RhdGVTZWxlY3RvciIsInNlbGVjdGVkIiwiaXNVbmluaXRpYWxpemVkIiwiaXNGZXRjaGluZyIsImlzTG9hZGluZyIsImRhdGEiLCJzdGF0dXMiLCJwZW5kaW5nIiwiYnVpbGRIb29rcyIsImFwaSIsIm1vZHVsZU9wdGlvbnMiLCJiYXRjaCIsImhvb2tzIiwidXNlRGlzcGF0Y2giLCJ1c2VTZWxlY3RvciIsInVzZVN0b3JlIiwidW5zdGFibGVfX3NpZGVFZmZlY3RzSW5SZW5kZXIiLCJjcmVhdGVTZWxlY3RvcjIiLCJzZXJpYWxpemVRdWVyeUFyZ3MiLCJjb250ZXh0IiwidXNlUG9zc2libHlJbW1lZGlhdGVFZmZlY3QiLCJjYiIsImJ1aWxkUXVlcnlIb29rcyIsImJ1aWxkTXV0YXRpb25Ib29rIiwidXNlUHJlZmV0Y2giLCJxdWVyeVN0YXRlUHJlU2VsZWN0b3IiLCJjdXJyZW50U3RhdGUiLCJsYXN0UmVzdWx0IiwiZW5kcG9pbnREZWZpbml0aW9ucyIsIm9yaWdpbmFsQXJncyIsImlzU3VjY2VzcyIsImhhc0RhdGEiLCJjdXJyZW50RGF0YSIsImRlZmF1bHRPcHRpb25zIiwiZGlzcGF0Y2giLCJzdGFibGVEZWZhdWx0T3B0aW9ucyIsImFyZyIsIm9wdGlvbnMiLCJ1dGlsIiwicHJlZmV0Y2giLCJuYW1lIiwidXNlUXVlcnlTdWJzY3JpcHRpb24iLCJyZWZldGNoT25SZWNvbm5lY3QiLCJyZWZldGNoT25Gb2N1cyIsInJlZmV0Y2hPbk1vdW50T3JBcmdDaGFuZ2UiLCJza2lwIiwicG9sbGluZ0ludGVydmFsIiwic2tpcFBvbGxpbmdJZlVuZm9jdXNlZCIsImluaXRpYXRlIiwiZW5kcG9pbnRzIiwic3Vic2NyaXB0aW9uU2VsZWN0b3JzUmVmIiwicmV0dXJuZWRWYWx1ZSIsImludGVybmFsQWN0aW9ucyIsImludGVybmFsX2dldFJUS1FTdWJzY3JpcHRpb25zIiwicHJvY2VzcyIsInR5cGUiLCJFcnJvciIsInJlZHVjZXJQYXRoIiwic3RhYmxlQXJnIiwic3RhYmxlU3Vic2NyaXB0aW9uT3B0aW9ucyIsImxhc3RSZW5kZXJIYWRTdWJzY3JpcHRpb24iLCJwcm9taXNlUmVmIiwicXVlcnlDYWNoZUtleSIsInJlcXVlc3RJZCIsImN1cnJlbnRSZW5kZXJIYXNTdWJzY3JpcHRpb24iLCJpc1JlcXVlc3RTdWJzY3JpYmVkIiwic3Vic2NyaXB0aW9uUmVtb3ZlZCIsImxhc3RQcm9taXNlIiwiY29uc29sZSIsImxvZyIsInVuc3Vic2NyaWJlIiwibGFzdFN1YnNjcmlwdGlvbk9wdGlvbnMiLCJzdWJzY3JpcHRpb25PcHRpb25zIiwicHJvbWlzZSIsImZvcmNlUmVmZXRjaCIsInVwZGF0ZVN1YnNjcmlwdGlvbk9wdGlvbnMiLCJyZWZldGNoIiwidXNlTGF6eVF1ZXJ5U3Vic2NyaXB0aW9uIiwic2V0QXJnIiwic3Vic2NyaXB0aW9uT3B0aW9uc1JlZiIsInRyaWdnZXIiLCJhcmcyIiwicHJlZmVyQ2FjaGVWYWx1ZSIsInVzZVF1ZXJ5U3RhdGUiLCJzZWxlY3RGcm9tUmVzdWx0Iiwic2VsZWN0IiwibGFzdFZhbHVlIiwic2VsZWN0RGVmYXVsdFJlc3VsdCIsIl8iLCJtZW1vaXplT3B0aW9ucyIsInJlc3VsdEVxdWFsaXR5Q2hlY2siLCJxdWVyeVNlbGVjdG9yIiwiZGV2TW9kZUNoZWNrcyIsImlkZW50aXR5RnVuY3Rpb25DaGVjayIsInN0YXRlIiwic3RvcmUiLCJuZXdMYXN0VmFsdWUiLCJnZXRTdGF0ZSIsInVzZUxhenlRdWVyeSIsInF1ZXJ5U3RhdGVSZXN1bHRzIiwiaW5mbyIsImxhc3RBcmciLCJ1c2VRdWVyeSIsInF1ZXJ5U3Vic2NyaXB0aW9uUmVzdWx0cyIsImlzRXJyb3IiLCJlcnJvciIsImZpeGVkQ2FjaGVLZXkiLCJzZXRQcm9taXNlIiwicmVzZXQiLCJ0cmlnZ2VyTXV0YXRpb24iLCJwcm9taXNlMiIsIm11dGF0aW9uU2VsZWN0b3IiLCJyZW1vdmVNdXRhdGlvblJlc3VsdCIsImZpbmFsU3RhdGUiLCJpc1F1ZXJ5RGVmaW5pdGlvbiIsImUiLCJpc011dGF0aW9uRGVmaW5pdGlvbiIsImNhcGl0YWxpemUiLCJzdHIiLCJyZXBsYWNlIiwidG9VcHBlckNhc2UiLCJzYWZlQXNzaWduIiwidGFyZ2V0IiwiYXJncyIsImFzc2lnbiIsInJyVXNlRGlzcGF0Y2giLCJyclVzZVNlbGVjdG9yIiwicnJVc2VTdG9yZSIsInJyQmF0Y2giLCJjb3VudE9iamVjdEtleXMiLCJvYmoiLCJjb3VudCIsIl9rZXkiLCJfY3JlYXRlU2VsZWN0b3IiLCJyZWFjdEhvb2tzTW9kdWxlTmFtZSIsInJlYWN0SG9va3NNb2R1bGUiLCJyZXN0IiwiaG9va05hbWVzIiwid2FybmVkIiwiaG9va05hbWUiLCJ3YXJuIiwibGVuZ3RoIiwiam9pbiIsImluaXQiLCJhbnlBcGkiLCJpbmplY3RFbmRwb2ludCIsImRlZmluaXRpb24iLCJ1c2VNdXRhdGlvbiIsIl9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNCIsImNvbmZpZ3VyZVN0b3JlIiwidXNlQ29udGV4dCIsInVzZUVmZmVjdDQiLCJSZWFjdCIsIlByb3ZpZGVyIiwiUmVhY3RSZWR1eENvbnRleHQiLCJzZXR1cExpc3RlbmVycyIsIkFwaVByb3ZpZGVyIiwicHJvcHMiLCJleGlzdGluZ0NvbnRleHQiLCJyZWR1Y2VyIiwibWlkZGxld2FyZSIsImdETSIsImNvbmNhdCIsImNoaWxkcmVuIiwiY3JlYXRlQXBpIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/dist/query/react/rtk-query-react.modern.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/dist/query/rtk-query.modern.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/query/rtk-query.modern.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryStatus: () => (/* binding */ QueryStatus),\n/* harmony export */   buildCreateApi: () => (/* binding */ buildCreateApi),\n/* harmony export */   copyWithStructuralSharing: () => (/* binding */ copyWithStructuralSharing),\n/* harmony export */   coreModule: () => (/* binding */ coreModule),\n/* harmony export */   coreModuleName: () => (/* binding */ coreModuleName),\n/* harmony export */   createApi: () => (/* binding */ createApi),\n/* harmony export */   defaultSerializeQueryArgs: () => (/* binding */ defaultSerializeQueryArgs),\n/* harmony export */   fakeBaseQuery: () => (/* binding */ fakeBaseQuery),\n/* harmony export */   fetchBaseQuery: () => (/* binding */ fetchBaseQuery),\n/* harmony export */   retry: () => (/* binding */ retry),\n/* harmony export */   setupListeners: () => (/* binding */ setupListeners),\n/* harmony export */   skipToken: () => (/* binding */ skipToken)\n/* harmony export */ });\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(ssr)/./node_modules/redux/dist/redux.mjs\");\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @reduxjs/toolkit */ \"(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\");\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/immer.mjs\");\n/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! reselect */ \"(ssr)/./node_modules/reselect/dist/reselect.mjs\");\n// src/query/core/apiState.ts\nvar QueryStatus = /* @__PURE__ */ ((QueryStatus2)=>{\n    QueryStatus2[\"uninitialized\"] = \"uninitialized\";\n    QueryStatus2[\"pending\"] = \"pending\";\n    QueryStatus2[\"fulfilled\"] = \"fulfilled\";\n    QueryStatus2[\"rejected\"] = \"rejected\";\n    return QueryStatus2;\n})(QueryStatus || {});\nfunction getRequestStatusFlags(status) {\n    return {\n        status,\n        isUninitialized: status === \"uninitialized\" /* uninitialized */ ,\n        isLoading: status === \"pending\" /* pending */ ,\n        isSuccess: status === \"fulfilled\" /* fulfilled */ ,\n        isError: status === \"rejected\" /* rejected */ \n    };\n}\n// src/query/utils/isAbsoluteUrl.ts\nfunction isAbsoluteUrl(url) {\n    return new RegExp(`(^|:)//`).test(url);\n}\n// src/query/utils/joinUrls.ts\nvar withoutTrailingSlash = (url)=>url.replace(/\\/$/, \"\");\nvar withoutLeadingSlash = (url)=>url.replace(/^\\//, \"\");\nfunction joinUrls(base, url) {\n    if (!base) {\n        return url;\n    }\n    if (!url) {\n        return base;\n    }\n    if (isAbsoluteUrl(url)) {\n        return url;\n    }\n    const delimiter = base.endsWith(\"/\") || !url.startsWith(\"?\") ? \"/\" : \"\";\n    base = withoutTrailingSlash(base);\n    url = withoutLeadingSlash(url);\n    return `${base}${delimiter}${url}`;\n}\n// src/query/utils/flatten.ts\nvar flatten = (arr)=>[].concat(...arr);\n// src/query/utils/isOnline.ts\nfunction isOnline() {\n    return typeof navigator === \"undefined\" ? true : navigator.onLine === void 0 ? true : navigator.onLine;\n}\n// src/query/utils/isDocumentVisible.ts\nfunction isDocumentVisible() {\n    if (typeof document === \"undefined\") {\n        return true;\n    }\n    return document.visibilityState !== \"hidden\";\n}\n// src/query/core/rtkImports.ts\n\n// src/query/utils/copyWithStructuralSharing.ts\nvar isPlainObject2 = _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPlainObject;\nfunction copyWithStructuralSharing(oldObj, newObj) {\n    if (oldObj === newObj || !(isPlainObject2(oldObj) && isPlainObject2(newObj) || Array.isArray(oldObj) && Array.isArray(newObj))) {\n        return newObj;\n    }\n    const newKeys = Object.keys(newObj);\n    const oldKeys = Object.keys(oldObj);\n    let isSameObject = newKeys.length === oldKeys.length;\n    const mergeObj = Array.isArray(newObj) ? [] : {};\n    for (const key of newKeys){\n        mergeObj[key] = copyWithStructuralSharing(oldObj[key], newObj[key]);\n        if (isSameObject) isSameObject = oldObj[key] === mergeObj[key];\n    }\n    return isSameObject ? oldObj : mergeObj;\n}\n// src/query/fetchBaseQuery.ts\nvar defaultFetchFn = (...args)=>fetch(...args);\nvar defaultValidateStatus = (response)=>response.status >= 200 && response.status <= 299;\nvar defaultIsJsonContentType = (headers)=>/*applicat*/ /ion\\/(vnd\\.api\\+)?json/.test(headers.get(\"content-type\") || \"\");\nfunction stripUndefined(obj) {\n    if (!(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(obj)) {\n        return obj;\n    }\n    const copy = {\n        ...obj\n    };\n    for (const [k, v] of Object.entries(copy)){\n        if (v === void 0) delete copy[k];\n    }\n    return copy;\n}\nfunction fetchBaseQuery({ baseUrl, prepareHeaders = (x)=>x, fetchFn = defaultFetchFn, paramsSerializer, isJsonContentType = defaultIsJsonContentType, jsonContentType = \"application/json\", jsonReplacer, timeout: defaultTimeout, responseHandler: globalResponseHandler, validateStatus: globalValidateStatus, ...baseFetchOptions } = {}) {\n    if (typeof fetch === \"undefined\" && fetchFn === defaultFetchFn) {\n        console.warn(\"Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments.\");\n    }\n    return async (arg, api)=>{\n        const { signal, getState, extra, endpoint, forced, type } = api;\n        let meta;\n        let { url, headers = new Headers(baseFetchOptions.headers), params = void 0, responseHandler = globalResponseHandler ?? \"json\", validateStatus = globalValidateStatus ?? defaultValidateStatus, timeout = defaultTimeout, ...rest } = typeof arg == \"string\" ? {\n            url: arg\n        } : arg;\n        let config = {\n            ...baseFetchOptions,\n            signal,\n            ...rest\n        };\n        headers = new Headers(stripUndefined(headers));\n        config.headers = await prepareHeaders(headers, {\n            getState,\n            extra,\n            endpoint,\n            forced,\n            type\n        }) || headers;\n        const isJsonifiable = (body)=>typeof body === \"object\" && ((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(body) || Array.isArray(body) || typeof body.toJSON === \"function\");\n        if (!config.headers.has(\"content-type\") && isJsonifiable(config.body)) {\n            config.headers.set(\"content-type\", jsonContentType);\n        }\n        if (isJsonifiable(config.body) && isJsonContentType(config.headers)) {\n            config.body = JSON.stringify(config.body, jsonReplacer);\n        }\n        if (params) {\n            const divider = ~url.indexOf(\"?\") ? \"&\" : \"?\";\n            const query = paramsSerializer ? paramsSerializer(params) : new URLSearchParams(stripUndefined(params));\n            url += divider + query;\n        }\n        url = joinUrls(baseUrl, url);\n        const request = new Request(url, config);\n        const requestClone = new Request(url, config);\n        meta = {\n            request: requestClone\n        };\n        let response, timedOut = false, timeoutId = timeout && setTimeout(()=>{\n            timedOut = true;\n            api.abort();\n        }, timeout);\n        try {\n            response = await fetchFn(request);\n        } catch (e) {\n            return {\n                error: {\n                    status: timedOut ? \"TIMEOUT_ERROR\" : \"FETCH_ERROR\",\n                    error: String(e)\n                },\n                meta\n            };\n        } finally{\n            if (timeoutId) clearTimeout(timeoutId);\n        }\n        const responseClone = response.clone();\n        meta.response = responseClone;\n        let resultData;\n        let responseText = \"\";\n        try {\n            let handleResponseError;\n            await Promise.all([\n                handleResponse(response, responseHandler).then((r)=>resultData = r, (e)=>handleResponseError = e),\n                // see https://github.com/node-fetch/node-fetch/issues/665#issuecomment-538995182\n                // we *have* to \"use up\" both streams at the same time or they will stop running in node-fetch scenarios\n                responseClone.text().then((r)=>responseText = r, ()=>{})\n            ]);\n            if (handleResponseError) throw handleResponseError;\n        } catch (e) {\n            return {\n                error: {\n                    status: \"PARSING_ERROR\",\n                    originalStatus: response.status,\n                    data: responseText,\n                    error: String(e)\n                },\n                meta\n            };\n        }\n        return validateStatus(response, resultData) ? {\n            data: resultData,\n            meta\n        } : {\n            error: {\n                status: response.status,\n                data: resultData\n            },\n            meta\n        };\n    };\n    async function handleResponse(response, responseHandler) {\n        if (typeof responseHandler === \"function\") {\n            return responseHandler(response);\n        }\n        if (responseHandler === \"content-type\") {\n            responseHandler = isJsonContentType(response.headers) ? \"json\" : \"text\";\n        }\n        if (responseHandler === \"json\") {\n            const text = await response.text();\n            return text.length ? JSON.parse(text) : null;\n        }\n        return response.text();\n    }\n}\n// src/query/HandledError.ts\nvar HandledError = class {\n    constructor(value, meta = void 0){\n        this.value = value;\n        this.meta = meta;\n    }\n};\n// src/query/retry.ts\nasync function defaultBackoff(attempt = 0, maxRetries = 5) {\n    const attempts = Math.min(attempt, maxRetries);\n    const timeout = ~~((Math.random() + 0.4) * (300 << attempts));\n    await new Promise((resolve)=>setTimeout((res)=>resolve(res), timeout));\n}\nfunction fail(e) {\n    throw Object.assign(new HandledError({\n        error: e\n    }), {\n        throwImmediately: true\n    });\n}\nvar EMPTY_OPTIONS = {};\nvar retryWithBackoff = (baseQuery, defaultOptions)=>async (args, api, extraOptions)=>{\n        const possibleMaxRetries = [\n            5,\n            (defaultOptions || EMPTY_OPTIONS).maxRetries,\n            (extraOptions || EMPTY_OPTIONS).maxRetries\n        ].filter((x)=>x !== void 0);\n        const [maxRetries] = possibleMaxRetries.slice(-1);\n        const defaultRetryCondition = (_, __, { attempt })=>attempt <= maxRetries;\n        const options = {\n            maxRetries,\n            backoff: defaultBackoff,\n            retryCondition: defaultRetryCondition,\n            ...defaultOptions,\n            ...extraOptions\n        };\n        let retry2 = 0;\n        while(true){\n            try {\n                const result = await baseQuery(args, api, extraOptions);\n                if (result.error) {\n                    throw new HandledError(result);\n                }\n                return result;\n            } catch (e) {\n                retry2++;\n                if (e.throwImmediately) {\n                    if (e instanceof HandledError) {\n                        return e.value;\n                    }\n                    throw e;\n                }\n                if (e instanceof HandledError && !options.retryCondition(e.value.error, args, {\n                    attempt: retry2,\n                    baseQueryApi: api,\n                    extraOptions\n                })) {\n                    return e.value;\n                }\n                await options.backoff(retry2, options.maxRetries);\n            }\n        }\n    };\nvar retry = /* @__PURE__ */ Object.assign(retryWithBackoff, {\n    fail\n});\n// src/query/core/setupListeners.ts\nvar onFocus = /* @__PURE__ */ (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAction)(\"__rtkq/focused\");\nvar onFocusLost = /* @__PURE__ */ (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAction)(\"__rtkq/unfocused\");\nvar onOnline = /* @__PURE__ */ (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAction)(\"__rtkq/online\");\nvar onOffline = /* @__PURE__ */ (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAction)(\"__rtkq/offline\");\nvar initialized = false;\nfunction setupListeners(dispatch, customHandler) {\n    function defaultHandler() {\n        const handleFocus = ()=>dispatch(onFocus());\n        const handleFocusLost = ()=>dispatch(onFocusLost());\n        const handleOnline = ()=>dispatch(onOnline());\n        const handleOffline = ()=>dispatch(onOffline());\n        const handleVisibilityChange = ()=>{\n            if (window.document.visibilityState === \"visible\") {\n                handleFocus();\n            } else {\n                handleFocusLost();\n            }\n        };\n        if (!initialized) {\n            if (false) {}\n        }\n        const unsubscribe = ()=>{\n            window.removeEventListener(\"focus\", handleFocus);\n            window.removeEventListener(\"visibilitychange\", handleVisibilityChange);\n            window.removeEventListener(\"online\", handleOnline);\n            window.removeEventListener(\"offline\", handleOffline);\n            initialized = false;\n        };\n        return unsubscribe;\n    }\n    return customHandler ? customHandler(dispatch, {\n        onFocus,\n        onFocusLost,\n        onOffline,\n        onOnline\n    }) : defaultHandler();\n}\n// src/query/endpointDefinitions.ts\nfunction isQueryDefinition(e) {\n    return e.type === \"query\" /* query */ ;\n}\nfunction isMutationDefinition(e) {\n    return e.type === \"mutation\" /* mutation */ ;\n}\nfunction calculateProvidedBy(description, result, error, queryArg, meta, assertTagTypes) {\n    if (isFunction(description)) {\n        return description(result, error, queryArg, meta).map(expandTagDescription).map(assertTagTypes);\n    }\n    if (Array.isArray(description)) {\n        return description.map(expandTagDescription).map(assertTagTypes);\n    }\n    return [];\n}\nfunction isFunction(t) {\n    return typeof t === \"function\";\n}\nfunction expandTagDescription(description) {\n    return typeof description === \"string\" ? {\n        type: description\n    } : description;\n}\n// src/query/core/buildInitiate.ts\n\n// src/query/utils/isNotNullish.ts\nfunction isNotNullish(v) {\n    return v != null;\n}\n// src/query/utils/countObjectKeys.ts\nfunction countObjectKeys(obj) {\n    let count = 0;\n    for(const _key in obj){\n        count++;\n    }\n    return count;\n}\n// src/tsHelpers.ts\nfunction asSafePromise(promise, fallback) {\n    return promise.catch(fallback);\n}\n// src/query/core/buildInitiate.ts\nvar forceQueryFnSymbol = Symbol(\"forceQueryFn\");\nvar isUpsertQuery = (arg)=>typeof arg[forceQueryFnSymbol] === \"function\";\nfunction buildInitiate({ serializeQueryArgs, queryThunk, mutationThunk, api, context }) {\n    const runningQueries = /* @__PURE__ */ new Map();\n    const runningMutations = /* @__PURE__ */ new Map();\n    const { unsubscribeQueryResult, removeMutationResult, updateSubscriptionOptions } = api.internalActions;\n    return {\n        buildInitiateQuery,\n        buildInitiateMutation,\n        getRunningQueryThunk,\n        getRunningMutationThunk,\n        getRunningQueriesThunk,\n        getRunningMutationsThunk\n    };\n    function getRunningQueryThunk(endpointName, queryArgs) {\n        return (dispatch)=>{\n            const endpointDefinition = context.endpointDefinitions[endpointName];\n            const queryCacheKey = serializeQueryArgs({\n                queryArgs,\n                endpointDefinition,\n                endpointName\n            });\n            return runningQueries.get(dispatch)?.[queryCacheKey];\n        };\n    }\n    function getRunningMutationThunk(_endpointName, fixedCacheKeyOrRequestId) {\n        return (dispatch)=>{\n            return runningMutations.get(dispatch)?.[fixedCacheKeyOrRequestId];\n        };\n    }\n    function getRunningQueriesThunk() {\n        return (dispatch)=>Object.values(runningQueries.get(dispatch) || {}).filter(isNotNullish);\n    }\n    function getRunningMutationsThunk() {\n        return (dispatch)=>Object.values(runningMutations.get(dispatch) || {}).filter(isNotNullish);\n    }\n    function middlewareWarning(dispatch) {\n        if (true) {\n            if (middlewareWarning.triggered) return;\n            const returnedValue = dispatch(api.internalActions.internal_getRTKQSubscriptions());\n            middlewareWarning.triggered = true;\n            if (typeof returnedValue !== \"object\" || typeof returnedValue?.type === \"string\") {\n                throw new Error( false ? 0 : `Warning: Middleware for RTK-Query API at reducerPath \"${api.reducerPath}\" has not been added to the store.\nYou must add the middleware for RTK-Query to function correctly!`);\n            }\n        }\n    }\n    function buildInitiateQuery(endpointName, endpointDefinition) {\n        const queryAction = (arg, { subscribe = true, forceRefetch, subscriptionOptions, [forceQueryFnSymbol]: forceQueryFn } = {})=>(dispatch, getState)=>{\n                const queryCacheKey = serializeQueryArgs({\n                    queryArgs: arg,\n                    endpointDefinition,\n                    endpointName\n                });\n                const thunk = queryThunk({\n                    type: \"query\",\n                    subscribe,\n                    forceRefetch,\n                    subscriptionOptions,\n                    endpointName,\n                    originalArgs: arg,\n                    queryCacheKey,\n                    [forceQueryFnSymbol]: forceQueryFn\n                });\n                const selector = api.endpoints[endpointName].select(arg);\n                const thunkResult = dispatch(thunk);\n                const stateAfter = selector(getState());\n                middlewareWarning(dispatch);\n                const { requestId, abort } = thunkResult;\n                const skippedSynchronously = stateAfter.requestId !== requestId;\n                const runningQuery = runningQueries.get(dispatch)?.[queryCacheKey];\n                const selectFromState = ()=>selector(getState());\n                const statePromise = Object.assign(forceQueryFn ? // a query has been forced (upsertQueryData)\n                // -> we want to resolve it once data has been written with the data that will be written\n                thunkResult.then(selectFromState) : skippedSynchronously && !runningQuery ? // a query has been skipped due to a condition and we do not have any currently running query\n                // -> we want to resolve it immediately with the current data\n                Promise.resolve(stateAfter) : // query just started or one is already in flight\n                // -> wait for the running query, then resolve with data from after that\n                Promise.all([\n                    runningQuery,\n                    thunkResult\n                ]).then(selectFromState), {\n                    arg,\n                    requestId,\n                    subscriptionOptions,\n                    queryCacheKey,\n                    abort,\n                    async unwrap () {\n                        const result = await statePromise;\n                        if (result.isError) {\n                            throw result.error;\n                        }\n                        return result.data;\n                    },\n                    refetch: ()=>dispatch(queryAction(arg, {\n                            subscribe: false,\n                            forceRefetch: true\n                        })),\n                    unsubscribe () {\n                        if (subscribe) dispatch(unsubscribeQueryResult({\n                            queryCacheKey,\n                            requestId\n                        }));\n                    },\n                    updateSubscriptionOptions (options) {\n                        statePromise.subscriptionOptions = options;\n                        dispatch(updateSubscriptionOptions({\n                            endpointName,\n                            requestId,\n                            queryCacheKey,\n                            options\n                        }));\n                    }\n                });\n                if (!runningQuery && !skippedSynchronously && !forceQueryFn) {\n                    const running = runningQueries.get(dispatch) || {};\n                    running[queryCacheKey] = statePromise;\n                    runningQueries.set(dispatch, running);\n                    statePromise.then(()=>{\n                        delete running[queryCacheKey];\n                        if (!countObjectKeys(running)) {\n                            runningQueries.delete(dispatch);\n                        }\n                    });\n                }\n                return statePromise;\n            };\n        return queryAction;\n    }\n    function buildInitiateMutation(endpointName) {\n        return (arg, { track = true, fixedCacheKey } = {})=>(dispatch, getState)=>{\n                const thunk = mutationThunk({\n                    type: \"mutation\",\n                    endpointName,\n                    originalArgs: arg,\n                    track,\n                    fixedCacheKey\n                });\n                const thunkResult = dispatch(thunk);\n                middlewareWarning(dispatch);\n                const { requestId, abort, unwrap } = thunkResult;\n                const returnValuePromise = asSafePromise(thunkResult.unwrap().then((data)=>({\n                        data\n                    })), (error)=>({\n                        error\n                    }));\n                const reset = ()=>{\n                    dispatch(removeMutationResult({\n                        requestId,\n                        fixedCacheKey\n                    }));\n                };\n                const ret = Object.assign(returnValuePromise, {\n                    arg: thunkResult.arg,\n                    requestId,\n                    abort,\n                    unwrap,\n                    reset\n                });\n                const running = runningMutations.get(dispatch) || {};\n                runningMutations.set(dispatch, running);\n                running[requestId] = ret;\n                ret.then(()=>{\n                    delete running[requestId];\n                    if (!countObjectKeys(running)) {\n                        runningMutations.delete(dispatch);\n                    }\n                });\n                if (fixedCacheKey) {\n                    running[fixedCacheKey] = ret;\n                    ret.then(()=>{\n                        if (running[fixedCacheKey] === ret) {\n                            delete running[fixedCacheKey];\n                            if (!countObjectKeys(running)) {\n                                runningMutations.delete(dispatch);\n                            }\n                        }\n                    });\n                }\n                return ret;\n            };\n    }\n}\n// src/query/core/buildThunks.ts\n\nfunction defaultTransformResponse(baseQueryReturnValue) {\n    return baseQueryReturnValue;\n}\nfunction buildThunks({ reducerPath, baseQuery, context: { endpointDefinitions }, serializeQueryArgs, api, assertTagType }) {\n    const patchQueryData = (endpointName, args, patches, updateProvided)=>(dispatch, getState)=>{\n            const endpointDefinition = endpointDefinitions[endpointName];\n            const queryCacheKey = serializeQueryArgs({\n                queryArgs: args,\n                endpointDefinition,\n                endpointName\n            });\n            dispatch(api.internalActions.queryResultPatched({\n                queryCacheKey,\n                patches\n            }));\n            if (!updateProvided) {\n                return;\n            }\n            const newValue = api.endpoints[endpointName].select(args)(// Work around TS 4.1 mismatch\n            getState());\n            const providedTags = calculateProvidedBy(endpointDefinition.providesTags, newValue.data, void 0, args, {}, assertTagType);\n            dispatch(api.internalActions.updateProvidedBy({\n                queryCacheKey,\n                providedTags\n            }));\n        };\n    const updateQueryData = (endpointName, args, updateRecipe, updateProvided = true)=>(dispatch, getState)=>{\n            const endpointDefinition = api.endpoints[endpointName];\n            const currentState = endpointDefinition.select(args)(// Work around TS 4.1 mismatch\n            getState());\n            let ret = {\n                patches: [],\n                inversePatches: [],\n                undo: ()=>dispatch(api.util.patchQueryData(endpointName, args, ret.inversePatches, updateProvided))\n            };\n            if (currentState.status === \"uninitialized\" /* uninitialized */ ) {\n                return ret;\n            }\n            let newValue;\n            if (\"data\" in currentState) {\n                if ((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(currentState.data)) {\n                    const [value, patches, inversePatches] = (0,immer__WEBPACK_IMPORTED_MODULE_2__.produceWithPatches)(currentState.data, updateRecipe);\n                    ret.patches.push(...patches);\n                    ret.inversePatches.push(...inversePatches);\n                    newValue = value;\n                } else {\n                    newValue = updateRecipe(currentState.data);\n                    ret.patches.push({\n                        op: \"replace\",\n                        path: [],\n                        value: newValue\n                    });\n                    ret.inversePatches.push({\n                        op: \"replace\",\n                        path: [],\n                        value: currentState.data\n                    });\n                }\n            }\n            dispatch(api.util.patchQueryData(endpointName, args, ret.patches, updateProvided));\n            return ret;\n        };\n    const upsertQueryData = (endpointName, args, value)=>(dispatch)=>{\n            return dispatch(api.endpoints[endpointName].initiate(args, {\n                subscribe: false,\n                forceRefetch: true,\n                [forceQueryFnSymbol]: ()=>({\n                        data: value\n                    })\n            }));\n        };\n    const executeEndpoint = async (arg, { signal, abort, rejectWithValue, fulfillWithValue, dispatch, getState, extra })=>{\n        const endpointDefinition = endpointDefinitions[arg.endpointName];\n        try {\n            let transformResponse = defaultTransformResponse;\n            let result;\n            const baseQueryApi = {\n                signal,\n                abort,\n                dispatch,\n                getState,\n                extra,\n                endpoint: arg.endpointName,\n                type: arg.type,\n                forced: arg.type === \"query\" ? isForcedQuery(arg, getState()) : void 0\n            };\n            const forceQueryFn = arg.type === \"query\" ? arg[forceQueryFnSymbol] : void 0;\n            if (forceQueryFn) {\n                result = forceQueryFn();\n            } else if (endpointDefinition.query) {\n                result = await baseQuery(endpointDefinition.query(arg.originalArgs), baseQueryApi, endpointDefinition.extraOptions);\n                if (endpointDefinition.transformResponse) {\n                    transformResponse = endpointDefinition.transformResponse;\n                }\n            } else {\n                result = await endpointDefinition.queryFn(arg.originalArgs, baseQueryApi, endpointDefinition.extraOptions, (arg2)=>baseQuery(arg2, baseQueryApi, endpointDefinition.extraOptions));\n            }\n            if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n                const what = endpointDefinition.query ? \"`baseQuery`\" : \"`queryFn`\";\n                let err;\n                if (!result) {\n                    err = `${what} did not return anything.`;\n                } else if (typeof result !== \"object\") {\n                    err = `${what} did not return an object.`;\n                } else if (result.error && result.data) {\n                    err = `${what} returned an object containing both \\`error\\` and \\`result\\`.`;\n                } else if (result.error === void 0 && result.data === void 0) {\n                    err = `${what} returned an object containing neither a valid \\`error\\` and \\`result\\`. At least one of them should not be \\`undefined\\``;\n                } else {\n                    for (const key of Object.keys(result)){\n                        if (key !== \"error\" && key !== \"data\" && key !== \"meta\") {\n                            err = `The object returned by ${what} has the unknown property ${key}.`;\n                            break;\n                        }\n                    }\n                }\n                if (err) {\n                    console.error(`Error encountered handling the endpoint ${arg.endpointName}.\n              ${err}\n              It needs to return an object with either the shape \\`{ data: <value> }\\` or \\`{ error: <value> }\\` that may contain an optional \\`meta\\` property.\n              Object returned was:`, result);\n                }\n            }\n            if (result.error) throw new HandledError(result.error, result.meta);\n            return fulfillWithValue(await transformResponse(result.data, result.meta, arg.originalArgs), {\n                fulfilledTimeStamp: Date.now(),\n                baseQueryMeta: result.meta,\n                [_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.SHOULD_AUTOBATCH]: true\n            });\n        } catch (error) {\n            let catchedError = error;\n            if (catchedError instanceof HandledError) {\n                let transformErrorResponse = defaultTransformResponse;\n                if (endpointDefinition.query && endpointDefinition.transformErrorResponse) {\n                    transformErrorResponse = endpointDefinition.transformErrorResponse;\n                }\n                try {\n                    return rejectWithValue(await transformErrorResponse(catchedError.value, catchedError.meta, arg.originalArgs), {\n                        baseQueryMeta: catchedError.meta,\n                        [_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.SHOULD_AUTOBATCH]: true\n                    });\n                } catch (e) {\n                    catchedError = e;\n                }\n            }\n            if (typeof process !== \"undefined\" && \"development\" !== \"production\") {\n                console.error(`An unhandled error occurred processing a request for the endpoint \"${arg.endpointName}\".\nIn the case of an unhandled error, no tags will be \"provided\" or \"invalidated\".`, catchedError);\n            } else {\n                console.error(catchedError);\n            }\n            throw catchedError;\n        }\n    };\n    function isForcedQuery(arg, state) {\n        const requestState = state[reducerPath]?.queries?.[arg.queryCacheKey];\n        const baseFetchOnMountOrArgChange = state[reducerPath]?.config.refetchOnMountOrArgChange;\n        const fulfilledVal = requestState?.fulfilledTimeStamp;\n        const refetchVal = arg.forceRefetch ?? (arg.subscribe && baseFetchOnMountOrArgChange);\n        if (refetchVal) {\n            return refetchVal === true || (Number(/* @__PURE__ */ new Date()) - Number(fulfilledVal)) / 1e3 >= refetchVal;\n        }\n        return false;\n    }\n    const queryThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAsyncThunk)(`${reducerPath}/executeQuery`, executeEndpoint, {\n        getPendingMeta () {\n            return {\n                startedTimeStamp: Date.now(),\n                [_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.SHOULD_AUTOBATCH]: true\n            };\n        },\n        condition (queryThunkArgs, { getState }) {\n            const state = getState();\n            const requestState = state[reducerPath]?.queries?.[queryThunkArgs.queryCacheKey];\n            const fulfilledVal = requestState?.fulfilledTimeStamp;\n            const currentArg = queryThunkArgs.originalArgs;\n            const previousArg = requestState?.originalArgs;\n            const endpointDefinition = endpointDefinitions[queryThunkArgs.endpointName];\n            if (isUpsertQuery(queryThunkArgs)) {\n                return true;\n            }\n            if (requestState?.status === \"pending\") {\n                return false;\n            }\n            if (isForcedQuery(queryThunkArgs, state)) {\n                return true;\n            }\n            if (isQueryDefinition(endpointDefinition) && endpointDefinition?.forceRefetch?.({\n                currentArg,\n                previousArg,\n                endpointState: requestState,\n                state\n            })) {\n                return true;\n            }\n            if (fulfilledVal) {\n                return false;\n            }\n            return true;\n        },\n        dispatchConditionRejection: true\n    });\n    const mutationThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAsyncThunk)(`${reducerPath}/executeMutation`, executeEndpoint, {\n        getPendingMeta () {\n            return {\n                startedTimeStamp: Date.now(),\n                [_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.SHOULD_AUTOBATCH]: true\n            };\n        }\n    });\n    const hasTheForce = (options)=>\"force\" in options;\n    const hasMaxAge = (options)=>\"ifOlderThan\" in options;\n    const prefetch = (endpointName, arg, options)=>(dispatch, getState)=>{\n            const force = hasTheForce(options) && options.force;\n            const maxAge = hasMaxAge(options) && options.ifOlderThan;\n            const queryAction = (force2 = true)=>api.endpoints[endpointName].initiate(arg, {\n                    forceRefetch: force2\n                });\n            const latestStateValue = api.endpoints[endpointName].select(arg)(getState());\n            if (force) {\n                dispatch(queryAction());\n            } else if (maxAge) {\n                const lastFulfilledTs = latestStateValue?.fulfilledTimeStamp;\n                if (!lastFulfilledTs) {\n                    dispatch(queryAction());\n                    return;\n                }\n                const shouldRetrigger = (Number(/* @__PURE__ */ new Date()) - Number(new Date(lastFulfilledTs))) / 1e3 >= maxAge;\n                if (shouldRetrigger) {\n                    dispatch(queryAction());\n                }\n            } else {\n                dispatch(queryAction(false));\n            }\n        };\n    function matchesEndpoint(endpointName) {\n        return (action)=>action?.meta?.arg?.endpointName === endpointName;\n    }\n    function buildMatchThunkActions(thunk, endpointName) {\n        return {\n            matchPending: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAllOf)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isPending)(thunk), matchesEndpoint(endpointName)),\n            matchFulfilled: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAllOf)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(thunk), matchesEndpoint(endpointName)),\n            matchRejected: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAllOf)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isRejected)(thunk), matchesEndpoint(endpointName))\n        };\n    }\n    return {\n        queryThunk,\n        mutationThunk,\n        prefetch,\n        updateQueryData,\n        upsertQueryData,\n        patchQueryData,\n        buildMatchThunkActions\n    };\n}\nfunction calculateProvidedByThunk(action, type, endpointDefinitions, assertTagType) {\n    return calculateProvidedBy(endpointDefinitions[action.meta.arg.endpointName][type], (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(action) ? action.payload : void 0, (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isRejectedWithValue)(action) ? action.payload : void 0, action.meta.arg.originalArgs, \"baseQueryMeta\" in action.meta ? action.meta.baseQueryMeta : void 0, assertTagType);\n}\n// src/query/core/buildSlice.ts\n\n\nfunction updateQuerySubstateIfExists(state, queryCacheKey, update) {\n    const substate = state[queryCacheKey];\n    if (substate) {\n        update(substate);\n    }\n}\nfunction getMutationCacheKey(id) {\n    return (\"arg\" in id ? id.arg.fixedCacheKey : id.fixedCacheKey) ?? id.requestId;\n}\nfunction updateMutationSubstateIfExists(state, id, update) {\n    const substate = state[getMutationCacheKey(id)];\n    if (substate) {\n        update(substate);\n    }\n}\nvar initialState = {};\nfunction buildSlice({ reducerPath, queryThunk, mutationThunk, context: { endpointDefinitions: definitions, apiUid, extractRehydrationInfo, hasRehydrationInfo }, assertTagType, config }) {\n    const resetApiState = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAction)(`${reducerPath}/resetApiState`);\n    const querySlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSlice)({\n        name: `${reducerPath}/queries`,\n        initialState,\n        reducers: {\n            removeQueryResult: {\n                reducer (draft, { payload: { queryCacheKey } }) {\n                    delete draft[queryCacheKey];\n                },\n                prepare: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.prepareAutoBatched)()\n            },\n            queryResultPatched: {\n                reducer (draft, { payload: { queryCacheKey, patches } }) {\n                    updateQuerySubstateIfExists(draft, queryCacheKey, (substate)=>{\n                        substate.data = (0,immer__WEBPACK_IMPORTED_MODULE_2__.applyPatches)(substate.data, patches.concat());\n                    });\n                },\n                prepare: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.prepareAutoBatched)()\n            }\n        },\n        extraReducers (builder) {\n            builder.addCase(queryThunk.pending, (draft, { meta, meta: { arg } })=>{\n                const upserting = isUpsertQuery(arg);\n                draft[arg.queryCacheKey] ??= {\n                    status: \"uninitialized\" /* uninitialized */ ,\n                    endpointName: arg.endpointName\n                };\n                updateQuerySubstateIfExists(draft, arg.queryCacheKey, (substate)=>{\n                    substate.status = \"pending\" /* pending */ ;\n                    substate.requestId = upserting && substate.requestId ? // for `upsertQuery` **updates**, keep the current `requestId`\n                    substate.requestId : // for normal queries or `upsertQuery` **inserts** always update the `requestId`\n                    meta.requestId;\n                    if (arg.originalArgs !== void 0) {\n                        substate.originalArgs = arg.originalArgs;\n                    }\n                    substate.startedTimeStamp = meta.startedTimeStamp;\n                });\n            }).addCase(queryThunk.fulfilled, (draft, { meta, payload })=>{\n                updateQuerySubstateIfExists(draft, meta.arg.queryCacheKey, (substate)=>{\n                    if (substate.requestId !== meta.requestId && !isUpsertQuery(meta.arg)) return;\n                    const { merge } = definitions[meta.arg.endpointName];\n                    substate.status = \"fulfilled\" /* fulfilled */ ;\n                    if (merge) {\n                        if (substate.data !== void 0) {\n                            const { fulfilledTimeStamp, arg, baseQueryMeta, requestId } = meta;\n                            let newData = (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(substate.data, (draftSubstateData)=>{\n                                return merge(draftSubstateData, payload, {\n                                    arg: arg.originalArgs,\n                                    baseQueryMeta,\n                                    fulfilledTimeStamp,\n                                    requestId\n                                });\n                            });\n                            substate.data = newData;\n                        } else {\n                            substate.data = payload;\n                        }\n                    } else {\n                        substate.data = definitions[meta.arg.endpointName].structuralSharing ?? true ? copyWithStructuralSharing((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(substate.data) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.original)(substate.data) : substate.data, payload) : payload;\n                    }\n                    delete substate.error;\n                    substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;\n                });\n            }).addCase(queryThunk.rejected, (draft, { meta: { condition, arg, requestId }, error, payload })=>{\n                updateQuerySubstateIfExists(draft, arg.queryCacheKey, (substate)=>{\n                    if (condition) {} else {\n                        if (substate.requestId !== requestId) return;\n                        substate.status = \"rejected\" /* rejected */ ;\n                        substate.error = payload ?? error;\n                    }\n                });\n            }).addMatcher(hasRehydrationInfo, (draft, action)=>{\n                const { queries } = extractRehydrationInfo(action);\n                for (const [key, entry] of Object.entries(queries)){\n                    if (// do not rehydrate entries that were currently in flight.\n                    entry?.status === \"fulfilled\" /* fulfilled */  || entry?.status === \"rejected\" /* rejected */ ) {\n                        draft[key] = entry;\n                    }\n                }\n            });\n        }\n    });\n    const mutationSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSlice)({\n        name: `${reducerPath}/mutations`,\n        initialState,\n        reducers: {\n            removeMutationResult: {\n                reducer (draft, { payload }) {\n                    const cacheKey = getMutationCacheKey(payload);\n                    if (cacheKey in draft) {\n                        delete draft[cacheKey];\n                    }\n                },\n                prepare: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.prepareAutoBatched)()\n            }\n        },\n        extraReducers (builder) {\n            builder.addCase(mutationThunk.pending, (draft, { meta, meta: { requestId, arg, startedTimeStamp } })=>{\n                if (!arg.track) return;\n                draft[getMutationCacheKey(meta)] = {\n                    requestId,\n                    status: \"pending\" /* pending */ ,\n                    endpointName: arg.endpointName,\n                    startedTimeStamp\n                };\n            }).addCase(mutationThunk.fulfilled, (draft, { payload, meta })=>{\n                if (!meta.arg.track) return;\n                updateMutationSubstateIfExists(draft, meta, (substate)=>{\n                    if (substate.requestId !== meta.requestId) return;\n                    substate.status = \"fulfilled\" /* fulfilled */ ;\n                    substate.data = payload;\n                    substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;\n                });\n            }).addCase(mutationThunk.rejected, (draft, { payload, error, meta })=>{\n                if (!meta.arg.track) return;\n                updateMutationSubstateIfExists(draft, meta, (substate)=>{\n                    if (substate.requestId !== meta.requestId) return;\n                    substate.status = \"rejected\" /* rejected */ ;\n                    substate.error = payload ?? error;\n                });\n            }).addMatcher(hasRehydrationInfo, (draft, action)=>{\n                const { mutations } = extractRehydrationInfo(action);\n                for (const [key, entry] of Object.entries(mutations)){\n                    if (// do not rehydrate entries that were currently in flight.\n                    (entry?.status === \"fulfilled\" /* fulfilled */  || entry?.status === \"rejected\" /* rejected */ ) && // only rehydrate endpoints that were persisted using a `fixedCacheKey`\n                    key !== entry?.requestId) {\n                        draft[key] = entry;\n                    }\n                }\n            });\n        }\n    });\n    const invalidationSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSlice)({\n        name: `${reducerPath}/invalidation`,\n        initialState,\n        reducers: {\n            updateProvidedBy: {\n                reducer (draft, action) {\n                    const { queryCacheKey, providedTags } = action.payload;\n                    for (const tagTypeSubscriptions of Object.values(draft)){\n                        for (const idSubscriptions of Object.values(tagTypeSubscriptions)){\n                            const foundAt = idSubscriptions.indexOf(queryCacheKey);\n                            if (foundAt !== -1) {\n                                idSubscriptions.splice(foundAt, 1);\n                            }\n                        }\n                    }\n                    for (const { type, id } of providedTags){\n                        const subscribedQueries = (draft[type] ??= {})[id || \"__internal_without_id\"] ??= [];\n                        const alreadySubscribed = subscribedQueries.includes(queryCacheKey);\n                        if (!alreadySubscribed) {\n                            subscribedQueries.push(queryCacheKey);\n                        }\n                    }\n                },\n                prepare: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.prepareAutoBatched)()\n            }\n        },\n        extraReducers (builder) {\n            builder.addCase(querySlice.actions.removeQueryResult, (draft, { payload: { queryCacheKey } })=>{\n                for (const tagTypeSubscriptions of Object.values(draft)){\n                    for (const idSubscriptions of Object.values(tagTypeSubscriptions)){\n                        const foundAt = idSubscriptions.indexOf(queryCacheKey);\n                        if (foundAt !== -1) {\n                            idSubscriptions.splice(foundAt, 1);\n                        }\n                    }\n                }\n            }).addMatcher(hasRehydrationInfo, (draft, action)=>{\n                const { provided } = extractRehydrationInfo(action);\n                for (const [type, incomingTags] of Object.entries(provided)){\n                    for (const [id, cacheKeys] of Object.entries(incomingTags)){\n                        const subscribedQueries = (draft[type] ??= {})[id || \"__internal_without_id\"] ??= [];\n                        for (const queryCacheKey of cacheKeys){\n                            const alreadySubscribed = subscribedQueries.includes(queryCacheKey);\n                            if (!alreadySubscribed) {\n                                subscribedQueries.push(queryCacheKey);\n                            }\n                        }\n                    }\n                }\n            }).addMatcher((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAnyOf)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(queryThunk), (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isRejectedWithValue)(queryThunk)), (draft, action)=>{\n                const providedTags = calculateProvidedByThunk(action, \"providesTags\", definitions, assertTagType);\n                const { queryCacheKey } = action.meta.arg;\n                invalidationSlice.caseReducers.updateProvidedBy(draft, invalidationSlice.actions.updateProvidedBy({\n                    queryCacheKey,\n                    providedTags\n                }));\n            });\n        }\n    });\n    const subscriptionSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSlice)({\n        name: `${reducerPath}/subscriptions`,\n        initialState,\n        reducers: {\n            updateSubscriptionOptions (d, a) {},\n            unsubscribeQueryResult (d, a) {},\n            internal_getRTKQSubscriptions () {}\n        }\n    });\n    const internalSubscriptionsSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSlice)({\n        name: `${reducerPath}/internalSubscriptions`,\n        initialState,\n        reducers: {\n            subscriptionsUpdated: {\n                reducer (state, action) {\n                    return (0,immer__WEBPACK_IMPORTED_MODULE_2__.applyPatches)(state, action.payload);\n                },\n                prepare: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.prepareAutoBatched)()\n            }\n        }\n    });\n    const configSlice = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createSlice)({\n        name: `${reducerPath}/config`,\n        initialState: {\n            online: isOnline(),\n            focused: isDocumentVisible(),\n            middlewareRegistered: false,\n            ...config\n        },\n        reducers: {\n            middlewareRegistered (state, { payload }) {\n                state.middlewareRegistered = state.middlewareRegistered === \"conflict\" || apiUid !== payload ? \"conflict\" : true;\n            }\n        },\n        extraReducers: (builder)=>{\n            builder.addCase(onOnline, (state)=>{\n                state.online = true;\n            }).addCase(onOffline, (state)=>{\n                state.online = false;\n            }).addCase(onFocus, (state)=>{\n                state.focused = true;\n            }).addCase(onFocusLost, (state)=>{\n                state.focused = false;\n            }).addMatcher(hasRehydrationInfo, (draft)=>({\n                    ...draft\n                }));\n        }\n    });\n    const combinedReducer = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.combineReducers)({\n        queries: querySlice.reducer,\n        mutations: mutationSlice.reducer,\n        provided: invalidationSlice.reducer,\n        subscriptions: internalSubscriptionsSlice.reducer,\n        config: configSlice.reducer\n    });\n    const reducer = (state, action)=>combinedReducer(resetApiState.match(action) ? void 0 : state, action);\n    const actions = {\n        ...configSlice.actions,\n        ...querySlice.actions,\n        ...subscriptionSlice.actions,\n        ...internalSubscriptionsSlice.actions,\n        ...mutationSlice.actions,\n        ...invalidationSlice.actions,\n        resetApiState\n    };\n    return {\n        reducer,\n        actions\n    };\n}\n// src/query/core/buildSelectors.ts\nvar skipToken = /* @__PURE__ */ Symbol.for(\"RTKQ/skipToken\");\nvar initialSubState = {\n    status: \"uninitialized\" /* uninitialized */ \n};\nvar defaultQuerySubState = /* @__PURE__ */ (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(initialSubState, ()=>{});\nvar defaultMutationSubState = /* @__PURE__ */ (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(initialSubState, ()=>{});\nfunction buildSelectors({ serializeQueryArgs, reducerPath, createSelector: createSelector2 }) {\n    const selectSkippedQuery = (state)=>defaultQuerySubState;\n    const selectSkippedMutation = (state)=>defaultMutationSubState;\n    return {\n        buildQuerySelector,\n        buildMutationSelector,\n        selectInvalidatedBy,\n        selectCachedArgsForQuery\n    };\n    function withRequestFlags(substate) {\n        return {\n            ...substate,\n            ...getRequestStatusFlags(substate.status)\n        };\n    }\n    function selectInternalState(rootState) {\n        const state = rootState[reducerPath];\n        if (true) {\n            if (!state) {\n                if (selectInternalState.triggered) return state;\n                selectInternalState.triggered = true;\n                console.error(`Error: No data found at \\`state.${reducerPath}\\`. Did you forget to add the reducer to the store?`);\n            }\n        }\n        return state;\n    }\n    function buildQuerySelector(endpointName, endpointDefinition) {\n        return (queryArgs)=>{\n            const serializedArgs = serializeQueryArgs({\n                queryArgs,\n                endpointDefinition,\n                endpointName\n            });\n            const selectQuerySubstate = (state)=>selectInternalState(state)?.queries?.[serializedArgs] ?? defaultQuerySubState;\n            const finalSelectQuerySubState = queryArgs === skipToken ? selectSkippedQuery : selectQuerySubstate;\n            return createSelector2(finalSelectQuerySubState, withRequestFlags);\n        };\n    }\n    function buildMutationSelector() {\n        return (id)=>{\n            let mutationId;\n            if (typeof id === \"object\") {\n                mutationId = getMutationCacheKey(id) ?? skipToken;\n            } else {\n                mutationId = id;\n            }\n            const selectMutationSubstate = (state)=>selectInternalState(state)?.mutations?.[mutationId] ?? defaultMutationSubState;\n            const finalSelectMutationSubstate = mutationId === skipToken ? selectSkippedMutation : selectMutationSubstate;\n            return createSelector2(finalSelectMutationSubstate, withRequestFlags);\n        };\n    }\n    function selectInvalidatedBy(state, tags) {\n        const apiState = state[reducerPath];\n        const toInvalidate = /* @__PURE__ */ new Set();\n        for (const tag of tags.map(expandTagDescription)){\n            const provided = apiState.provided[tag.type];\n            if (!provided) {\n                continue;\n            }\n            let invalidateSubscriptions = (tag.id !== void 0 ? // id given: invalidate all queries that provide this type & id\n            provided[tag.id] : // no id: invalidate all queries that provide this type\n            flatten(Object.values(provided))) ?? [];\n            for (const invalidate of invalidateSubscriptions){\n                toInvalidate.add(invalidate);\n            }\n        }\n        return flatten(Array.from(toInvalidate.values()).map((queryCacheKey)=>{\n            const querySubState = apiState.queries[queryCacheKey];\n            return querySubState ? [\n                {\n                    queryCacheKey,\n                    endpointName: querySubState.endpointName,\n                    originalArgs: querySubState.originalArgs\n                }\n            ] : [];\n        }));\n    }\n    function selectCachedArgsForQuery(state, queryName) {\n        return Object.values(state[reducerPath].queries).filter((entry)=>entry?.endpointName === queryName && entry.status !== \"uninitialized\" /* uninitialized */ ).map((entry)=>entry.originalArgs);\n    }\n}\n// src/query/defaultSerializeQueryArgs.ts\nvar cache = WeakMap ? /* @__PURE__ */ new WeakMap() : void 0;\nvar defaultSerializeQueryArgs = ({ endpointName, queryArgs })=>{\n    let serialized = \"\";\n    const cached = cache?.get(queryArgs);\n    if (typeof cached === \"string\") {\n        serialized = cached;\n    } else {\n        const stringified = JSON.stringify(queryArgs, (key, value)=>(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) ? Object.keys(value).sort().reduce((acc, key2)=>{\n                acc[key2] = value[key2];\n                return acc;\n            }, {}) : value);\n        if ((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(queryArgs)) {\n            cache?.set(queryArgs, stringified);\n        }\n        serialized = stringified;\n    }\n    return `${endpointName}(${serialized})`;\n};\n// src/query/createApi.ts\n\nfunction buildCreateApi(...modules) {\n    return function baseCreateApi(options) {\n        const extractRehydrationInfo = (0,reselect__WEBPACK_IMPORTED_MODULE_3__.weakMapMemoize)((action)=>options.extractRehydrationInfo?.(action, {\n                reducerPath: options.reducerPath ?? \"api\"\n            }));\n        const optionsWithDefaults = {\n            reducerPath: \"api\",\n            keepUnusedDataFor: 60,\n            refetchOnMountOrArgChange: false,\n            refetchOnFocus: false,\n            refetchOnReconnect: false,\n            invalidationBehavior: \"delayed\",\n            ...options,\n            extractRehydrationInfo,\n            serializeQueryArgs (queryArgsApi) {\n                let finalSerializeQueryArgs = defaultSerializeQueryArgs;\n                if (\"serializeQueryArgs\" in queryArgsApi.endpointDefinition) {\n                    const endpointSQA = queryArgsApi.endpointDefinition.serializeQueryArgs;\n                    finalSerializeQueryArgs = (queryArgsApi2)=>{\n                        const initialResult = endpointSQA(queryArgsApi2);\n                        if (typeof initialResult === \"string\") {\n                            return initialResult;\n                        } else {\n                            return defaultSerializeQueryArgs({\n                                ...queryArgsApi2,\n                                queryArgs: initialResult\n                            });\n                        }\n                    };\n                } else if (options.serializeQueryArgs) {\n                    finalSerializeQueryArgs = options.serializeQueryArgs;\n                }\n                return finalSerializeQueryArgs(queryArgsApi);\n            },\n            tagTypes: [\n                ...options.tagTypes || []\n            ]\n        };\n        const context = {\n            endpointDefinitions: {},\n            batch (fn) {\n                fn();\n            },\n            apiUid: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.nanoid)(),\n            extractRehydrationInfo,\n            hasRehydrationInfo: (0,reselect__WEBPACK_IMPORTED_MODULE_3__.weakMapMemoize)((action)=>extractRehydrationInfo(action) != null)\n        };\n        const api = {\n            injectEndpoints,\n            enhanceEndpoints ({ addTagTypes, endpoints }) {\n                if (addTagTypes) {\n                    for (const eT of addTagTypes){\n                        if (!optionsWithDefaults.tagTypes.includes(eT)) {\n                            ;\n                            optionsWithDefaults.tagTypes.push(eT);\n                        }\n                    }\n                }\n                if (endpoints) {\n                    for (const [endpointName, partialDefinition] of Object.entries(endpoints)){\n                        if (typeof partialDefinition === \"function\") {\n                            partialDefinition(context.endpointDefinitions[endpointName]);\n                        } else {\n                            Object.assign(context.endpointDefinitions[endpointName] || {}, partialDefinition);\n                        }\n                    }\n                }\n                return api;\n            }\n        };\n        const initializedModules = modules.map((m)=>m.init(api, optionsWithDefaults, context));\n        function injectEndpoints(inject) {\n            const evaluatedEndpoints = inject.endpoints({\n                query: (x)=>({\n                        ...x,\n                        type: \"query\" /* query */ \n                    }),\n                mutation: (x)=>({\n                        ...x,\n                        type: \"mutation\" /* mutation */ \n                    })\n            });\n            for (const [endpointName, definition] of Object.entries(evaluatedEndpoints)){\n                if (!inject.overrideExisting && endpointName in context.endpointDefinitions) {\n                    if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n                        console.error(`called \\`injectEndpoints\\` to override already-existing endpointName ${endpointName} without specifying \\`overrideExisting: true\\``);\n                    }\n                    continue;\n                }\n                context.endpointDefinitions[endpointName] = definition;\n                for (const m of initializedModules){\n                    m.injectEndpoint(endpointName, definition);\n                }\n            }\n            return api;\n        }\n        return api.injectEndpoints({\n            endpoints: options.endpoints\n        });\n    };\n}\n// src/query/fakeBaseQuery.ts\n\nfunction fakeBaseQuery() {\n    return function() {\n        throw new Error( false ? 0 : \"When using `fakeBaseQuery`, all queries & mutations must use the `queryFn` definition syntax.\");\n    };\n}\n// src/query/core/buildMiddleware/cacheCollection.ts\nfunction isObjectEmpty(obj) {\n    for(let k in obj){\n        return false;\n    }\n    return true;\n}\nvar THIRTY_TWO_BIT_MAX_TIMER_SECONDS = 2147483647 / 1e3 - 1;\nvar buildCacheCollectionHandler = ({ reducerPath, api, context, internalState })=>{\n    const { removeQueryResult, unsubscribeQueryResult } = api.internalActions;\n    function anySubscriptionsRemainingForKey(queryCacheKey) {\n        const subscriptions = internalState.currentSubscriptions[queryCacheKey];\n        return !!subscriptions && !isObjectEmpty(subscriptions);\n    }\n    const currentRemovalTimeouts = {};\n    const handler = (action, mwApi, internalState2)=>{\n        if (unsubscribeQueryResult.match(action)) {\n            const state = mwApi.getState()[reducerPath];\n            const { queryCacheKey } = action.payload;\n            handleUnsubscribe(queryCacheKey, state.queries[queryCacheKey]?.endpointName, mwApi, state.config);\n        }\n        if (api.util.resetApiState.match(action)) {\n            for (const [key, timeout] of Object.entries(currentRemovalTimeouts)){\n                if (timeout) clearTimeout(timeout);\n                delete currentRemovalTimeouts[key];\n            }\n        }\n        if (context.hasRehydrationInfo(action)) {\n            const state = mwApi.getState()[reducerPath];\n            const { queries } = context.extractRehydrationInfo(action);\n            for (const [queryCacheKey, queryState] of Object.entries(queries)){\n                handleUnsubscribe(queryCacheKey, queryState?.endpointName, mwApi, state.config);\n            }\n        }\n    };\n    function handleUnsubscribe(queryCacheKey, endpointName, api2, config) {\n        const endpointDefinition = context.endpointDefinitions[endpointName];\n        const keepUnusedDataFor = endpointDefinition?.keepUnusedDataFor ?? config.keepUnusedDataFor;\n        if (keepUnusedDataFor === Infinity) {\n            return;\n        }\n        const finalKeepUnusedDataFor = Math.max(0, Math.min(keepUnusedDataFor, THIRTY_TWO_BIT_MAX_TIMER_SECONDS));\n        if (!anySubscriptionsRemainingForKey(queryCacheKey)) {\n            const currentTimeout = currentRemovalTimeouts[queryCacheKey];\n            if (currentTimeout) {\n                clearTimeout(currentTimeout);\n            }\n            currentRemovalTimeouts[queryCacheKey] = setTimeout(()=>{\n                if (!anySubscriptionsRemainingForKey(queryCacheKey)) {\n                    api2.dispatch(removeQueryResult({\n                        queryCacheKey\n                    }));\n                }\n                delete currentRemovalTimeouts[queryCacheKey];\n            }, finalKeepUnusedDataFor * 1e3);\n        }\n    }\n    return handler;\n};\n// src/query/core/buildMiddleware/invalidationByTags.ts\nvar buildInvalidationByTagsHandler = ({ reducerPath, context, context: { endpointDefinitions }, mutationThunk, queryThunk, api, assertTagType, refetchQuery, internalState })=>{\n    const { removeQueryResult } = api.internalActions;\n    const isThunkActionWithTags = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAnyOf)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(mutationThunk), (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isRejectedWithValue)(mutationThunk));\n    const isQueryEnd = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAnyOf)((0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(mutationThunk, queryThunk), (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isRejected)(mutationThunk, queryThunk));\n    let pendingTagInvalidations = [];\n    const handler = (action, mwApi)=>{\n        if (isThunkActionWithTags(action)) {\n            invalidateTags(calculateProvidedByThunk(action, \"invalidatesTags\", endpointDefinitions, assertTagType), mwApi);\n        } else if (isQueryEnd(action)) {\n            invalidateTags([], mwApi);\n        } else if (api.util.invalidateTags.match(action)) {\n            invalidateTags(calculateProvidedBy(action.payload, void 0, void 0, void 0, void 0, assertTagType), mwApi);\n        }\n    };\n    function hasPendingRequests(state) {\n        for(const key in state.queries){\n            if (state.queries[key]?.status === \"pending\" /* pending */ ) return true;\n        }\n        for(const key in state.mutations){\n            if (state.mutations[key]?.status === \"pending\" /* pending */ ) return true;\n        }\n        return false;\n    }\n    function invalidateTags(newTags, mwApi) {\n        const rootState = mwApi.getState();\n        const state = rootState[reducerPath];\n        pendingTagInvalidations.push(...newTags);\n        if (state.config.invalidationBehavior === \"delayed\" && hasPendingRequests(state)) {\n            return;\n        }\n        const tags = pendingTagInvalidations;\n        pendingTagInvalidations = [];\n        if (tags.length === 0) return;\n        const toInvalidate = api.util.selectInvalidatedBy(rootState, tags);\n        context.batch(()=>{\n            const valuesArray = Array.from(toInvalidate.values());\n            for (const { queryCacheKey } of valuesArray){\n                const querySubState = state.queries[queryCacheKey];\n                const subscriptionSubState = internalState.currentSubscriptions[queryCacheKey] ?? {};\n                if (querySubState) {\n                    if (countObjectKeys(subscriptionSubState) === 0) {\n                        mwApi.dispatch(removeQueryResult({\n                            queryCacheKey\n                        }));\n                    } else if (querySubState.status !== \"uninitialized\" /* uninitialized */ ) {\n                        mwApi.dispatch(refetchQuery(querySubState, queryCacheKey));\n                    }\n                }\n            }\n        });\n    }\n    return handler;\n};\n// src/query/core/buildMiddleware/polling.ts\nvar buildPollingHandler = ({ reducerPath, queryThunk, api, refetchQuery, internalState })=>{\n    const currentPolls = {};\n    const handler = (action, mwApi)=>{\n        if (api.internalActions.updateSubscriptionOptions.match(action) || api.internalActions.unsubscribeQueryResult.match(action)) {\n            updatePollingInterval(action.payload, mwApi);\n        }\n        if (queryThunk.pending.match(action) || queryThunk.rejected.match(action) && action.meta.condition) {\n            updatePollingInterval(action.meta.arg, mwApi);\n        }\n        if (queryThunk.fulfilled.match(action) || queryThunk.rejected.match(action) && !action.meta.condition) {\n            startNextPoll(action.meta.arg, mwApi);\n        }\n        if (api.util.resetApiState.match(action)) {\n            clearPolls();\n        }\n    };\n    function startNextPoll({ queryCacheKey }, api2) {\n        const state = api2.getState()[reducerPath];\n        const querySubState = state.queries[queryCacheKey];\n        const subscriptions = internalState.currentSubscriptions[queryCacheKey];\n        if (!querySubState || querySubState.status === \"uninitialized\" /* uninitialized */ ) return;\n        const { lowestPollingInterval, skipPollingIfUnfocused } = findLowestPollingInterval(subscriptions);\n        if (!Number.isFinite(lowestPollingInterval)) return;\n        const currentPoll = currentPolls[queryCacheKey];\n        if (currentPoll?.timeout) {\n            clearTimeout(currentPoll.timeout);\n            currentPoll.timeout = void 0;\n        }\n        const nextPollTimestamp = Date.now() + lowestPollingInterval;\n        currentPolls[queryCacheKey] = {\n            nextPollTimestamp,\n            pollingInterval: lowestPollingInterval,\n            timeout: setTimeout(()=>{\n                if (state.config.focused || !skipPollingIfUnfocused) {\n                    api2.dispatch(refetchQuery(querySubState, queryCacheKey));\n                }\n                startNextPoll({\n                    queryCacheKey\n                }, api2);\n            }, lowestPollingInterval)\n        };\n    }\n    function updatePollingInterval({ queryCacheKey }, api2) {\n        const state = api2.getState()[reducerPath];\n        const querySubState = state.queries[queryCacheKey];\n        const subscriptions = internalState.currentSubscriptions[queryCacheKey];\n        if (!querySubState || querySubState.status === \"uninitialized\" /* uninitialized */ ) {\n            return;\n        }\n        const { lowestPollingInterval } = findLowestPollingInterval(subscriptions);\n        if (!Number.isFinite(lowestPollingInterval)) {\n            cleanupPollForKey(queryCacheKey);\n            return;\n        }\n        const currentPoll = currentPolls[queryCacheKey];\n        const nextPollTimestamp = Date.now() + lowestPollingInterval;\n        if (!currentPoll || nextPollTimestamp < currentPoll.nextPollTimestamp) {\n            startNextPoll({\n                queryCacheKey\n            }, api2);\n        }\n    }\n    function cleanupPollForKey(key) {\n        const existingPoll = currentPolls[key];\n        if (existingPoll?.timeout) {\n            clearTimeout(existingPoll.timeout);\n        }\n        delete currentPolls[key];\n    }\n    function clearPolls() {\n        for (const key of Object.keys(currentPolls)){\n            cleanupPollForKey(key);\n        }\n    }\n    function findLowestPollingInterval(subscribers = {}) {\n        let skipPollingIfUnfocused = false;\n        let lowestPollingInterval = Number.POSITIVE_INFINITY;\n        for(let key in subscribers){\n            if (!!subscribers[key].pollingInterval) {\n                lowestPollingInterval = Math.min(subscribers[key].pollingInterval, lowestPollingInterval);\n                skipPollingIfUnfocused = subscribers[key].skipPollingIfUnfocused || skipPollingIfUnfocused;\n            }\n        }\n        return {\n            lowestPollingInterval,\n            skipPollingIfUnfocused\n        };\n    }\n    return handler;\n};\n// src/query/core/buildMiddleware/windowEventHandling.ts\nvar buildWindowEventHandler = ({ reducerPath, context, api, refetchQuery, internalState })=>{\n    const { removeQueryResult } = api.internalActions;\n    const handler = (action, mwApi)=>{\n        if (onFocus.match(action)) {\n            refetchValidQueries(mwApi, \"refetchOnFocus\");\n        }\n        if (onOnline.match(action)) {\n            refetchValidQueries(mwApi, \"refetchOnReconnect\");\n        }\n    };\n    function refetchValidQueries(api2, type) {\n        const state = api2.getState()[reducerPath];\n        const queries = state.queries;\n        const subscriptions = internalState.currentSubscriptions;\n        context.batch(()=>{\n            for (const queryCacheKey of Object.keys(subscriptions)){\n                const querySubState = queries[queryCacheKey];\n                const subscriptionSubState = subscriptions[queryCacheKey];\n                if (!subscriptionSubState || !querySubState) continue;\n                const shouldRefetch = Object.values(subscriptionSubState).some((sub)=>sub[type] === true) || Object.values(subscriptionSubState).every((sub)=>sub[type] === void 0) && state.config[type];\n                if (shouldRefetch) {\n                    if (countObjectKeys(subscriptionSubState) === 0) {\n                        api2.dispatch(removeQueryResult({\n                            queryCacheKey\n                        }));\n                    } else if (querySubState.status !== \"uninitialized\" /* uninitialized */ ) {\n                        api2.dispatch(refetchQuery(querySubState, queryCacheKey));\n                    }\n                }\n            }\n        });\n    }\n    return handler;\n};\n// src/query/core/buildMiddleware/cacheLifecycle.ts\nvar neverResolvedError = new Error(\"Promise never resolved before cacheEntryRemoved.\");\nvar buildCacheLifecycleHandler = ({ api, reducerPath, context, queryThunk, mutationThunk, internalState })=>{\n    const isQueryThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAsyncThunkAction)(queryThunk);\n    const isMutationThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isAsyncThunkAction)(mutationThunk);\n    const isFulfilledThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(queryThunk, mutationThunk);\n    const lifecycleMap = {};\n    const handler = (action, mwApi, stateBefore)=>{\n        const cacheKey = getCacheKey(action);\n        if (queryThunk.pending.match(action)) {\n            const oldState = stateBefore[reducerPath].queries[cacheKey];\n            const state = mwApi.getState()[reducerPath].queries[cacheKey];\n            if (!oldState && state) {\n                handleNewKey(action.meta.arg.endpointName, action.meta.arg.originalArgs, cacheKey, mwApi, action.meta.requestId);\n            }\n        } else if (mutationThunk.pending.match(action)) {\n            const state = mwApi.getState()[reducerPath].mutations[cacheKey];\n            if (state) {\n                handleNewKey(action.meta.arg.endpointName, action.meta.arg.originalArgs, cacheKey, mwApi, action.meta.requestId);\n            }\n        } else if (isFulfilledThunk(action)) {\n            const lifecycle = lifecycleMap[cacheKey];\n            if (lifecycle?.valueResolved) {\n                lifecycle.valueResolved({\n                    data: action.payload,\n                    meta: action.meta.baseQueryMeta\n                });\n                delete lifecycle.valueResolved;\n            }\n        } else if (api.internalActions.removeQueryResult.match(action) || api.internalActions.removeMutationResult.match(action)) {\n            const lifecycle = lifecycleMap[cacheKey];\n            if (lifecycle) {\n                delete lifecycleMap[cacheKey];\n                lifecycle.cacheEntryRemoved();\n            }\n        } else if (api.util.resetApiState.match(action)) {\n            for (const [cacheKey2, lifecycle] of Object.entries(lifecycleMap)){\n                delete lifecycleMap[cacheKey2];\n                lifecycle.cacheEntryRemoved();\n            }\n        }\n    };\n    function getCacheKey(action) {\n        if (isQueryThunk(action)) return action.meta.arg.queryCacheKey;\n        if (isMutationThunk(action)) {\n            return action.meta.arg.fixedCacheKey ?? action.meta.requestId;\n        }\n        if (api.internalActions.removeQueryResult.match(action)) return action.payload.queryCacheKey;\n        if (api.internalActions.removeMutationResult.match(action)) return getMutationCacheKey(action.payload);\n        return \"\";\n    }\n    function handleNewKey(endpointName, originalArgs, queryCacheKey, mwApi, requestId) {\n        const endpointDefinition = context.endpointDefinitions[endpointName];\n        const onCacheEntryAdded = endpointDefinition?.onCacheEntryAdded;\n        if (!onCacheEntryAdded) return;\n        let lifecycle = {};\n        const cacheEntryRemoved = new Promise((resolve)=>{\n            lifecycle.cacheEntryRemoved = resolve;\n        });\n        const cacheDataLoaded = Promise.race([\n            new Promise((resolve)=>{\n                lifecycle.valueResolved = resolve;\n            }),\n            cacheEntryRemoved.then(()=>{\n                throw neverResolvedError;\n            })\n        ]);\n        cacheDataLoaded.catch(()=>{});\n        lifecycleMap[queryCacheKey] = lifecycle;\n        const selector = api.endpoints[endpointName].select(endpointDefinition.type === \"query\" /* query */  ? originalArgs : queryCacheKey);\n        const extra = mwApi.dispatch((_, __, extra2)=>extra2);\n        const lifecycleApi = {\n            ...mwApi,\n            getCacheEntry: ()=>selector(mwApi.getState()),\n            requestId,\n            extra,\n            updateCachedData: endpointDefinition.type === \"query\" /* query */  ? (updateRecipe)=>mwApi.dispatch(api.util.updateQueryData(endpointName, originalArgs, updateRecipe)) : void 0,\n            cacheDataLoaded,\n            cacheEntryRemoved\n        };\n        const runningHandler = onCacheEntryAdded(originalArgs, lifecycleApi);\n        Promise.resolve(runningHandler).catch((e)=>{\n            if (e === neverResolvedError) return;\n            throw e;\n        });\n    }\n    return handler;\n};\n// src/query/core/buildMiddleware/queryLifecycle.ts\nvar buildQueryLifecycleHandler = ({ api, context, queryThunk, mutationThunk })=>{\n    const isPendingThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isPending)(queryThunk, mutationThunk);\n    const isRejectedThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isRejected)(queryThunk, mutationThunk);\n    const isFullfilledThunk = (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.isFulfilled)(queryThunk, mutationThunk);\n    const lifecycleMap = {};\n    const handler = (action, mwApi)=>{\n        if (isPendingThunk(action)) {\n            const { requestId, arg: { endpointName, originalArgs } } = action.meta;\n            const endpointDefinition = context.endpointDefinitions[endpointName];\n            const onQueryStarted = endpointDefinition?.onQueryStarted;\n            if (onQueryStarted) {\n                const lifecycle = {};\n                const queryFulfilled = new Promise((resolve, reject)=>{\n                    lifecycle.resolve = resolve;\n                    lifecycle.reject = reject;\n                });\n                queryFulfilled.catch(()=>{});\n                lifecycleMap[requestId] = lifecycle;\n                const selector = api.endpoints[endpointName].select(endpointDefinition.type === \"query\" /* query */  ? originalArgs : requestId);\n                const extra = mwApi.dispatch((_, __, extra2)=>extra2);\n                const lifecycleApi = {\n                    ...mwApi,\n                    getCacheEntry: ()=>selector(mwApi.getState()),\n                    requestId,\n                    extra,\n                    updateCachedData: endpointDefinition.type === \"query\" /* query */  ? (updateRecipe)=>mwApi.dispatch(api.util.updateQueryData(endpointName, originalArgs, updateRecipe)) : void 0,\n                    queryFulfilled\n                };\n                onQueryStarted(originalArgs, lifecycleApi);\n            }\n        } else if (isFullfilledThunk(action)) {\n            const { requestId, baseQueryMeta } = action.meta;\n            lifecycleMap[requestId]?.resolve({\n                data: action.payload,\n                meta: baseQueryMeta\n            });\n            delete lifecycleMap[requestId];\n        } else if (isRejectedThunk(action)) {\n            const { requestId, rejectedWithValue, baseQueryMeta } = action.meta;\n            lifecycleMap[requestId]?.reject({\n                error: action.payload ?? action.error,\n                isUnhandledError: !rejectedWithValue,\n                meta: baseQueryMeta\n            });\n            delete lifecycleMap[requestId];\n        }\n    };\n    return handler;\n};\n// src/query/core/buildMiddleware/devMiddleware.ts\nvar buildDevCheckHandler = ({ api, context: { apiUid }, reducerPath })=>{\n    return (action, mwApi)=>{\n        if (api.util.resetApiState.match(action)) {\n            mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));\n        }\n        if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n            if (api.internalActions.middlewareRegistered.match(action) && action.payload === apiUid && mwApi.getState()[reducerPath]?.config?.middlewareRegistered === \"conflict\") {\n                console.warn(`There is a mismatch between slice and middleware for the reducerPath \"${reducerPath}\".\nYou can only have one api per reducer path, this will lead to crashes in various situations!${reducerPath === \"api\" ? `\nIf you have multiple apis, you *have* to specify the reducerPath option when using createApi!` : \"\"}`);\n            }\n        }\n    };\n};\n// src/query/core/buildMiddleware/batchActions.ts\n\nvar buildBatchedActionsHandler = ({ api, queryThunk, internalState })=>{\n    const subscriptionsPrefix = `${api.reducerPath}/subscriptions`;\n    let previousSubscriptions = null;\n    let updateSyncTimer = null;\n    const { updateSubscriptionOptions, unsubscribeQueryResult } = api.internalActions;\n    const actuallyMutateSubscriptions = (mutableState, action)=>{\n        if (updateSubscriptionOptions.match(action)) {\n            const { queryCacheKey, requestId, options } = action.payload;\n            if (mutableState?.[queryCacheKey]?.[requestId]) {\n                mutableState[queryCacheKey][requestId] = options;\n            }\n            return true;\n        }\n        if (unsubscribeQueryResult.match(action)) {\n            const { queryCacheKey, requestId } = action.payload;\n            if (mutableState[queryCacheKey]) {\n                delete mutableState[queryCacheKey][requestId];\n            }\n            return true;\n        }\n        if (api.internalActions.removeQueryResult.match(action)) {\n            delete mutableState[action.payload.queryCacheKey];\n            return true;\n        }\n        if (queryThunk.pending.match(action)) {\n            const { meta: { arg, requestId } } = action;\n            const substate = mutableState[arg.queryCacheKey] ??= {};\n            substate[`${requestId}_running`] = {};\n            if (arg.subscribe) {\n                substate[requestId] = arg.subscriptionOptions ?? substate[requestId] ?? {};\n            }\n            return true;\n        }\n        let mutated = false;\n        if (queryThunk.fulfilled.match(action) || queryThunk.rejected.match(action)) {\n            const state = mutableState[action.meta.arg.queryCacheKey] || {};\n            const key = `${action.meta.requestId}_running`;\n            mutated ||= !!state[key];\n            delete state[key];\n        }\n        if (queryThunk.rejected.match(action)) {\n            const { meta: { condition, arg, requestId } } = action;\n            if (condition && arg.subscribe) {\n                const substate = mutableState[arg.queryCacheKey] ??= {};\n                substate[requestId] = arg.subscriptionOptions ?? substate[requestId] ?? {};\n                mutated = true;\n            }\n        }\n        return mutated;\n    };\n    const getSubscriptions = ()=>internalState.currentSubscriptions;\n    const getSubscriptionCount = (queryCacheKey)=>{\n        const subscriptions = getSubscriptions();\n        const subscriptionsForQueryArg = subscriptions[queryCacheKey] ?? {};\n        return countObjectKeys(subscriptionsForQueryArg);\n    };\n    const isRequestSubscribed = (queryCacheKey, requestId)=>{\n        const subscriptions = getSubscriptions();\n        return !!subscriptions?.[queryCacheKey]?.[requestId];\n    };\n    const subscriptionSelectors = {\n        getSubscriptions,\n        getSubscriptionCount,\n        isRequestSubscribed\n    };\n    return (action, mwApi)=>{\n        if (!previousSubscriptions) {\n            previousSubscriptions = JSON.parse(JSON.stringify(internalState.currentSubscriptions));\n        }\n        if (api.util.resetApiState.match(action)) {\n            previousSubscriptions = internalState.currentSubscriptions = {};\n            updateSyncTimer = null;\n            return [\n                true,\n                false\n            ];\n        }\n        if (api.internalActions.internal_getRTKQSubscriptions.match(action)) {\n            return [\n                false,\n                subscriptionSelectors\n            ];\n        }\n        const didMutate = actuallyMutateSubscriptions(internalState.currentSubscriptions, action);\n        let actionShouldContinue = true;\n        if (didMutate) {\n            if (!updateSyncTimer) {\n                updateSyncTimer = setTimeout(()=>{\n                    const newSubscriptions = JSON.parse(JSON.stringify(internalState.currentSubscriptions));\n                    const [, patches] = (0,immer__WEBPACK_IMPORTED_MODULE_2__.produceWithPatches)(previousSubscriptions, ()=>newSubscriptions);\n                    mwApi.next(api.internalActions.subscriptionsUpdated(patches));\n                    previousSubscriptions = newSubscriptions;\n                    updateSyncTimer = null;\n                }, 500);\n            }\n            const isSubscriptionSliceAction = typeof action.type == \"string\" && !!action.type.startsWith(subscriptionsPrefix);\n            const isAdditionalSubscriptionAction = queryThunk.rejected.match(action) && action.meta.condition && !!action.meta.arg.subscribe;\n            actionShouldContinue = !isSubscriptionSliceAction && !isAdditionalSubscriptionAction;\n        }\n        return [\n            actionShouldContinue,\n            false\n        ];\n    };\n};\n// src/query/core/buildMiddleware/index.ts\nfunction buildMiddleware(input) {\n    const { reducerPath, queryThunk, api, context } = input;\n    const { apiUid } = context;\n    const actions = {\n        invalidateTags: (0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_1__.createAction)(`${reducerPath}/invalidateTags`)\n    };\n    const isThisApiSliceAction = (action)=>action.type.startsWith(`${reducerPath}/`);\n    const handlerBuilders = [\n        buildDevCheckHandler,\n        buildCacheCollectionHandler,\n        buildInvalidationByTagsHandler,\n        buildPollingHandler,\n        buildCacheLifecycleHandler,\n        buildQueryLifecycleHandler\n    ];\n    const middleware = (mwApi)=>{\n        let initialized2 = false;\n        let internalState = {\n            currentSubscriptions: {}\n        };\n        const builderArgs = {\n            ...input,\n            internalState,\n            refetchQuery,\n            isThisApiSliceAction\n        };\n        const handlers = handlerBuilders.map((build)=>build(builderArgs));\n        const batchedActionsHandler = buildBatchedActionsHandler(builderArgs);\n        const windowEventsHandler = buildWindowEventHandler(builderArgs);\n        return (next)=>{\n            return (action)=>{\n                if (!(0,_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__.isAction)(action)) {\n                    return next(action);\n                }\n                if (!initialized2) {\n                    initialized2 = true;\n                    mwApi.dispatch(api.internalActions.middlewareRegistered(apiUid));\n                }\n                const mwApiWithNext = {\n                    ...mwApi,\n                    next\n                };\n                const stateBefore = mwApi.getState();\n                const [actionShouldContinue, internalProbeResult] = batchedActionsHandler(action, mwApiWithNext, stateBefore);\n                let res;\n                if (actionShouldContinue) {\n                    res = next(action);\n                } else {\n                    res = internalProbeResult;\n                }\n                if (!!mwApi.getState()[reducerPath]) {\n                    windowEventsHandler(action, mwApiWithNext, stateBefore);\n                    if (isThisApiSliceAction(action) || context.hasRehydrationInfo(action)) {\n                        for (let handler of handlers){\n                            handler(action, mwApiWithNext, stateBefore);\n                        }\n                    }\n                }\n                return res;\n            };\n        };\n    };\n    return {\n        middleware,\n        actions\n    };\n    function refetchQuery(querySubState, queryCacheKey, override = {}) {\n        return queryThunk({\n            type: \"query\",\n            endpointName: querySubState.endpointName,\n            originalArgs: querySubState.originalArgs,\n            subscribe: false,\n            forceRefetch: true,\n            queryCacheKey,\n            ...override\n        });\n    }\n}\n// src/query/tsHelpers.ts\nfunction assertCast(v) {}\nfunction safeAssign(target, ...args) {\n    return Object.assign(target, ...args);\n}\n// src/query/core/module.ts\n\nvar coreModuleName = /* @__PURE__ */ Symbol();\nvar coreModule = ({ createSelector: createSelector2 = reselect__WEBPACK_IMPORTED_MODULE_3__.createSelector } = {})=>({\n        name: coreModuleName,\n        init (api, { baseQuery, tagTypes, reducerPath, serializeQueryArgs, keepUnusedDataFor, refetchOnMountOrArgChange, refetchOnFocus, refetchOnReconnect, invalidationBehavior }, context) {\n            (0,immer__WEBPACK_IMPORTED_MODULE_2__.enablePatches)();\n            assertCast(serializeQueryArgs);\n            const assertTagType = (tag)=>{\n                if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n                    if (!tagTypes.includes(tag.type)) {\n                        console.error(`Tag type '${tag.type}' was used, but not specified in \\`tagTypes\\`!`);\n                    }\n                }\n                return tag;\n            };\n            Object.assign(api, {\n                reducerPath,\n                endpoints: {},\n                internalActions: {\n                    onOnline,\n                    onOffline,\n                    onFocus,\n                    onFocusLost\n                },\n                util: {}\n            });\n            const { queryThunk, mutationThunk, patchQueryData, updateQueryData, upsertQueryData, prefetch, buildMatchThunkActions } = buildThunks({\n                baseQuery,\n                reducerPath,\n                context,\n                api,\n                serializeQueryArgs,\n                assertTagType\n            });\n            const { reducer, actions: sliceActions } = buildSlice({\n                context,\n                queryThunk,\n                mutationThunk,\n                reducerPath,\n                assertTagType,\n                config: {\n                    refetchOnFocus,\n                    refetchOnReconnect,\n                    refetchOnMountOrArgChange,\n                    keepUnusedDataFor,\n                    reducerPath,\n                    invalidationBehavior\n                }\n            });\n            safeAssign(api.util, {\n                patchQueryData,\n                updateQueryData,\n                upsertQueryData,\n                prefetch,\n                resetApiState: sliceActions.resetApiState\n            });\n            safeAssign(api.internalActions, sliceActions);\n            const { middleware, actions: middlewareActions } = buildMiddleware({\n                reducerPath,\n                context,\n                queryThunk,\n                mutationThunk,\n                api,\n                assertTagType\n            });\n            safeAssign(api.util, middlewareActions);\n            safeAssign(api, {\n                reducer,\n                middleware\n            });\n            const { buildQuerySelector, buildMutationSelector, selectInvalidatedBy, selectCachedArgsForQuery } = buildSelectors({\n                serializeQueryArgs,\n                reducerPath,\n                createSelector: createSelector2\n            });\n            safeAssign(api.util, {\n                selectInvalidatedBy,\n                selectCachedArgsForQuery\n            });\n            const { buildInitiateQuery, buildInitiateMutation, getRunningMutationThunk, getRunningMutationsThunk, getRunningQueriesThunk, getRunningQueryThunk } = buildInitiate({\n                queryThunk,\n                mutationThunk,\n                api,\n                serializeQueryArgs,\n                context\n            });\n            safeAssign(api.util, {\n                getRunningMutationThunk,\n                getRunningMutationsThunk,\n                getRunningQueryThunk,\n                getRunningQueriesThunk\n            });\n            return {\n                name: coreModuleName,\n                injectEndpoint (endpointName, definition) {\n                    const anyApi = api;\n                    anyApi.endpoints[endpointName] ??= {};\n                    if (isQueryDefinition(definition)) {\n                        safeAssign(anyApi.endpoints[endpointName], {\n                            name: endpointName,\n                            select: buildQuerySelector(endpointName, definition),\n                            initiate: buildInitiateQuery(endpointName, definition)\n                        }, buildMatchThunkActions(queryThunk, endpointName));\n                    } else if (isMutationDefinition(definition)) {\n                        safeAssign(anyApi.endpoints[endpointName], {\n                            name: endpointName,\n                            select: buildMutationSelector(),\n                            initiate: buildInitiateMutation(endpointName)\n                        }, buildMatchThunkActions(mutationThunk, endpointName));\n                    }\n                }\n            };\n        }\n    });\n// src/query/core/index.ts\nvar createApi = /* @__PURE__ */ buildCreateApi(coreModule());\n //# sourceMappingURL=rtk-query.modern.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L3F1ZXJ5L3J0ay1xdWVyeS5tb2Rlcm4ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSw2QkFBNkI7QUFDN0IsSUFBSUEsY0FBOEIsYUFBSCxHQUFJLEVBQUNDO0lBQ2xDQSxZQUFZLENBQUMsZ0JBQWdCLEdBQUc7SUFDaENBLFlBQVksQ0FBQyxVQUFVLEdBQUc7SUFDMUJBLFlBQVksQ0FBQyxZQUFZLEdBQUc7SUFDNUJBLFlBQVksQ0FBQyxXQUFXLEdBQUc7SUFDM0IsT0FBT0E7QUFDVCxHQUFHRCxlQUFlLENBQUM7QUFDbkIsU0FBU0Usc0JBQXNCQyxNQUFNO0lBQ25DLE9BQU87UUFDTEE7UUFDQUMsaUJBQWlCRCxXQUFXLGdCQUFnQixpQkFBaUI7UUFDN0RFLFdBQVdGLFdBQVcsVUFBVSxXQUFXO1FBQzNDRyxXQUFXSCxXQUFXLFlBQVksYUFBYTtRQUMvQ0ksU0FBU0osV0FBVyxXQUFXLFlBQVk7SUFDN0M7QUFDRjtBQUVBLG1DQUFtQztBQUNuQyxTQUFTSyxjQUFjQyxHQUFHO0lBQ3hCLE9BQU8sSUFBSUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFQyxJQUFJLENBQUNGO0FBQ3BDO0FBRUEsOEJBQThCO0FBQzlCLElBQUlHLHVCQUF1QixDQUFDSCxNQUFRQSxJQUFJSSxPQUFPLENBQUMsT0FBTztBQUN2RCxJQUFJQyxzQkFBc0IsQ0FBQ0wsTUFBUUEsSUFBSUksT0FBTyxDQUFDLE9BQU87QUFDdEQsU0FBU0UsU0FBU0MsSUFBSSxFQUFFUCxHQUFHO0lBQ3pCLElBQUksQ0FBQ08sTUFBTTtRQUNULE9BQU9QO0lBQ1Q7SUFDQSxJQUFJLENBQUNBLEtBQUs7UUFDUixPQUFPTztJQUNUO0lBQ0EsSUFBSVIsY0FBY0MsTUFBTTtRQUN0QixPQUFPQTtJQUNUO0lBQ0EsTUFBTVEsWUFBWUQsS0FBS0UsUUFBUSxDQUFDLFFBQVEsQ0FBQ1QsSUFBSVUsVUFBVSxDQUFDLE9BQU8sTUFBTTtJQUNyRUgsT0FBT0oscUJBQXFCSTtJQUM1QlAsTUFBTUssb0JBQW9CTDtJQUMxQixPQUFPLENBQUMsRUFBRU8sS0FBSyxFQUFFQyxVQUFVLEVBQUVSLElBQUksQ0FBQztBQUNwQztBQUVBLDZCQUE2QjtBQUM3QixJQUFJVyxVQUFVLENBQUNDLE1BQVEsRUFBRSxDQUFDQyxNQUFNLElBQUlEO0FBRXBDLDhCQUE4QjtBQUM5QixTQUFTRTtJQUNQLE9BQU8sT0FBT0MsY0FBYyxjQUFjLE9BQU9BLFVBQVVDLE1BQU0sS0FBSyxLQUFLLElBQUksT0FBT0QsVUFBVUMsTUFBTTtBQUN4RztBQUVBLHVDQUF1QztBQUN2QyxTQUFTQztJQUNQLElBQUksT0FBT0MsYUFBYSxhQUFhO1FBQ25DLE9BQU87SUFDVDtJQUNBLE9BQU9BLFNBQVNDLGVBQWUsS0FBSztBQUN0QztBQUVBLCtCQUErQjtBQUN3UTtBQUV2UywrQ0FBK0M7QUFDL0MsSUFBSW1CLGlCQUFpQkYsMkRBQWFBO0FBQ2xDLFNBQVNHLDBCQUEwQkMsTUFBTSxFQUFFQyxNQUFNO0lBQy9DLElBQUlELFdBQVdDLFVBQVUsQ0FBRUgsQ0FBQUEsZUFBZUUsV0FBV0YsZUFBZUcsV0FBV0MsTUFBTUMsT0FBTyxDQUFDSCxXQUFXRSxNQUFNQyxPQUFPLENBQUNGLE9BQU0sR0FBSTtRQUM5SCxPQUFPQTtJQUNUO0lBQ0EsTUFBTUcsVUFBVUMsT0FBT0MsSUFBSSxDQUFDTDtJQUM1QixNQUFNTSxVQUFVRixPQUFPQyxJQUFJLENBQUNOO0lBQzVCLElBQUlRLGVBQWVKLFFBQVFLLE1BQU0sS0FBS0YsUUFBUUUsTUFBTTtJQUNwRCxNQUFNQyxXQUFXUixNQUFNQyxPQUFPLENBQUNGLFVBQVUsRUFBRSxHQUFHLENBQUM7SUFDL0MsS0FBSyxNQUFNVSxPQUFPUCxRQUFTO1FBQ3pCTSxRQUFRLENBQUNDLElBQUksR0FBR1osMEJBQTBCQyxNQUFNLENBQUNXLElBQUksRUFBRVYsTUFBTSxDQUFDVSxJQUFJO1FBQ2xFLElBQUlILGNBQ0ZBLGVBQWVSLE1BQU0sQ0FBQ1csSUFBSSxLQUFLRCxRQUFRLENBQUNDLElBQUk7SUFDaEQ7SUFDQSxPQUFPSCxlQUFlUixTQUFTVTtBQUNqQztBQUVBLDhCQUE4QjtBQUM5QixJQUFJRSxpQkFBaUIsQ0FBQyxHQUFHQyxPQUFTQyxTQUFTRDtBQUMzQyxJQUFJRSx3QkFBd0IsQ0FBQ0MsV0FBYUEsU0FBUzlELE1BQU0sSUFBSSxPQUFPOEQsU0FBUzlELE1BQU0sSUFBSTtBQUN2RixJQUFJK0QsMkJBQTJCLENBQUNDLFVBQzlCLFVBQVUsR0FDVix5QkFBeUJ4RCxJQUFJLENBQUN3RCxRQUFRQyxHQUFHLENBQUMsbUJBQW1CO0FBRS9ELFNBQVNDLGVBQWVDLEdBQUc7SUFDekIsSUFBSSxDQUFDekIsK0RBQWFBLENBQUN5QixNQUFNO1FBQ3ZCLE9BQU9BO0lBQ1Q7SUFDQSxNQUFNQyxPQUFPO1FBQ1gsR0FBR0QsR0FBRztJQUNSO0lBQ0EsS0FBSyxNQUFNLENBQUNFLEdBQUdDLEVBQUUsSUFBSW5CLE9BQU9vQixPQUFPLENBQUNILE1BQU87UUFDekMsSUFBSUUsTUFBTSxLQUFLLEdBQ2IsT0FBT0YsSUFBSSxDQUFDQyxFQUFFO0lBQ2xCO0lBQ0EsT0FBT0Q7QUFDVDtBQUNBLFNBQVNJLGVBQWUsRUFDdEJDLE9BQU8sRUFDUEMsaUJBQWlCLENBQUNDLElBQU1BLENBQUMsRUFDekJDLFVBQVVsQixjQUFjLEVBQ3hCbUIsZ0JBQWdCLEVBQ2hCQyxvQkFBb0JmLHdCQUF3QixFQUM1Q2dCLGtCQUFrQixrQkFBa0IsRUFDcENDLFlBQVksRUFDWkMsU0FBU0MsY0FBYyxFQUN2QkMsaUJBQWlCQyxxQkFBcUIsRUFDdENDLGdCQUFnQkMsb0JBQW9CLEVBQ3BDLEdBQUdDLGtCQUNKLEdBQUcsQ0FBQyxDQUFDO0lBQ0osSUFBSSxPQUFPM0IsVUFBVSxlQUFlZ0IsWUFBWWxCLGdCQUFnQjtRQUM5RDhCLFFBQVFDLElBQUksQ0FBQztJQUNmO0lBQ0EsT0FBTyxPQUFPQyxLQUFLQztRQUNqQixNQUFNLEVBQ0pDLE1BQU0sRUFDTkMsUUFBUSxFQUNSQyxLQUFLLEVBQ0xDLFFBQVEsRUFDUkMsTUFBTSxFQUNOQyxJQUFJLEVBQ0wsR0FBR047UUFDSixJQUFJTztRQUNKLElBQUksRUFDRjVGLEdBQUcsRUFDSDBELFVBQVUsSUFBSW1DLFFBQVFaLGlCQUFpQnZCLE9BQU8sQ0FBQyxFQUMvQ29DLFNBQVMsS0FBSyxDQUFDLEVBQ2ZqQixrQkFBa0JDLHlCQUF5QixNQUFNLEVBQ2pEQyxpQkFBaUJDLHdCQUF3QnpCLHFCQUFxQixFQUM5RG9CLFVBQVVDLGNBQWMsRUFDeEIsR0FBR21CLE1BQ0osR0FBRyxPQUFPWCxPQUFPLFdBQVc7WUFDM0JwRixLQUFLb0Y7UUFDUCxJQUFJQTtRQUNKLElBQUlZLFNBQVM7WUFDWCxHQUFHZixnQkFBZ0I7WUFDbkJLO1lBQ0EsR0FBR1MsSUFBSTtRQUNUO1FBQ0FyQyxVQUFVLElBQUltQyxRQUFRakMsZUFBZUY7UUFDckNzQyxPQUFPdEMsT0FBTyxHQUFHLE1BQU1VLGVBQWVWLFNBQVM7WUFDN0M2QjtZQUNBQztZQUNBQztZQUNBQztZQUNBQztRQUNGLE1BQU1qQztRQUNOLE1BQU11QyxnQkFBZ0IsQ0FBQ0MsT0FBUyxPQUFPQSxTQUFTLFlBQWE5RCxDQUFBQSwrREFBYUEsQ0FBQzhELFNBQVN4RCxNQUFNQyxPQUFPLENBQUN1RCxTQUFTLE9BQU9BLEtBQUtDLE1BQU0sS0FBSyxVQUFTO1FBQzNJLElBQUksQ0FBQ0gsT0FBT3RDLE9BQU8sQ0FBQzBDLEdBQUcsQ0FBQyxtQkFBbUJILGNBQWNELE9BQU9FLElBQUksR0FBRztZQUNyRUYsT0FBT3RDLE9BQU8sQ0FBQzJDLEdBQUcsQ0FBQyxnQkFBZ0I1QjtRQUNyQztRQUNBLElBQUl3QixjQUFjRCxPQUFPRSxJQUFJLEtBQUsxQixrQkFBa0J3QixPQUFPdEMsT0FBTyxHQUFHO1lBQ25Fc0MsT0FBT0UsSUFBSSxHQUFHSSxLQUFLQyxTQUFTLENBQUNQLE9BQU9FLElBQUksRUFBRXhCO1FBQzVDO1FBQ0EsSUFBSW9CLFFBQVE7WUFDVixNQUFNVSxVQUFVLENBQUN4RyxJQUFJeUcsT0FBTyxDQUFDLE9BQU8sTUFBTTtZQUMxQyxNQUFNQyxRQUFRbkMsbUJBQW1CQSxpQkFBaUJ1QixVQUFVLElBQUlhLGdCQUFnQi9DLGVBQWVrQztZQUMvRjlGLE9BQU93RyxVQUFVRTtRQUNuQjtRQUNBMUcsTUFBTU0sU0FBUzZELFNBQVNuRTtRQUN4QixNQUFNNEcsVUFBVSxJQUFJQyxRQUFRN0csS0FBS2dHO1FBQ2pDLE1BQU1jLGVBQWUsSUFBSUQsUUFBUTdHLEtBQUtnRztRQUN0Q0osT0FBTztZQUNMZ0IsU0FBU0U7UUFDWDtRQUNBLElBQUl0RCxVQUFVdUQsV0FBVyxPQUFPQyxZQUFZckMsV0FBV3NDLFdBQVc7WUFDaEVGLFdBQVc7WUFDWDFCLElBQUk2QixLQUFLO1FBQ1gsR0FBR3ZDO1FBQ0gsSUFBSTtZQUNGbkIsV0FBVyxNQUFNYyxRQUFRc0M7UUFDM0IsRUFBRSxPQUFPTyxHQUFHO1lBQ1YsT0FBTztnQkFDTEMsT0FBTztvQkFDTDFILFFBQVFxSCxXQUFXLGtCQUFrQjtvQkFDckNLLE9BQU9DLE9BQU9GO2dCQUNoQjtnQkFDQXZCO1lBQ0Y7UUFDRixTQUFVO1lBQ1IsSUFBSW9CLFdBQ0ZNLGFBQWFOO1FBQ2pCO1FBQ0EsTUFBTU8sZ0JBQWdCL0QsU0FBU2dFLEtBQUs7UUFDcEM1QixLQUFLcEMsUUFBUSxHQUFHK0Q7UUFDaEIsSUFBSUU7UUFDSixJQUFJQyxlQUFlO1FBQ25CLElBQUk7WUFDRixJQUFJQztZQUNKLE1BQU1DLFFBQVFDLEdBQUcsQ0FBQztnQkFDaEJDLGVBQWV0RSxVQUFVcUIsaUJBQWlCa0QsSUFBSSxDQUFDLENBQUNDLElBQU1QLGFBQWFPLEdBQUcsQ0FBQ2IsSUFBTVEsc0JBQXNCUjtnQkFDbkcsaUZBQWlGO2dCQUNqRix3R0FBd0c7Z0JBQ3hHSSxjQUFjVSxJQUFJLEdBQUdGLElBQUksQ0FBQyxDQUFDQyxJQUFNTixlQUFlTSxHQUFHLEtBQ25EO2FBQ0Q7WUFDRCxJQUFJTCxxQkFDRixNQUFNQTtRQUNWLEVBQUUsT0FBT1IsR0FBRztZQUNWLE9BQU87Z0JBQ0xDLE9BQU87b0JBQ0wxSCxRQUFRO29CQUNSd0ksZ0JBQWdCMUUsU0FBUzlELE1BQU07b0JBQy9CeUksTUFBTVQ7b0JBQ05OLE9BQU9DLE9BQU9GO2dCQUNoQjtnQkFDQXZCO1lBQ0Y7UUFDRjtRQUNBLE9BQU9iLGVBQWV2QixVQUFVaUUsY0FBYztZQUM1Q1UsTUFBTVY7WUFDTjdCO1FBQ0YsSUFBSTtZQUNGd0IsT0FBTztnQkFDTDFILFFBQVE4RCxTQUFTOUQsTUFBTTtnQkFDdkJ5SSxNQUFNVjtZQUNSO1lBQ0E3QjtRQUNGO0lBQ0Y7SUFDQSxlQUFla0MsZUFBZXRFLFFBQVEsRUFBRXFCLGVBQWU7UUFDckQsSUFBSSxPQUFPQSxvQkFBb0IsWUFBWTtZQUN6QyxPQUFPQSxnQkFBZ0JyQjtRQUN6QjtRQUNBLElBQUlxQixvQkFBb0IsZ0JBQWdCO1lBQ3RDQSxrQkFBa0JMLGtCQUFrQmhCLFNBQVNFLE9BQU8sSUFBSSxTQUFTO1FBQ25FO1FBQ0EsSUFBSW1CLG9CQUFvQixRQUFRO1lBQzlCLE1BQU1vRCxPQUFPLE1BQU16RSxTQUFTeUUsSUFBSTtZQUNoQyxPQUFPQSxLQUFLaEYsTUFBTSxHQUFHcUQsS0FBSzhCLEtBQUssQ0FBQ0gsUUFBUTtRQUMxQztRQUNBLE9BQU96RSxTQUFTeUUsSUFBSTtJQUN0QjtBQUNGO0FBRUEsNEJBQTRCO0FBQzVCLElBQUlJLGVBQWU7SUFDakJDLFlBQVlDLEtBQUssRUFBRTNDLE9BQU8sS0FBSyxDQUFDLENBQUU7UUFDaEMsSUFBSSxDQUFDMkMsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQzNDLElBQUksR0FBR0E7SUFDZDtBQUNGO0FBRUEscUJBQXFCO0FBQ3JCLGVBQWU0QyxlQUFlQyxVQUFVLENBQUMsRUFBRUMsYUFBYSxDQUFDO0lBQ3ZELE1BQU1DLFdBQVdDLEtBQUtDLEdBQUcsQ0FBQ0osU0FBU0M7SUFDbkMsTUFBTS9ELFVBQVUsQ0FBQyxDQUFFLEVBQUNpRSxLQUFLRSxNQUFNLEtBQUssR0FBRSxJQUFNLFFBQU9ILFFBQU8sQ0FBQztJQUMzRCxNQUFNLElBQUlmLFFBQVEsQ0FBQ21CLFVBQVk5QixXQUFXLENBQUMrQixNQUFRRCxRQUFRQyxNQUFNckU7QUFDbkU7QUFDQSxTQUFTc0UsS0FBSzlCLENBQUM7SUFDYixNQUFNdEUsT0FBT3FHLE1BQU0sQ0FBQyxJQUFJYixhQUFhO1FBQ25DakIsT0FBT0Q7SUFDVCxJQUFJO1FBQ0ZnQyxrQkFBa0I7SUFDcEI7QUFDRjtBQUNBLElBQUlDLGdCQUFnQixDQUFDO0FBQ3JCLElBQUlDLG1CQUFtQixDQUFDQyxXQUFXQyxpQkFBbUIsT0FBT2xHLE1BQU1nQyxLQUFLbUU7UUFDdEUsTUFBTUMscUJBQXFCO1lBQUM7WUFBSUYsQ0FBQUEsa0JBQWtCSCxhQUFZLEVBQUdWLFVBQVU7WUFBR2MsQ0FBQUEsZ0JBQWdCSixhQUFZLEVBQUdWLFVBQVU7U0FBQyxDQUFDZ0IsTUFBTSxDQUFDLENBQUNyRixJQUFNQSxNQUFNLEtBQUs7UUFDbEosTUFBTSxDQUFDcUUsV0FBVyxHQUFHZSxtQkFBbUJFLEtBQUssQ0FBQyxDQUFDO1FBQy9DLE1BQU1DLHdCQUF3QixDQUFDQyxHQUFHQyxJQUFJLEVBQ3BDckIsT0FBTyxFQUNSLEdBQUtBLFdBQVdDO1FBQ2pCLE1BQU1xQixVQUFVO1lBQ2RyQjtZQUNBc0IsU0FBU3hCO1lBQ1R5QixnQkFBZ0JMO1lBQ2hCLEdBQUdMLGNBQWM7WUFDakIsR0FBR0MsWUFBWTtRQUNqQjtRQUNBLElBQUlVLFNBQVM7UUFDYixNQUFPLEtBQU07WUFDWCxJQUFJO2dCQUNGLE1BQU1DLFNBQVMsTUFBTWIsVUFBVWpHLE1BQU1nQyxLQUFLbUU7Z0JBQzFDLElBQUlXLE9BQU8vQyxLQUFLLEVBQUU7b0JBQ2hCLE1BQU0sSUFBSWlCLGFBQWE4QjtnQkFDekI7Z0JBQ0EsT0FBT0E7WUFDVCxFQUFFLE9BQU9oRCxHQUFHO2dCQUNWK0M7Z0JBQ0EsSUFBSS9DLEVBQUVnQyxnQkFBZ0IsRUFBRTtvQkFDdEIsSUFBSWhDLGFBQWFrQixjQUFjO3dCQUM3QixPQUFPbEIsRUFBRW9CLEtBQUs7b0JBQ2hCO29CQUNBLE1BQU1wQjtnQkFDUjtnQkFDQSxJQUFJQSxhQUFha0IsZ0JBQWdCLENBQUMwQixRQUFRRSxjQUFjLENBQUM5QyxFQUFFb0IsS0FBSyxDQUFDbkIsS0FBSyxFQUFFL0QsTUFBTTtvQkFDNUVvRixTQUFTeUI7b0JBQ1RFLGNBQWMvRTtvQkFDZG1FO2dCQUNGLElBQUk7b0JBQ0YsT0FBT3JDLEVBQUVvQixLQUFLO2dCQUNoQjtnQkFDQSxNQUFNd0IsUUFBUUMsT0FBTyxDQUFDRSxRQUFRSCxRQUFRckIsVUFBVTtZQUNsRDtRQUNGO0lBQ0Y7QUFDQSxJQUFJMkIsUUFBUSxhQUFhLEdBQUd4SCxPQUFPcUcsTUFBTSxDQUFDRyxrQkFBa0I7SUFDMURKO0FBQ0Y7QUFFQSxtQ0FBbUM7QUFDbkMsSUFBSXFCLFVBQVUsYUFBYSxHQUFHbEosOERBQVlBLENBQUM7QUFDM0MsSUFBSW1KLGNBQWMsYUFBYSxHQUFHbkosOERBQVlBLENBQUM7QUFDL0MsSUFBSW9KLFdBQVcsYUFBYSxHQUFHcEosOERBQVlBLENBQUM7QUFDNUMsSUFBSXFKLFlBQVksYUFBYSxHQUFHckosOERBQVlBLENBQUM7QUFDN0MsSUFBSXNKLGNBQWM7QUFDbEIsU0FBU0MsZUFBZUMsUUFBUSxFQUFFQyxhQUFhO0lBQzdDLFNBQVNDO1FBQ1AsTUFBTUMsY0FBYyxJQUFNSCxTQUFTTjtRQUNuQyxNQUFNVSxrQkFBa0IsSUFBTUosU0FBU0w7UUFDdkMsTUFBTVUsZUFBZSxJQUFNTCxTQUFTSjtRQUNwQyxNQUFNVSxnQkFBZ0IsSUFBTU4sU0FBU0g7UUFDckMsTUFBTVUseUJBQXlCO1lBQzdCLElBQUlDLE9BQU9sSyxRQUFRLENBQUNDLGVBQWUsS0FBSyxXQUFXO2dCQUNqRDRKO1lBQ0YsT0FBTztnQkFDTEM7WUFDRjtRQUNGO1FBQ0EsSUFBSSxDQUFDTixhQUFhO1lBQ2hCLElBQUksS0FBd0QsRUFBRSxFQU03RDtRQUNIO1FBQ0EsTUFBTVksY0FBYztZQUNsQkYsT0FBT0csbUJBQW1CLENBQUMsU0FBU1I7WUFDcENLLE9BQU9HLG1CQUFtQixDQUFDLG9CQUFvQko7WUFDL0NDLE9BQU9HLG1CQUFtQixDQUFDLFVBQVVOO1lBQ3JDRyxPQUFPRyxtQkFBbUIsQ0FBQyxXQUFXTDtZQUN0Q1IsY0FBYztRQUNoQjtRQUNBLE9BQU9ZO0lBQ1Q7SUFDQSxPQUFPVCxnQkFBZ0JBLGNBQWNELFVBQVU7UUFDN0NOO1FBQ0FDO1FBQ0FFO1FBQ0FEO0lBQ0YsS0FBS007QUFDUDtBQUVBLG1DQUFtQztBQUNuQyxTQUFTVSxrQkFBa0JyRSxDQUFDO0lBQzFCLE9BQU9BLEVBQUV4QixJQUFJLEtBQUssUUFBUSxTQUFTO0FBQ3JDO0FBQ0EsU0FBUzhGLHFCQUFxQnRFLENBQUM7SUFDN0IsT0FBT0EsRUFBRXhCLElBQUksS0FBSyxXQUFXLFlBQVk7QUFDM0M7QUFDQSxTQUFTK0Ysb0JBQW9CQyxXQUFXLEVBQUV4QixNQUFNLEVBQUUvQyxLQUFLLEVBQUV3RSxRQUFRLEVBQUVoRyxJQUFJLEVBQUVpRyxjQUFjO0lBQ3JGLElBQUlDLFdBQVdILGNBQWM7UUFDM0IsT0FBT0EsWUFBWXhCLFFBQVEvQyxPQUFPd0UsVUFBVWhHLE1BQU1tRyxHQUFHLENBQUNDLHNCQUFzQkQsR0FBRyxDQUFDRjtJQUNsRjtJQUNBLElBQUluSixNQUFNQyxPQUFPLENBQUNnSixjQUFjO1FBQzlCLE9BQU9BLFlBQVlJLEdBQUcsQ0FBQ0Msc0JBQXNCRCxHQUFHLENBQUNGO0lBQ25EO0lBQ0EsT0FBTyxFQUFFO0FBQ1g7QUFDQSxTQUFTQyxXQUFXRyxDQUFDO0lBQ25CLE9BQU8sT0FBT0EsTUFBTTtBQUN0QjtBQUNBLFNBQVNELHFCQUFxQkwsV0FBVztJQUN2QyxPQUFPLE9BQU9BLGdCQUFnQixXQUFXO1FBQ3ZDaEcsTUFBTWdHO0lBQ1IsSUFBSUE7QUFDTjtBQUVBLGtDQUFrQztBQUNtRDtBQUVyRixrQ0FBa0M7QUFDbEMsU0FBU1MsYUFBYXBJLENBQUM7SUFDckIsT0FBT0EsS0FBSztBQUNkO0FBRUEscUNBQXFDO0FBQ3JDLFNBQVNxSSxnQkFBZ0J4SSxHQUFHO0lBQzFCLElBQUl5SSxRQUFRO0lBQ1osSUFBSyxNQUFNQyxRQUFRMUksSUFBSztRQUN0QnlJO0lBQ0Y7SUFDQSxPQUFPQTtBQUNUO0FBRUEsbUJBQW1CO0FBQ25CLFNBQVNFLGNBQWNDLE9BQU8sRUFBRUMsUUFBUTtJQUN0QyxPQUFPRCxRQUFRRSxLQUFLLENBQUNEO0FBQ3ZCO0FBRUEsa0NBQWtDO0FBQ2xDLElBQUlFLHFCQUFxQkMsT0FBTztBQUNoQyxJQUFJQyxnQkFBZ0IsQ0FBQzFILE1BQVEsT0FBT0EsR0FBRyxDQUFDd0gsbUJBQW1CLEtBQUs7QUFDaEUsU0FBU0csY0FBYyxFQUNyQkMsa0JBQWtCLEVBQ2xCQyxVQUFVLEVBQ1ZDLGFBQWEsRUFDYjdILEdBQUcsRUFDSDhILE9BQU8sRUFDUjtJQUNDLE1BQU1DLGlCQUFpQixhQUFhLEdBQUcsSUFBSUM7SUFDM0MsTUFBTUMsbUJBQW1CLGFBQWEsR0FBRyxJQUFJRDtJQUM3QyxNQUFNLEVBQ0pFLHNCQUFzQixFQUN0QkMsb0JBQW9CLEVBQ3BCQyx5QkFBeUIsRUFDMUIsR0FBR3BJLElBQUlxSSxlQUFlO0lBQ3ZCLE9BQU87UUFDTEM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7SUFDRjtJQUNBLFNBQVNILHFCQUFxQkksWUFBWSxFQUFFQyxTQUFTO1FBQ25ELE9BQU8sQ0FBQ3REO1lBQ04sTUFBTXVELHFCQUFxQmhCLFFBQVFpQixtQkFBbUIsQ0FBQ0gsYUFBYTtZQUNwRSxNQUFNSSxnQkFBZ0JyQixtQkFBbUI7Z0JBQ3ZDa0I7Z0JBQ0FDO2dCQUNBRjtZQUNGO1lBQ0EsT0FBT2IsZUFBZXpKLEdBQUcsQ0FBQ2lILFdBQVcsQ0FBQ3lELGNBQWM7UUFDdEQ7SUFDRjtJQUNBLFNBQVNQLHdCQUF3QlEsYUFBYSxFQUFFQyx3QkFBd0I7UUFDdEUsT0FBTyxDQUFDM0Q7WUFDTixPQUFPMEMsaUJBQWlCM0osR0FBRyxDQUFDaUgsV0FBVyxDQUFDMkQseUJBQXlCO1FBQ25FO0lBQ0Y7SUFDQSxTQUFTUjtRQUNQLE9BQU8sQ0FBQ25ELFdBQWEvSCxPQUFPMkwsTUFBTSxDQUFDcEIsZUFBZXpKLEdBQUcsQ0FBQ2lILGFBQWEsQ0FBQyxHQUFHbEIsTUFBTSxDQUFDMEM7SUFDaEY7SUFDQSxTQUFTNEI7UUFDUCxPQUFPLENBQUNwRCxXQUFhL0gsT0FBTzJMLE1BQU0sQ0FBQ2xCLGlCQUFpQjNKLEdBQUcsQ0FBQ2lILGFBQWEsQ0FBQyxHQUFHbEIsTUFBTSxDQUFDMEM7SUFDbEY7SUFDQSxTQUFTcUMsa0JBQWtCN0QsUUFBUTtRQUNqQyxJQUFJOEQsSUFBcUMsRUFBRTtZQUN6QyxJQUFJRCxrQkFBa0JFLFNBQVMsRUFDN0I7WUFDRixNQUFNQyxnQkFBZ0JoRSxTQUFTdkYsSUFBSXFJLGVBQWUsQ0FBQ21CLDZCQUE2QjtZQUNoRkosa0JBQWtCRSxTQUFTLEdBQUc7WUFDOUIsSUFBSSxPQUFPQyxrQkFBa0IsWUFBWSxPQUFPQSxlQUFlakosU0FBUyxVQUFVO2dCQUNoRixNQUFNLElBQUltSixNQUFNSixNQUFxQyxHQUFHdkMsQ0FBMkIsR0FBRyxDQUFDLHNEQUFzRCxFQUFFOUcsSUFBSTBKLFdBQVcsQ0FBQztnRUFDdkcsQ0FBQztZQUMzRDtRQUNGO0lBQ0Y7SUFDQSxTQUFTcEIsbUJBQW1CTSxZQUFZLEVBQUVFLGtCQUFrQjtRQUMxRCxNQUFNYSxjQUFjLENBQUM1SixLQUFLLEVBQ3hCNkosWUFBWSxJQUFJLEVBQ2hCQyxZQUFZLEVBQ1pDLG1CQUFtQixFQUNuQixDQUFDdkMsbUJBQW1CLEVBQUV3QyxZQUFZLEVBQ25DLEdBQUcsQ0FBQyxDQUFDLEdBQUssQ0FBQ3hFLFVBQVVyRjtnQkFDcEIsTUFBTThJLGdCQUFnQnJCLG1CQUFtQjtvQkFDdkNrQixXQUFXOUk7b0JBQ1grSTtvQkFDQUY7Z0JBQ0Y7Z0JBQ0EsTUFBTW9CLFFBQVFwQyxXQUFXO29CQUN2QnRILE1BQU07b0JBQ05zSjtvQkFDQUM7b0JBQ0FDO29CQUNBbEI7b0JBQ0FxQixjQUFjbEs7b0JBQ2RpSjtvQkFDQSxDQUFDekIsbUJBQW1CLEVBQUV3QztnQkFDeEI7Z0JBQ0EsTUFBTUcsV0FBV2xLLElBQUltSyxTQUFTLENBQUN2QixhQUFhLENBQUN3QixNQUFNLENBQUNySztnQkFDcEQsTUFBTXNLLGNBQWM5RSxTQUFTeUU7Z0JBQzdCLE1BQU1NLGFBQWFKLFNBQVNoSztnQkFDNUJrSixrQkFBa0I3RDtnQkFDbEIsTUFBTSxFQUNKZ0YsU0FBUyxFQUNUMUksS0FBSyxFQUNOLEdBQUd3STtnQkFDSixNQUFNRyx1QkFBdUJGLFdBQVdDLFNBQVMsS0FBS0E7Z0JBQ3RELE1BQU1FLGVBQWUxQyxlQUFlekosR0FBRyxDQUFDaUgsV0FBVyxDQUFDeUQsY0FBYztnQkFDbEUsTUFBTTBCLGtCQUFrQixJQUFNUixTQUFTaEs7Z0JBQ3ZDLE1BQU15SyxlQUFlbk4sT0FBT3FHLE1BQU0sQ0FBQ2tHLGVBQ2pDLDRDQUE0QztnQkFDNUMseUZBQXlGO2dCQUN6Rk0sWUFBWTNILElBQUksQ0FBQ2dJLG1CQUNmRix3QkFBd0IsQ0FBQ0MsZUFDM0IsNkZBQTZGO2dCQUM3Riw2REFBNkQ7Z0JBQzdEbEksUUFBUW1CLE9BQU8sQ0FBQzRHLGNBRWhCLGlEQUFpRDtnQkFDakQsd0VBQXdFO2dCQUN4RS9ILFFBQVFDLEdBQUcsQ0FBQztvQkFBQ2lJO29CQUFjSjtpQkFBWSxFQUFFM0gsSUFBSSxDQUFDZ0ksa0JBQzdDO29CQUNEM0s7b0JBQ0F3SztvQkFDQVQ7b0JBQ0FkO29CQUNBbkg7b0JBQ0EsTUFBTStJO3dCQUNKLE1BQU05RixTQUFTLE1BQU02Rjt3QkFDckIsSUFBSTdGLE9BQU9ySyxPQUFPLEVBQUU7NEJBQ2xCLE1BQU1xSyxPQUFPL0MsS0FBSzt3QkFDcEI7d0JBQ0EsT0FBTytDLE9BQU9oQyxJQUFJO29CQUNwQjtvQkFDQStILFNBQVMsSUFBTXRGLFNBQVNvRSxZQUFZNUosS0FBSzs0QkFDdkM2SixXQUFXOzRCQUNYQyxjQUFjO3dCQUNoQjtvQkFDQTVEO3dCQUNFLElBQUkyRCxXQUNGckUsU0FBUzJDLHVCQUF1Qjs0QkFDOUJjOzRCQUNBdUI7d0JBQ0Y7b0JBQ0o7b0JBQ0FuQywyQkFBMEIxRCxPQUFPO3dCQUMvQmlHLGFBQWFiLG1CQUFtQixHQUFHcEY7d0JBQ25DYSxTQUFTNkMsMEJBQTBCOzRCQUNqQ1E7NEJBQ0EyQjs0QkFDQXZCOzRCQUNBdEU7d0JBQ0Y7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0EsSUFBSSxDQUFDK0YsZ0JBQWdCLENBQUNELHdCQUF3QixDQUFDVCxjQUFjO29CQUMzRCxNQUFNZSxVQUFVL0MsZUFBZXpKLEdBQUcsQ0FBQ2lILGFBQWEsQ0FBQztvQkFDakR1RixPQUFPLENBQUM5QixjQUFjLEdBQUcyQjtvQkFDekI1QyxlQUFlL0csR0FBRyxDQUFDdUUsVUFBVXVGO29CQUM3QkgsYUFBYWpJLElBQUksQ0FBQzt3QkFDaEIsT0FBT29JLE9BQU8sQ0FBQzlCLGNBQWM7d0JBQzdCLElBQUksQ0FBQ2hDLGdCQUFnQjhELFVBQVU7NEJBQzdCL0MsZUFBZWdELE1BQU0sQ0FBQ3hGO3dCQUN4QjtvQkFDRjtnQkFDRjtnQkFDQSxPQUFPb0Y7WUFDVDtRQUNBLE9BQU9oQjtJQUNUO0lBQ0EsU0FBU3BCLHNCQUFzQkssWUFBWTtRQUN6QyxPQUFPLENBQUM3SSxLQUFLLEVBQ1hpTCxRQUFRLElBQUksRUFDWkMsYUFBYSxFQUNkLEdBQUcsQ0FBQyxDQUFDLEdBQUssQ0FBQzFGLFVBQVVyRjtnQkFDcEIsTUFBTThKLFFBQVFuQyxjQUFjO29CQUMxQnZILE1BQU07b0JBQ05zSTtvQkFDQXFCLGNBQWNsSztvQkFDZGlMO29CQUNBQztnQkFDRjtnQkFDQSxNQUFNWixjQUFjOUUsU0FBU3lFO2dCQUM3Qlosa0JBQWtCN0Q7Z0JBQ2xCLE1BQU0sRUFDSmdGLFNBQVMsRUFDVDFJLEtBQUssRUFDTCtJLE1BQU0sRUFDUCxHQUFHUDtnQkFDSixNQUFNYSxxQkFBcUIvRCxjQUFja0QsWUFBWU8sTUFBTSxHQUFHbEksSUFBSSxDQUFDLENBQUNJLE9BQVU7d0JBQzVFQTtvQkFDRixLQUFLLENBQUNmLFFBQVc7d0JBQ2ZBO29CQUNGO2dCQUNBLE1BQU1vSixRQUFRO29CQUNaNUYsU0FBUzRDLHFCQUFxQjt3QkFDNUJvQzt3QkFDQVU7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0EsTUFBTUcsTUFBTTVOLE9BQU9xRyxNQUFNLENBQUNxSCxvQkFBb0I7b0JBQzVDbkwsS0FBS3NLLFlBQVl0SyxHQUFHO29CQUNwQndLO29CQUNBMUk7b0JBQ0ErSTtvQkFDQU87Z0JBQ0Y7Z0JBQ0EsTUFBTUwsVUFBVTdDLGlCQUFpQjNKLEdBQUcsQ0FBQ2lILGFBQWEsQ0FBQztnQkFDbkQwQyxpQkFBaUJqSCxHQUFHLENBQUN1RSxVQUFVdUY7Z0JBQy9CQSxPQUFPLENBQUNQLFVBQVUsR0FBR2E7Z0JBQ3JCQSxJQUFJMUksSUFBSSxDQUFDO29CQUNQLE9BQU9vSSxPQUFPLENBQUNQLFVBQVU7b0JBQ3pCLElBQUksQ0FBQ3ZELGdCQUFnQjhELFVBQVU7d0JBQzdCN0MsaUJBQWlCOEMsTUFBTSxDQUFDeEY7b0JBQzFCO2dCQUNGO2dCQUNBLElBQUkwRixlQUFlO29CQUNqQkgsT0FBTyxDQUFDRyxjQUFjLEdBQUdHO29CQUN6QkEsSUFBSTFJLElBQUksQ0FBQzt3QkFDUCxJQUFJb0ksT0FBTyxDQUFDRyxjQUFjLEtBQUtHLEtBQUs7NEJBQ2xDLE9BQU9OLE9BQU8sQ0FBQ0csY0FBYzs0QkFDN0IsSUFBSSxDQUFDakUsZ0JBQWdCOEQsVUFBVTtnQ0FDN0I3QyxpQkFBaUI4QyxNQUFNLENBQUN4Rjs0QkFDMUI7d0JBQ0Y7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0EsT0FBTzZGO1lBQ1Q7SUFDRjtBQUNGO0FBRUEsZ0NBQWdDO0FBQ3dCO0FBQ3hELFNBQVNHLHlCQUF5QkMsb0JBQW9CO0lBQ3BELE9BQU9BO0FBQ1Q7QUFDQSxTQUFTQyxZQUFZLEVBQ25CL0IsV0FBVyxFQUNYekYsU0FBUyxFQUNUNkQsU0FBUyxFQUNQaUIsbUJBQW1CLEVBQ3BCLEVBQ0RwQixrQkFBa0IsRUFDbEIzSCxHQUFHLEVBQ0gwTCxhQUFhLEVBQ2Q7SUFDQyxNQUFNQyxpQkFBaUIsQ0FBQy9DLGNBQWM1SyxNQUFNNE4sU0FBU0MsaUJBQW1CLENBQUN0RyxVQUFVckY7WUFDakYsTUFBTTRJLHFCQUFxQkMsbUJBQW1CLENBQUNILGFBQWE7WUFDNUQsTUFBTUksZ0JBQWdCckIsbUJBQW1CO2dCQUN2Q2tCLFdBQVc3SztnQkFDWDhLO2dCQUNBRjtZQUNGO1lBQ0FyRCxTQUFTdkYsSUFBSXFJLGVBQWUsQ0FBQ3lELGtCQUFrQixDQUFDO2dCQUM5QzlDO2dCQUNBNEM7WUFDRjtZQUNBLElBQUksQ0FBQ0MsZ0JBQWdCO2dCQUNuQjtZQUNGO1lBQ0EsTUFBTUUsV0FBVy9MLElBQUltSyxTQUFTLENBQUN2QixhQUFhLENBQUN3QixNQUFNLENBQUNwTSxNQUNsRCw4QkFBOEI7WUFDOUJrQztZQUVGLE1BQU04TCxlQUFlM0Ysb0JBQW9CeUMsbUJBQW1CbUQsWUFBWSxFQUFFRixTQUFTakosSUFBSSxFQUFFLEtBQUssR0FBRzlFLE1BQU0sQ0FBQyxHQUFHME47WUFDM0duRyxTQUFTdkYsSUFBSXFJLGVBQWUsQ0FBQzZELGdCQUFnQixDQUFDO2dCQUM1Q2xEO2dCQUNBZ0Q7WUFDRjtRQUNGO0lBQ0EsTUFBTUcsa0JBQWtCLENBQUN2RCxjQUFjNUssTUFBTW9PLGNBQWNQLGlCQUFpQixJQUFJLEdBQUssQ0FBQ3RHLFVBQVVyRjtZQUM5RixNQUFNNEkscUJBQXFCOUksSUFBSW1LLFNBQVMsQ0FBQ3ZCLGFBQWE7WUFDdEQsTUFBTXlELGVBQWV2RCxtQkFBbUJzQixNQUFNLENBQUNwTSxNQUM3Qyw4QkFBOEI7WUFDOUJrQztZQUVGLElBQUlrTCxNQUFNO2dCQUNSUSxTQUFTLEVBQUU7Z0JBQ1hVLGdCQUFnQixFQUFFO2dCQUNsQkMsTUFBTSxJQUFNaEgsU0FBU3ZGLElBQUl3TSxJQUFJLENBQUNiLGNBQWMsQ0FBQy9DLGNBQWM1SyxNQUFNb04sSUFBSWtCLGNBQWMsRUFBRVQ7WUFDdkY7WUFDQSxJQUFJUSxhQUFhaFMsTUFBTSxLQUFLLGdCQUFnQixpQkFBaUIsS0FBSTtnQkFDL0QsT0FBTytRO1lBQ1Q7WUFDQSxJQUFJVztZQUNKLElBQUksVUFBVU0sY0FBYztnQkFDMUIsSUFBSWhCLGtEQUFXQSxDQUFDZ0IsYUFBYXZKLElBQUksR0FBRztvQkFDbEMsTUFBTSxDQUFDSSxPQUFPMEksU0FBU1UsZUFBZSxHQUFHaEIseURBQWtCQSxDQUFDZSxhQUFhdkosSUFBSSxFQUFFc0o7b0JBQy9FaEIsSUFBSVEsT0FBTyxDQUFDYSxJQUFJLElBQUliO29CQUNwQlIsSUFBSWtCLGNBQWMsQ0FBQ0csSUFBSSxJQUFJSDtvQkFDM0JQLFdBQVc3STtnQkFDYixPQUFPO29CQUNMNkksV0FBV0ssYUFBYUMsYUFBYXZKLElBQUk7b0JBQ3pDc0ksSUFBSVEsT0FBTyxDQUFDYSxJQUFJLENBQUM7d0JBQ2ZDLElBQUk7d0JBQ0pDLE1BQU0sRUFBRTt3QkFDUnpKLE9BQU82STtvQkFDVDtvQkFDQVgsSUFBSWtCLGNBQWMsQ0FBQ0csSUFBSSxDQUFDO3dCQUN0QkMsSUFBSTt3QkFDSkMsTUFBTSxFQUFFO3dCQUNSekosT0FBT21KLGFBQWF2SixJQUFJO29CQUMxQjtnQkFDRjtZQUNGO1lBQ0F5QyxTQUFTdkYsSUFBSXdNLElBQUksQ0FBQ2IsY0FBYyxDQUFDL0MsY0FBYzVLLE1BQU1vTixJQUFJUSxPQUFPLEVBQUVDO1lBQ2xFLE9BQU9UO1FBQ1Q7SUFDQSxNQUFNd0Isa0JBQWtCLENBQUNoRSxjQUFjNUssTUFBTWtGLFFBQVUsQ0FBQ3FDO1lBQ3RELE9BQU9BLFNBQVN2RixJQUFJbUssU0FBUyxDQUFDdkIsYUFBYSxDQUFDaUUsUUFBUSxDQUFDN08sTUFBTTtnQkFDekQ0TCxXQUFXO2dCQUNYQyxjQUFjO2dCQUNkLENBQUN0QyxtQkFBbUIsRUFBRSxJQUFPO3dCQUMzQnpFLE1BQU1JO29CQUNSO1lBQ0Y7UUFDRjtJQUNBLE1BQU00SixrQkFBa0IsT0FBTy9NLEtBQUssRUFDbENFLE1BQU0sRUFDTjRCLEtBQUssRUFDTGtMLGVBQWUsRUFDZkMsZ0JBQWdCLEVBQ2hCekgsUUFBUSxFQUNSckYsUUFBUSxFQUNSQyxLQUFLLEVBQ047UUFDQyxNQUFNMkkscUJBQXFCQyxtQkFBbUIsQ0FBQ2hKLElBQUk2SSxZQUFZLENBQUM7UUFDaEUsSUFBSTtZQUNGLElBQUlxRSxvQkFBb0IxQjtZQUN4QixJQUFJekc7WUFDSixNQUFNQyxlQUFlO2dCQUNuQjlFO2dCQUNBNEI7Z0JBQ0EwRDtnQkFDQXJGO2dCQUNBQztnQkFDQUMsVUFBVUwsSUFBSTZJLFlBQVk7Z0JBQzFCdEksTUFBTVAsSUFBSU8sSUFBSTtnQkFDZEQsUUFBUU4sSUFBSU8sSUFBSSxLQUFLLFVBQVU0TSxjQUFjbk4sS0FBS0csY0FBYyxLQUFLO1lBQ3ZFO1lBQ0EsTUFBTTZKLGVBQWVoSyxJQUFJTyxJQUFJLEtBQUssVUFBVVAsR0FBRyxDQUFDd0gsbUJBQW1CLEdBQUcsS0FBSztZQUMzRSxJQUFJd0MsY0FBYztnQkFDaEJqRixTQUFTaUY7WUFDWCxPQUFPLElBQUlqQixtQkFBbUJ6SCxLQUFLLEVBQUU7Z0JBQ25DeUQsU0FBUyxNQUFNYixVQUFVNkUsbUJBQW1CekgsS0FBSyxDQUFDdEIsSUFBSWtLLFlBQVksR0FBR2xGLGNBQWMrRCxtQkFBbUIzRSxZQUFZO2dCQUNsSCxJQUFJMkUsbUJBQW1CbUUsaUJBQWlCLEVBQUU7b0JBQ3hDQSxvQkFBb0JuRSxtQkFBbUJtRSxpQkFBaUI7Z0JBQzFEO1lBQ0YsT0FBTztnQkFDTG5JLFNBQVMsTUFBTWdFLG1CQUFtQnFFLE9BQU8sQ0FBQ3BOLElBQUlrSyxZQUFZLEVBQUVsRixjQUFjK0QsbUJBQW1CM0UsWUFBWSxFQUFFLENBQUNpSixPQUFTbkosVUFBVW1KLE1BQU1ySSxjQUFjK0QsbUJBQW1CM0UsWUFBWTtZQUNwTDtZQUNBLElBQUksT0FBT2tGLFlBQVksZUFBZUEsa0JBQXlCLGVBQWU7Z0JBQzVFLE1BQU1nRSxPQUFPdkUsbUJBQW1CekgsS0FBSyxHQUFHLGdCQUFnQjtnQkFDeEQsSUFBSWlNO2dCQUNKLElBQUksQ0FBQ3hJLFFBQVE7b0JBQ1h3SSxNQUFNLENBQUMsRUFBRUQsS0FBSyx5QkFBeUIsQ0FBQztnQkFDMUMsT0FBTyxJQUFJLE9BQU92SSxXQUFXLFVBQVU7b0JBQ3JDd0ksTUFBTSxDQUFDLEVBQUVELEtBQUssMEJBQTBCLENBQUM7Z0JBQzNDLE9BQU8sSUFBSXZJLE9BQU8vQyxLQUFLLElBQUkrQyxPQUFPaEMsSUFBSSxFQUFFO29CQUN0Q3dLLE1BQU0sQ0FBQyxFQUFFRCxLQUFLLDZEQUE2RCxDQUFDO2dCQUM5RSxPQUFPLElBQUl2SSxPQUFPL0MsS0FBSyxLQUFLLEtBQUssS0FBSytDLE9BQU9oQyxJQUFJLEtBQUssS0FBSyxHQUFHO29CQUM1RHdLLE1BQU0sQ0FBQyxFQUFFRCxLQUFLLHlIQUF5SCxDQUFDO2dCQUMxSSxPQUFPO29CQUNMLEtBQUssTUFBTXZQLE9BQU9OLE9BQU9DLElBQUksQ0FBQ3FILFFBQVM7d0JBQ3JDLElBQUloSCxRQUFRLFdBQVdBLFFBQVEsVUFBVUEsUUFBUSxRQUFROzRCQUN2RHdQLE1BQU0sQ0FBQyx1QkFBdUIsRUFBRUQsS0FBSywwQkFBMEIsRUFBRXZQLElBQUksQ0FBQyxDQUFDOzRCQUN2RTt3QkFDRjtvQkFDRjtnQkFDRjtnQkFDQSxJQUFJd1AsS0FBSztvQkFDUHpOLFFBQVFrQyxLQUFLLENBQUMsQ0FBQyx3Q0FBd0MsRUFBRWhDLElBQUk2SSxZQUFZLENBQUM7Y0FDdEUsRUFBRTBFLElBQUk7O2tDQUVjLENBQUMsRUFBRXhJO2dCQUM3QjtZQUNGO1lBQ0EsSUFBSUEsT0FBTy9DLEtBQUssRUFDZCxNQUFNLElBQUlpQixhQUFhOEIsT0FBTy9DLEtBQUssRUFBRStDLE9BQU92RSxJQUFJO1lBQ2xELE9BQU95TSxpQkFBaUIsTUFBTUMsa0JBQWtCbkksT0FBT2hDLElBQUksRUFBRWdDLE9BQU92RSxJQUFJLEVBQUVSLElBQUlrSyxZQUFZLEdBQUc7Z0JBQzNGc0Qsb0JBQW9CQyxLQUFLQyxHQUFHO2dCQUM1QkMsZUFBZTVJLE9BQU92RSxJQUFJO2dCQUMxQixDQUFDekQsOERBQWdCQSxDQUFDLEVBQUU7WUFDdEI7UUFDRixFQUFFLE9BQU9pRixPQUFPO1lBQ2QsSUFBSTRMLGVBQWU1TDtZQUNuQixJQUFJNEwsd0JBQXdCM0ssY0FBYztnQkFDeEMsSUFBSTRLLHlCQUF5QnJDO2dCQUM3QixJQUFJekMsbUJBQW1CekgsS0FBSyxJQUFJeUgsbUJBQW1COEUsc0JBQXNCLEVBQUU7b0JBQ3pFQSx5QkFBeUI5RSxtQkFBbUI4RSxzQkFBc0I7Z0JBQ3BFO2dCQUNBLElBQUk7b0JBQ0YsT0FBT2IsZ0JBQWdCLE1BQU1hLHVCQUF1QkQsYUFBYXpLLEtBQUssRUFBRXlLLGFBQWFwTixJQUFJLEVBQUVSLElBQUlrSyxZQUFZLEdBQUc7d0JBQzVHeUQsZUFBZUMsYUFBYXBOLElBQUk7d0JBQ2hDLENBQUN6RCw4REFBZ0JBLENBQUMsRUFBRTtvQkFDdEI7Z0JBQ0YsRUFBRSxPQUFPZ0YsR0FBRztvQkFDVjZMLGVBQWU3TDtnQkFDakI7WUFDRjtZQUNBLElBQUksT0FBT3VILFlBQVksZUFBZUEsa0JBQXlCLGNBQWM7Z0JBQzNFeEosUUFBUWtDLEtBQUssQ0FBQyxDQUFDLG1FQUFtRSxFQUFFaEMsSUFBSTZJLFlBQVksQ0FBQzsrRUFDOUIsQ0FBQyxFQUFFK0U7WUFDNUUsT0FBTztnQkFDTDlOLFFBQVFrQyxLQUFLLENBQUM0TDtZQUNoQjtZQUNBLE1BQU1BO1FBQ1I7SUFDRjtJQUNBLFNBQVNULGNBQWNuTixHQUFHLEVBQUU4TixLQUFLO1FBQy9CLE1BQU1DLGVBQWVELEtBQUssQ0FBQ25FLFlBQVksRUFBRXFFLFNBQVMsQ0FBQ2hPLElBQUlpSixhQUFhLENBQUM7UUFDckUsTUFBTWdGLDhCQUE4QkgsS0FBSyxDQUFDbkUsWUFBWSxFQUFFL0ksT0FBT3NOO1FBQy9ELE1BQU1DLGVBQWVKLGNBQWNQO1FBQ25DLE1BQU1ZLGFBQWFwTyxJQUFJOEosWUFBWSxJQUFLOUosQ0FBQUEsSUFBSTZKLFNBQVMsSUFBSW9FLDJCQUEwQjtRQUNuRixJQUFJRyxZQUFZO1lBQ2QsT0FBT0EsZUFBZSxRQUFRLENBQUNDLE9BQU8sYUFBYSxHQUFHLElBQUlaLFVBQVVZLE9BQU9GLGFBQVksSUFBSyxPQUFPQztRQUNyRztRQUNBLE9BQU87SUFDVDtJQUNBLE1BQU12RyxhQUFhMUwsa0VBQWdCQSxDQUFDLENBQUMsRUFBRXdOLFlBQVksYUFBYSxDQUFDLEVBQUVvRCxpQkFBaUI7UUFDbEZ1QjtZQUNFLE9BQU87Z0JBQ0xDLGtCQUFrQmQsS0FBS0MsR0FBRztnQkFDMUIsQ0FBQzNRLDhEQUFnQkEsQ0FBQyxFQUFFO1lBQ3RCO1FBQ0Y7UUFDQXlSLFdBQVVDLGNBQWMsRUFBRSxFQUN4QnRPLFFBQVEsRUFDVDtZQUNDLE1BQU0yTixRQUFRM047WUFDZCxNQUFNNE4sZUFBZUQsS0FBSyxDQUFDbkUsWUFBWSxFQUFFcUUsU0FBUyxDQUFDUyxlQUFleEYsYUFBYSxDQUFDO1lBQ2hGLE1BQU1rRixlQUFlSixjQUFjUDtZQUNuQyxNQUFNa0IsYUFBYUQsZUFBZXZFLFlBQVk7WUFDOUMsTUFBTXlFLGNBQWNaLGNBQWM3RDtZQUNsQyxNQUFNbkIscUJBQXFCQyxtQkFBbUIsQ0FBQ3lGLGVBQWU1RixZQUFZLENBQUM7WUFDM0UsSUFBSW5CLGNBQWMrRyxpQkFBaUI7Z0JBQ2pDLE9BQU87WUFDVDtZQUNBLElBQUlWLGNBQWN6VCxXQUFXLFdBQVc7Z0JBQ3RDLE9BQU87WUFDVDtZQUNBLElBQUk2UyxjQUFjc0IsZ0JBQWdCWCxRQUFRO2dCQUN4QyxPQUFPO1lBQ1Q7WUFDQSxJQUFJMUgsa0JBQWtCMkMsdUJBQXVCQSxvQkFBb0JlLGVBQWU7Z0JBQzlFNEU7Z0JBQ0FDO2dCQUNBQyxlQUFlYjtnQkFDZkQ7WUFDRixJQUFJO2dCQUNGLE9BQU87WUFDVDtZQUNBLElBQUlLLGNBQWM7Z0JBQ2hCLE9BQU87WUFDVDtZQUNBLE9BQU87UUFDVDtRQUNBVSw0QkFBNEI7SUFDOUI7SUFDQSxNQUFNL0csZ0JBQWdCM0wsa0VBQWdCQSxDQUFDLENBQUMsRUFBRXdOLFlBQVksZ0JBQWdCLENBQUMsRUFBRW9ELGlCQUFpQjtRQUN4RnVCO1lBQ0UsT0FBTztnQkFDTEMsa0JBQWtCZCxLQUFLQyxHQUFHO2dCQUMxQixDQUFDM1EsOERBQWdCQSxDQUFDLEVBQUU7WUFDdEI7UUFDRjtJQUNGO0lBQ0EsTUFBTStSLGNBQWMsQ0FBQ25LLFVBQVksV0FBV0E7SUFDNUMsTUFBTW9LLFlBQVksQ0FBQ3BLLFVBQVksaUJBQWlCQTtJQUNoRCxNQUFNcUssV0FBVyxDQUFDbkcsY0FBYzdJLEtBQUsyRSxVQUFZLENBQUNhLFVBQVVyRjtZQUMxRCxNQUFNOE8sUUFBUUgsWUFBWW5LLFlBQVlBLFFBQVFzSyxLQUFLO1lBQ25ELE1BQU1DLFNBQVNILFVBQVVwSyxZQUFZQSxRQUFRd0ssV0FBVztZQUN4RCxNQUFNdkYsY0FBYyxDQUFDd0YsU0FBUyxJQUFJLEdBQUtuUCxJQUFJbUssU0FBUyxDQUFDdkIsYUFBYSxDQUFDaUUsUUFBUSxDQUFDOU0sS0FBSztvQkFDL0U4SixjQUFjc0Y7Z0JBQ2hCO1lBQ0EsTUFBTUMsbUJBQW1CcFAsSUFBSW1LLFNBQVMsQ0FBQ3ZCLGFBQWEsQ0FBQ3dCLE1BQU0sQ0FBQ3JLLEtBQUtHO1lBQ2pFLElBQUk4TyxPQUFPO2dCQUNUekosU0FBU29FO1lBQ1gsT0FBTyxJQUFJc0YsUUFBUTtnQkFDakIsTUFBTUksa0JBQWtCRCxrQkFBa0I3QjtnQkFDMUMsSUFBSSxDQUFDOEIsaUJBQWlCO29CQUNwQjlKLFNBQVNvRTtvQkFDVDtnQkFDRjtnQkFDQSxNQUFNMkYsa0JBQWtCLENBQUNsQixPQUFPLGFBQWEsR0FBRyxJQUFJWixVQUFVWSxPQUFPLElBQUlaLEtBQUs2QixpQkFBZ0IsSUFBSyxPQUFPSjtnQkFDMUcsSUFBSUssaUJBQWlCO29CQUNuQi9KLFNBQVNvRTtnQkFDWDtZQUNGLE9BQU87Z0JBQ0xwRSxTQUFTb0UsWUFBWTtZQUN2QjtRQUNGO0lBQ0EsU0FBUzRGLGdCQUFnQjNHLFlBQVk7UUFDbkMsT0FBTyxDQUFDNEcsU0FBV0EsUUFBUWpQLE1BQU1SLEtBQUs2SSxpQkFBaUJBO0lBQ3pEO0lBQ0EsU0FBUzZHLHVCQUF1QnpGLEtBQUssRUFBRXBCLFlBQVk7UUFDakQsT0FBTztZQUNMOEcsY0FBY3BULHlEQUFPQSxDQUFDRSwyREFBU0EsQ0FBQ3dOLFFBQVF1RixnQkFBZ0IzRztZQUN4RCtHLGdCQUFnQnJULHlEQUFPQSxDQUFDSSw2REFBV0EsQ0FBQ3NOLFFBQVF1RixnQkFBZ0IzRztZQUM1RGdILGVBQWV0VCx5REFBT0EsQ0FBQ0csNERBQVVBLENBQUN1TixRQUFRdUYsZ0JBQWdCM0c7UUFDNUQ7SUFDRjtJQUNBLE9BQU87UUFDTGhCO1FBQ0FDO1FBQ0FrSDtRQUNBNUM7UUFDQVM7UUFDQWpCO1FBQ0E4RDtJQUNGO0FBQ0Y7QUFDQSxTQUFTSSx5QkFBeUJMLE1BQU0sRUFBRWxQLElBQUksRUFBRXlJLG1CQUFtQixFQUFFMkMsYUFBYTtJQUNoRixPQUFPckYsb0JBQW9CMEMsbUJBQW1CLENBQUN5RyxPQUFPalAsSUFBSSxDQUFDUixHQUFHLENBQUM2SSxZQUFZLENBQUMsQ0FBQ3RJLEtBQUssRUFBRTVELDZEQUFXQSxDQUFDOFMsVUFBVUEsT0FBT00sT0FBTyxHQUFHLEtBQUssR0FBR25ULHFFQUFtQkEsQ0FBQzZTLFVBQVVBLE9BQU9NLE9BQU8sR0FBRyxLQUFLLEdBQUdOLE9BQU9qUCxJQUFJLENBQUNSLEdBQUcsQ0FBQ2tLLFlBQVksRUFBRSxtQkFBbUJ1RixPQUFPalAsSUFBSSxHQUFHaVAsT0FBT2pQLElBQUksQ0FBQ21OLGFBQWEsR0FBRyxLQUFLLEdBQUdoQztBQUMvUjtBQUVBLCtCQUErQjtBQUNDO0FBQ2U7QUFDL0MsU0FBU3dFLDRCQUE0QnJDLEtBQUssRUFBRTdFLGFBQWEsRUFBRW1ILE1BQU07SUFDL0QsTUFBTUMsV0FBV3ZDLEtBQUssQ0FBQzdFLGNBQWM7SUFDckMsSUFBSW9ILFVBQVU7UUFDWkQsT0FBT0M7SUFDVDtBQUNGO0FBQ0EsU0FBU0Msb0JBQW9CQyxFQUFFO0lBQzdCLE9BQU8sQ0FBQyxTQUFTQSxLQUFLQSxHQUFHdlEsR0FBRyxDQUFDa0wsYUFBYSxHQUFHcUYsR0FBR3JGLGFBQWEsS0FBS3FGLEdBQUcvRixTQUFTO0FBQ2hGO0FBQ0EsU0FBU2dHLCtCQUErQjFDLEtBQUssRUFBRXlDLEVBQUUsRUFBRUgsTUFBTTtJQUN2RCxNQUFNQyxXQUFXdkMsS0FBSyxDQUFDd0Msb0JBQW9CQyxJQUFJO0lBQy9DLElBQUlGLFVBQVU7UUFDWkQsT0FBT0M7SUFDVDtBQUNGO0FBQ0EsSUFBSUksZUFBZSxDQUFDO0FBQ3BCLFNBQVNDLFdBQVcsRUFDbEIvRyxXQUFXLEVBQ1g5QixVQUFVLEVBQ1ZDLGFBQWEsRUFDYkMsU0FBUyxFQUNQaUIscUJBQXFCMkgsV0FBVyxFQUNoQ0MsTUFBTSxFQUNOQyxzQkFBc0IsRUFDdEJDLGtCQUFrQixFQUNuQixFQUNEbkYsYUFBYSxFQUNiL0ssTUFBTSxFQUNQO0lBQ0MsTUFBTW1RLGdCQUFnQi9VLDhEQUFZQSxDQUFDLENBQUMsRUFBRTJOLFlBQVksY0FBYyxDQUFDO0lBQ2pFLE1BQU1xSCxhQUFhL1UsNkRBQVdBLENBQUM7UUFDN0JnVixNQUFNLENBQUMsRUFBRXRILFlBQVksUUFBUSxDQUFDO1FBQzlCOEc7UUFDQVMsVUFBVTtZQUNSQyxtQkFBbUI7Z0JBQ2pCQyxTQUFRQyxLQUFLLEVBQUUsRUFDYnRCLFNBQVMsRUFDUDlHLGFBQWEsRUFDZCxFQUNGO29CQUNDLE9BQU9vSSxLQUFLLENBQUNwSSxjQUFjO2dCQUM3QjtnQkFDQXFJLFNBQVN4VSxvRUFBa0JBO1lBQzdCO1lBQ0FpUCxvQkFBb0I7Z0JBQ2xCcUYsU0FBUUMsS0FBSyxFQUFFLEVBQ2J0QixTQUFTLEVBQ1A5RyxhQUFhLEVBQ2I0QyxPQUFPLEVBQ1IsRUFDRjtvQkFDQ3NFLDRCQUE0QmtCLE9BQU9wSSxlQUFlLENBQUNvSDt3QkFDakRBLFNBQVN0TixJQUFJLEdBQUdrTixtREFBWUEsQ0FBQ0ksU0FBU3ROLElBQUksRUFBRThJLFFBQVFwUSxNQUFNO29CQUM1RDtnQkFDRjtnQkFDQTZWLFNBQVN4VSxvRUFBa0JBO1lBQzdCO1FBQ0Y7UUFDQXlVLGVBQWNDLE9BQU87WUFDbkJBLFFBQVFDLE9BQU8sQ0FBQzVKLFdBQVc2SixPQUFPLEVBQUUsQ0FBQ0wsT0FBTyxFQUMxQzdRLElBQUksRUFDSkEsTUFBTSxFQUNKUixHQUFHLEVBQ0osRUFDRjtnQkFDQyxNQUFNMlIsWUFBWWpLLGNBQWMxSDtnQkFDaENxUixLQUFLLENBQUNyUixJQUFJaUosYUFBYSxDQUFDLEtBQUs7b0JBQzNCM08sUUFBUSxnQkFBZ0IsaUJBQWlCO29CQUN6Q3VPLGNBQWM3SSxJQUFJNkksWUFBWTtnQkFDaEM7Z0JBQ0FzSCw0QkFBNEJrQixPQUFPclIsSUFBSWlKLGFBQWEsRUFBRSxDQUFDb0g7b0JBQ3JEQSxTQUFTL1YsTUFBTSxHQUFHLFVBQVUsV0FBVztvQkFDdkMrVixTQUFTN0YsU0FBUyxHQUFHbUgsYUFBYXRCLFNBQVM3RixTQUFTLEdBQ2xELDhEQUE4RDtvQkFDOUQ2RixTQUFTN0YsU0FBUyxHQUVsQixnRkFBZ0Y7b0JBQ2hGaEssS0FBS2dLLFNBQVM7b0JBRWhCLElBQUl4SyxJQUFJa0ssWUFBWSxLQUFLLEtBQUssR0FBRzt3QkFDL0JtRyxTQUFTbkcsWUFBWSxHQUFHbEssSUFBSWtLLFlBQVk7b0JBQzFDO29CQUNBbUcsU0FBUzlCLGdCQUFnQixHQUFHL04sS0FBSytOLGdCQUFnQjtnQkFDbkQ7WUFDRixHQUFHa0QsT0FBTyxDQUFDNUosV0FBVytKLFNBQVMsRUFBRSxDQUFDUCxPQUFPLEVBQ3ZDN1EsSUFBSSxFQUNKdVAsT0FBTyxFQUNSO2dCQUNDSSw0QkFBNEJrQixPQUFPN1EsS0FBS1IsR0FBRyxDQUFDaUosYUFBYSxFQUFFLENBQUNvSDtvQkFDMUQsSUFBSUEsU0FBUzdGLFNBQVMsS0FBS2hLLEtBQUtnSyxTQUFTLElBQUksQ0FBQzlDLGNBQWNsSCxLQUFLUixHQUFHLEdBQ2xFO29CQUNGLE1BQU0sRUFDSjZSLEtBQUssRUFDTixHQUFHbEIsV0FBVyxDQUFDblEsS0FBS1IsR0FBRyxDQUFDNkksWUFBWSxDQUFDO29CQUN0Q3dILFNBQVMvVixNQUFNLEdBQUcsWUFBWSxhQUFhO29CQUMzQyxJQUFJdVgsT0FBTzt3QkFDVCxJQUFJeEIsU0FBU3ROLElBQUksS0FBSyxLQUFLLEdBQUc7NEJBQzVCLE1BQU0sRUFDSnlLLGtCQUFrQixFQUNsQnhOLEdBQUcsRUFDSDJOLGFBQWEsRUFDYm5ELFNBQVMsRUFDVixHQUFHaEs7NEJBQ0osSUFBSXNSLFVBQVV6Viw4Q0FBZUEsQ0FBQ2dVLFNBQVN0TixJQUFJLEVBQUUsQ0FBQ2dQO2dDQUM1QyxPQUFPRixNQUFNRSxtQkFBbUJoQyxTQUFTO29DQUN2Qy9QLEtBQUtBLElBQUlrSyxZQUFZO29DQUNyQnlEO29DQUNBSDtvQ0FDQWhEO2dDQUNGOzRCQUNGOzRCQUNBNkYsU0FBU3ROLElBQUksR0FBRytPO3dCQUNsQixPQUFPOzRCQUNMekIsU0FBU3ROLElBQUksR0FBR2dOO3dCQUNsQjtvQkFDRixPQUFPO3dCQUNMTSxTQUFTdE4sSUFBSSxHQUFHNE4sV0FBVyxDQUFDblEsS0FBS1IsR0FBRyxDQUFDNkksWUFBWSxDQUFDLENBQUNtSixpQkFBaUIsSUFBSSxPQUFPN1UsMEJBQTBCNlMsOENBQU9BLENBQUNLLFNBQVN0TixJQUFJLElBQUltTiwrQ0FBUUEsQ0FBQ0csU0FBU3ROLElBQUksSUFBSXNOLFNBQVN0TixJQUFJLEVBQUVnTixXQUFXQTtvQkFDeEw7b0JBQ0EsT0FBT00sU0FBU3JPLEtBQUs7b0JBQ3JCcU8sU0FBUzdDLGtCQUFrQixHQUFHaE4sS0FBS2dOLGtCQUFrQjtnQkFDdkQ7WUFDRixHQUFHaUUsT0FBTyxDQUFDNUosV0FBV29LLFFBQVEsRUFBRSxDQUFDWixPQUFPLEVBQ3RDN1EsTUFBTSxFQUNKZ08sU0FBUyxFQUNUeE8sR0FBRyxFQUNId0ssU0FBUyxFQUNWLEVBQ0R4SSxLQUFLLEVBQ0wrTixPQUFPLEVBQ1I7Z0JBQ0NJLDRCQUE0QmtCLE9BQU9yUixJQUFJaUosYUFBYSxFQUFFLENBQUNvSDtvQkFDckQsSUFBSTdCLFdBQVcsQ0FDZixPQUFPO3dCQUNMLElBQUk2QixTQUFTN0YsU0FBUyxLQUFLQSxXQUN6Qjt3QkFDRjZGLFNBQVMvVixNQUFNLEdBQUcsV0FBVyxZQUFZO3dCQUN6QytWLFNBQVNyTyxLQUFLLEdBQUcrTixXQUFXL047b0JBQzlCO2dCQUNGO1lBQ0YsR0FBR2tRLFVBQVUsQ0FBQ3BCLG9CQUFvQixDQUFDTyxPQUFPNUI7Z0JBQ3hDLE1BQU0sRUFDSnpCLE9BQU8sRUFDUixHQUFHNkMsdUJBQXVCcEI7Z0JBQzNCLEtBQUssTUFBTSxDQUFDMVIsS0FBS29VLE1BQU0sSUFBSTFVLE9BQU9vQixPQUFPLENBQUNtUCxTQUFVO29CQUNsRCxJQUNFLDBEQUEwRDtvQkFDMURtRSxPQUFPN1gsV0FBVyxZQUFZLGFBQWEsT0FBTTZYLE9BQU83WCxXQUFXLFdBQVcsWUFBWSxLQUMxRjt3QkFDQStXLEtBQUssQ0FBQ3RULElBQUksR0FBR29VO29CQUNmO2dCQUNGO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EsTUFBTUMsZ0JBQWdCblcsNkRBQVdBLENBQUM7UUFDaENnVixNQUFNLENBQUMsRUFBRXRILFlBQVksVUFBVSxDQUFDO1FBQ2hDOEc7UUFDQVMsVUFBVTtZQUNSOUksc0JBQXNCO2dCQUNwQmdKLFNBQVFDLEtBQUssRUFBRSxFQUNidEIsT0FBTyxFQUNSO29CQUNDLE1BQU1zQyxXQUFXL0Isb0JBQW9CUDtvQkFDckMsSUFBSXNDLFlBQVloQixPQUFPO3dCQUNyQixPQUFPQSxLQUFLLENBQUNnQixTQUFTO29CQUN4QjtnQkFDRjtnQkFDQWYsU0FBU3hVLG9FQUFrQkE7WUFDN0I7UUFDRjtRQUNBeVUsZUFBY0MsT0FBTztZQUNuQkEsUUFBUUMsT0FBTyxDQUFDM0osY0FBYzRKLE9BQU8sRUFBRSxDQUFDTCxPQUFPLEVBQzdDN1EsSUFBSSxFQUNKQSxNQUFNLEVBQ0pnSyxTQUFTLEVBQ1R4SyxHQUFHLEVBQ0h1TyxnQkFBZ0IsRUFDakIsRUFDRjtnQkFDQyxJQUFJLENBQUN2TyxJQUFJaUwsS0FBSyxFQUNaO2dCQUNGb0csS0FBSyxDQUFDZixvQkFBb0I5UCxNQUFNLEdBQUc7b0JBQ2pDZ0s7b0JBQ0FsUSxRQUFRLFVBQVUsV0FBVztvQkFDN0J1TyxjQUFjN0ksSUFBSTZJLFlBQVk7b0JBQzlCMEY7Z0JBQ0Y7WUFDRixHQUFHa0QsT0FBTyxDQUFDM0osY0FBYzhKLFNBQVMsRUFBRSxDQUFDUCxPQUFPLEVBQzFDdEIsT0FBTyxFQUNQdlAsSUFBSSxFQUNMO2dCQUNDLElBQUksQ0FBQ0EsS0FBS1IsR0FBRyxDQUFDaUwsS0FBSyxFQUNqQjtnQkFDRnVGLCtCQUErQmEsT0FBTzdRLE1BQU0sQ0FBQzZQO29CQUMzQyxJQUFJQSxTQUFTN0YsU0FBUyxLQUFLaEssS0FBS2dLLFNBQVMsRUFDdkM7b0JBQ0Y2RixTQUFTL1YsTUFBTSxHQUFHLFlBQVksYUFBYTtvQkFDM0MrVixTQUFTdE4sSUFBSSxHQUFHZ047b0JBQ2hCTSxTQUFTN0Msa0JBQWtCLEdBQUdoTixLQUFLZ04sa0JBQWtCO2dCQUN2RDtZQUNGLEdBQUdpRSxPQUFPLENBQUMzSixjQUFjbUssUUFBUSxFQUFFLENBQUNaLE9BQU8sRUFDekN0QixPQUFPLEVBQ1AvTixLQUFLLEVBQ0x4QixJQUFJLEVBQ0w7Z0JBQ0MsSUFBSSxDQUFDQSxLQUFLUixHQUFHLENBQUNpTCxLQUFLLEVBQ2pCO2dCQUNGdUYsK0JBQStCYSxPQUFPN1EsTUFBTSxDQUFDNlA7b0JBQzNDLElBQUlBLFNBQVM3RixTQUFTLEtBQUtoSyxLQUFLZ0ssU0FBUyxFQUN2QztvQkFDRjZGLFNBQVMvVixNQUFNLEdBQUcsV0FBVyxZQUFZO29CQUN6QytWLFNBQVNyTyxLQUFLLEdBQUcrTixXQUFXL047Z0JBQzlCO1lBQ0YsR0FBR2tRLFVBQVUsQ0FBQ3BCLG9CQUFvQixDQUFDTyxPQUFPNUI7Z0JBQ3hDLE1BQU0sRUFDSjZDLFNBQVMsRUFDVixHQUFHekIsdUJBQXVCcEI7Z0JBQzNCLEtBQUssTUFBTSxDQUFDMVIsS0FBS29VLE1BQU0sSUFBSTFVLE9BQU9vQixPQUFPLENBQUN5VCxXQUFZO29CQUNwRCxJQUVFLDBEQUQwRDtvQkFDekRILENBQUFBLE9BQU83WCxXQUFXLFlBQVksYUFBYSxPQUFNNlgsT0FBTzdYLFdBQVcsV0FBVyxZQUFZLEdBQWQsS0FBcUIsdUVBQXVFO29CQUN6S3lELFFBQVFvVSxPQUFPM0gsV0FDZjt3QkFDQTZHLEtBQUssQ0FBQ3RULElBQUksR0FBR29VO29CQUNmO2dCQUNGO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EsTUFBTUksb0JBQW9CdFcsNkRBQVdBLENBQUM7UUFDcENnVixNQUFNLENBQUMsRUFBRXRILFlBQVksYUFBYSxDQUFDO1FBQ25DOEc7UUFDQVMsVUFBVTtZQUNSL0Usa0JBQWtCO2dCQUNoQmlGLFNBQVFDLEtBQUssRUFBRTVCLE1BQU07b0JBQ25CLE1BQU0sRUFDSnhHLGFBQWEsRUFDYmdELFlBQVksRUFDYixHQUFHd0QsT0FBT00sT0FBTztvQkFDbEIsS0FBSyxNQUFNeUMsd0JBQXdCL1UsT0FBTzJMLE1BQU0sQ0FBQ2lJLE9BQVE7d0JBQ3ZELEtBQUssTUFBTW9CLG1CQUFtQmhWLE9BQU8yTCxNQUFNLENBQUNvSixzQkFBdUI7NEJBQ2pFLE1BQU1FLFVBQVVELGdCQUFnQnBSLE9BQU8sQ0FBQzRIOzRCQUN4QyxJQUFJeUosWUFBWSxDQUFDLEdBQUc7Z0NBQ2xCRCxnQkFBZ0JFLE1BQU0sQ0FBQ0QsU0FBUzs0QkFDbEM7d0JBQ0Y7b0JBQ0Y7b0JBQ0EsS0FBSyxNQUFNLEVBQ1RuUyxJQUFJLEVBQ0pnUSxFQUFFLEVBQ0gsSUFBSXRFLGFBQWM7d0JBQ2pCLE1BQU0yRyxvQkFBb0IsQ0FBQ3ZCLEtBQUssQ0FBQzlRLEtBQUssS0FBSyxDQUFDLEVBQUUsQ0FBQ2dRLE1BQU0sd0JBQXdCLEtBQUssRUFBRTt3QkFDcEYsTUFBTXNDLG9CQUFvQkQsa0JBQWtCRSxRQUFRLENBQUM3Sjt3QkFDckQsSUFBSSxDQUFDNEosbUJBQW1COzRCQUN0QkQsa0JBQWtCbEcsSUFBSSxDQUFDekQ7d0JBQ3pCO29CQUNGO2dCQUNGO2dCQUNBcUksU0FBU3hVLG9FQUFrQkE7WUFDN0I7UUFDRjtRQUNBeVUsZUFBY0MsT0FBTztZQUNuQkEsUUFBUUMsT0FBTyxDQUFDVCxXQUFXK0IsT0FBTyxDQUFDNUIsaUJBQWlCLEVBQUUsQ0FBQ0UsT0FBTyxFQUM1RHRCLFNBQVMsRUFDUDlHLGFBQWEsRUFDZCxFQUNGO2dCQUNDLEtBQUssTUFBTXVKLHdCQUF3Qi9VLE9BQU8yTCxNQUFNLENBQUNpSSxPQUFRO29CQUN2RCxLQUFLLE1BQU1vQixtQkFBbUJoVixPQUFPMkwsTUFBTSxDQUFDb0osc0JBQXVCO3dCQUNqRSxNQUFNRSxVQUFVRCxnQkFBZ0JwUixPQUFPLENBQUM0SDt3QkFDeEMsSUFBSXlKLFlBQVksQ0FBQyxHQUFHOzRCQUNsQkQsZ0JBQWdCRSxNQUFNLENBQUNELFNBQVM7d0JBQ2xDO29CQUNGO2dCQUNGO1lBQ0YsR0FBR1IsVUFBVSxDQUFDcEIsb0JBQW9CLENBQUNPLE9BQU81QjtnQkFDeEMsTUFBTSxFQUNKdUQsUUFBUSxFQUNULEdBQUduQyx1QkFBdUJwQjtnQkFDM0IsS0FBSyxNQUFNLENBQUNsUCxNQUFNMFMsYUFBYSxJQUFJeFYsT0FBT29CLE9BQU8sQ0FBQ21VLFVBQVc7b0JBQzNELEtBQUssTUFBTSxDQUFDekMsSUFBSTJDLFVBQVUsSUFBSXpWLE9BQU9vQixPQUFPLENBQUNvVSxjQUFlO3dCQUMxRCxNQUFNTCxvQkFBb0IsQ0FBQ3ZCLEtBQUssQ0FBQzlRLEtBQUssS0FBSyxDQUFDLEVBQUUsQ0FBQ2dRLE1BQU0sd0JBQXdCLEtBQUssRUFBRTt3QkFDcEYsS0FBSyxNQUFNdEgsaUJBQWlCaUssVUFBVzs0QkFDckMsTUFBTUwsb0JBQW9CRCxrQkFBa0JFLFFBQVEsQ0FBQzdKOzRCQUNyRCxJQUFJLENBQUM0SixtQkFBbUI7Z0NBQ3RCRCxrQkFBa0JsRyxJQUFJLENBQUN6RDs0QkFDekI7d0JBQ0Y7b0JBQ0Y7Z0JBQ0Y7WUFDRixHQUFHaUosVUFBVSxDQUFDNVYseURBQU9BLENBQUNLLDZEQUFXQSxDQUFDa0wsYUFBYWpMLHFFQUFtQkEsQ0FBQ2lMLGNBQWMsQ0FBQ3dKLE9BQU81QjtnQkFDdkYsTUFBTXhELGVBQWU2RCx5QkFBeUJMLFFBQVEsZ0JBQWdCa0IsYUFBYWhGO2dCQUNuRixNQUFNLEVBQ0oxQyxhQUFhLEVBQ2QsR0FBR3dHLE9BQU9qUCxJQUFJLENBQUNSLEdBQUc7Z0JBQ25CdVMsa0JBQWtCWSxZQUFZLENBQUNoSCxnQkFBZ0IsQ0FBQ2tGLE9BQU9rQixrQkFBa0JRLE9BQU8sQ0FBQzVHLGdCQUFnQixDQUFDO29CQUNoR2xEO29CQUNBZ0Q7Z0JBQ0Y7WUFDRjtRQUNGO0lBQ0Y7SUFDQSxNQUFNbUgsb0JBQW9CblgsNkRBQVdBLENBQUM7UUFDcENnVixNQUFNLENBQUMsRUFBRXRILFlBQVksY0FBYyxDQUFDO1FBQ3BDOEc7UUFDQVMsVUFBVTtZQUNSN0ksMkJBQTBCZ0wsQ0FBQyxFQUFFQyxDQUFDLEdBQzlCO1lBQ0FuTCx3QkFBdUJrTCxDQUFDLEVBQUVDLENBQUMsR0FDM0I7WUFDQTdKLGtDQUNBO1FBQ0Y7SUFDRjtJQUNBLE1BQU04Siw2QkFBNkJ0WCw2REFBV0EsQ0FBQztRQUM3Q2dWLE1BQU0sQ0FBQyxFQUFFdEgsWUFBWSxzQkFBc0IsQ0FBQztRQUM1QzhHO1FBQ0FTLFVBQVU7WUFDUnNDLHNCQUFzQjtnQkFDcEJwQyxTQUFRdEQsS0FBSyxFQUFFMkIsTUFBTTtvQkFDbkIsT0FBT1EsbURBQVlBLENBQUNuQyxPQUFPMkIsT0FBT00sT0FBTztnQkFDM0M7Z0JBQ0F1QixTQUFTeFUsb0VBQWtCQTtZQUM3QjtRQUNGO0lBQ0Y7SUFDQSxNQUFNMlcsY0FBY3hYLDZEQUFXQSxDQUFDO1FBQzlCZ1YsTUFBTSxDQUFDLEVBQUV0SCxZQUFZLE9BQU8sQ0FBQztRQUM3QjhHLGNBQWM7WUFDWmlELFFBQVFoWTtZQUNSaVksU0FBUzlYO1lBQ1QrWCxzQkFBc0I7WUFDdEIsR0FBR2hULE1BQU07UUFDWDtRQUNBc1EsVUFBVTtZQUNSMEMsc0JBQXFCOUYsS0FBSyxFQUFFLEVBQzFCaUMsT0FBTyxFQUNSO2dCQUNDakMsTUFBTThGLG9CQUFvQixHQUFHOUYsTUFBTThGLG9CQUFvQixLQUFLLGNBQWNoRCxXQUFXYixVQUFVLGFBQWE7WUFDOUc7UUFDRjtRQUNBd0IsZUFBZSxDQUFDQztZQUNkQSxRQUFRQyxPQUFPLENBQUNyTSxVQUFVLENBQUMwSTtnQkFDekJBLE1BQU00RixNQUFNLEdBQUc7WUFDakIsR0FBR2pDLE9BQU8sQ0FBQ3BNLFdBQVcsQ0FBQ3lJO2dCQUNyQkEsTUFBTTRGLE1BQU0sR0FBRztZQUNqQixHQUFHakMsT0FBTyxDQUFDdk0sU0FBUyxDQUFDNEk7Z0JBQ25CQSxNQUFNNkYsT0FBTyxHQUFHO1lBQ2xCLEdBQUdsQyxPQUFPLENBQUN0TSxhQUFhLENBQUMySTtnQkFDdkJBLE1BQU02RixPQUFPLEdBQUc7WUFDbEIsR0FBR3pCLFVBQVUsQ0FBQ3BCLG9CQUFvQixDQUFDTyxRQUFXO29CQUM1QyxHQUFHQSxLQUFLO2dCQUNWO1FBQ0Y7SUFDRjtJQUNBLE1BQU13QyxrQkFBa0J6WCxpRUFBZUEsQ0FBQztRQUN0QzRSLFNBQVNnRCxXQUFXSSxPQUFPO1FBQzNCa0IsV0FBV0YsY0FBY2hCLE9BQU87UUFDaEM0QixVQUFVVCxrQkFBa0JuQixPQUFPO1FBQ25DMEMsZUFBZVAsMkJBQTJCbkMsT0FBTztRQUNqRHhRLFFBQVE2UyxZQUFZckMsT0FBTztJQUM3QjtJQUNBLE1BQU1BLFVBQVUsQ0FBQ3RELE9BQU8yQixTQUFXb0UsZ0JBQWdCOUMsY0FBY2dELEtBQUssQ0FBQ3RFLFVBQVUsS0FBSyxJQUFJM0IsT0FBTzJCO0lBQ2pHLE1BQU1zRCxVQUFVO1FBQ2QsR0FBR1UsWUFBWVYsT0FBTztRQUN0QixHQUFHL0IsV0FBVytCLE9BQU87UUFDckIsR0FBR0ssa0JBQWtCTCxPQUFPO1FBQzVCLEdBQUdRLDJCQUEyQlIsT0FBTztRQUNyQyxHQUFHWCxjQUFjVyxPQUFPO1FBQ3hCLEdBQUdSLGtCQUFrQlEsT0FBTztRQUM1QmhDO0lBQ0Y7SUFDQSxPQUFPO1FBQ0xLO1FBQ0EyQjtJQUNGO0FBQ0Y7QUFFQSxtQ0FBbUM7QUFDbkMsSUFBSWlCLFlBQVksYUFBYSxHQUFHdk0sT0FBT3dNLEdBQUcsQ0FBQztBQUMzQyxJQUFJQyxrQkFBa0I7SUFDcEI1WixRQUFRLGdCQUFnQixpQkFBaUI7QUFDM0M7QUFDQSxJQUFJNlosdUJBQXVCLGFBQWEsR0FBRzlYLDhDQUFlQSxDQUFDNlgsaUJBQWlCLEtBQzVFO0FBQ0EsSUFBSUUsMEJBQTBCLGFBQWEsR0FBRy9YLDhDQUFlQSxDQUFDNlgsaUJBQWlCLEtBQy9FO0FBQ0EsU0FBU0csZUFBZSxFQUN0QnpNLGtCQUFrQixFQUNsQitCLFdBQVcsRUFDWHpOLGdCQUFnQm9ZLGVBQWUsRUFDaEM7SUFDQyxNQUFNQyxxQkFBcUIsQ0FBQ3pHLFFBQVVxRztJQUN0QyxNQUFNSyx3QkFBd0IsQ0FBQzFHLFFBQVVzRztJQUN6QyxPQUFPO1FBQ0xLO1FBQ0FDO1FBQ0FDO1FBQ0FDO0lBQ0Y7SUFDQSxTQUFTQyxpQkFBaUJ4RSxRQUFRO1FBQ2hDLE9BQU87WUFDTCxHQUFHQSxRQUFRO1lBQ1gsR0FBR2hXLHNCQUFzQmdXLFNBQVMvVixNQUFNLENBQUM7UUFDM0M7SUFDRjtJQUNBLFNBQVN3YSxvQkFBb0JDLFNBQVM7UUFDcEMsTUFBTWpILFFBQVFpSCxTQUFTLENBQUNwTCxZQUFZO1FBQ3BDLElBQUlMLElBQXFDLEVBQUU7WUFDekMsSUFBSSxDQUFDd0UsT0FBTztnQkFDVixJQUFJZ0gsb0JBQW9CdkwsU0FBUyxFQUMvQixPQUFPdUU7Z0JBQ1RnSCxvQkFBb0J2TCxTQUFTLEdBQUc7Z0JBQ2hDekosUUFBUWtDLEtBQUssQ0FBQyxDQUFDLGdDQUFnQyxFQUFFMkgsWUFBWSxtREFBbUQsQ0FBQztZQUNuSDtRQUNGO1FBQ0EsT0FBT21FO0lBQ1Q7SUFDQSxTQUFTMkcsbUJBQW1CNUwsWUFBWSxFQUFFRSxrQkFBa0I7UUFDMUQsT0FBTyxDQUFDRDtZQUNOLE1BQU1rTSxpQkFBaUJwTixtQkFBbUI7Z0JBQ3hDa0I7Z0JBQ0FDO2dCQUNBRjtZQUNGO1lBQ0EsTUFBTW9NLHNCQUFzQixDQUFDbkgsUUFBVWdILG9CQUFvQmhILFFBQVFFLFNBQVMsQ0FBQ2dILGVBQWUsSUFBSWI7WUFDaEcsTUFBTWUsMkJBQTJCcE0sY0FBY2tMLFlBQVlPLHFCQUFxQlU7WUFDaEYsT0FBT1gsZ0JBQWdCWSwwQkFBMEJMO1FBQ25EO0lBQ0Y7SUFDQSxTQUFTSDtRQUNQLE9BQU8sQ0FBQ25FO1lBQ04sSUFBSTRFO1lBQ0osSUFBSSxPQUFPNUUsT0FBTyxVQUFVO2dCQUMxQjRFLGFBQWE3RSxvQkFBb0JDLE9BQU95RDtZQUMxQyxPQUFPO2dCQUNMbUIsYUFBYTVFO1lBQ2Y7WUFDQSxNQUFNNkUseUJBQXlCLENBQUN0SCxRQUFVZ0gsb0JBQW9CaEgsUUFBUXdFLFdBQVcsQ0FBQzZDLFdBQVcsSUFBSWY7WUFDakcsTUFBTWlCLDhCQUE4QkYsZUFBZW5CLFlBQVlRLHdCQUF3Qlk7WUFDdkYsT0FBT2QsZ0JBQWdCZSw2QkFBNkJSO1FBQ3REO0lBQ0Y7SUFDQSxTQUFTRixvQkFBb0I3RyxLQUFLLEVBQUV3SCxJQUFJO1FBQ3RDLE1BQU1DLFdBQVd6SCxLQUFLLENBQUNuRSxZQUFZO1FBQ25DLE1BQU02TCxlQUFlLGFBQWEsR0FBRyxJQUFJQztRQUN6QyxLQUFLLE1BQU1DLE9BQU9KLEtBQUszTyxHQUFHLENBQUNDLHNCQUF1QjtZQUNoRCxNQUFNb00sV0FBV3VDLFNBQVN2QyxRQUFRLENBQUMwQyxJQUFJblYsSUFBSSxDQUFDO1lBQzVDLElBQUksQ0FBQ3lTLFVBQVU7Z0JBQ2I7WUFDRjtZQUNBLElBQUkyQywwQkFBMEIsQ0FBQ0QsSUFBSW5GLEVBQUUsS0FBSyxLQUFLLElBQzdDLCtEQUErRDtZQUMvRHlDLFFBQVEsQ0FBQzBDLElBQUluRixFQUFFLENBQUMsR0FFaEIsdURBQXVEO1lBQ3ZEaFYsUUFBUWtDLE9BQU8yTCxNQUFNLENBQUM0SixVQUN4QixLQUFNLEVBQUU7WUFDUixLQUFLLE1BQU00QyxjQUFjRCx3QkFBeUI7Z0JBQ2hESCxhQUFhSyxHQUFHLENBQUNEO1lBQ25CO1FBQ0Y7UUFDQSxPQUFPcmEsUUFBUStCLE1BQU13WSxJQUFJLENBQUNOLGFBQWFwTSxNQUFNLElBQUl6QyxHQUFHLENBQUMsQ0FBQ3NDO1lBQ3BELE1BQU04TSxnQkFBZ0JSLFNBQVN2SCxPQUFPLENBQUMvRSxjQUFjO1lBQ3JELE9BQU84TSxnQkFBZ0I7Z0JBQUM7b0JBQ3RCOU07b0JBQ0FKLGNBQWNrTixjQUFjbE4sWUFBWTtvQkFDeENxQixjQUFjNkwsY0FBYzdMLFlBQVk7Z0JBQzFDO2FBQUUsR0FBRyxFQUFFO1FBQ1Q7SUFDRjtJQUNBLFNBQVMwSyx5QkFBeUI5RyxLQUFLLEVBQUVrSSxTQUFTO1FBQ2hELE9BQU92WSxPQUFPMkwsTUFBTSxDQUFDMEUsS0FBSyxDQUFDbkUsWUFBWSxDQUFDcUUsT0FBTyxFQUFFMUosTUFBTSxDQUFDLENBQUM2TixRQUFVQSxPQUFPdEosaUJBQWlCbU4sYUFBYTdELE1BQU03WCxNQUFNLEtBQUssZ0JBQWdCLGlCQUFpQixLQUFJcU0sR0FBRyxDQUFDLENBQUN3TCxRQUFVQSxNQUFNakksWUFBWTtJQUNqTTtBQUNGO0FBRUEseUNBQXlDO0FBQ3pDLElBQUkrTCxRQUFRQyxVQUFVLGFBQWEsR0FBRyxJQUFJQSxZQUFZLEtBQUs7QUFDM0QsSUFBSUMsNEJBQTRCLENBQUMsRUFDL0J0TixZQUFZLEVBQ1pDLFNBQVMsRUFDVjtJQUNDLElBQUlzTixhQUFhO0lBQ2pCLE1BQU1DLFNBQVNKLE9BQU8xWCxJQUFJdUs7SUFDMUIsSUFBSSxPQUFPdU4sV0FBVyxVQUFVO1FBQzlCRCxhQUFhQztJQUNmLE9BQU87UUFDTCxNQUFNQyxjQUFjcFYsS0FBS0MsU0FBUyxDQUFDMkgsV0FBVyxDQUFDL0ssS0FBS29GLFFBQVVuRywrREFBYUEsQ0FBQ21HLFNBQVMxRixPQUFPQyxJQUFJLENBQUN5RixPQUFPb1QsSUFBSSxHQUFHQyxNQUFNLENBQUMsQ0FBQ0MsS0FBS0M7Z0JBQzFIRCxHQUFHLENBQUNDLEtBQUssR0FBR3ZULEtBQUssQ0FBQ3VULEtBQUs7Z0JBQ3ZCLE9BQU9EO1lBQ1QsR0FBRyxDQUFDLEtBQUt0VDtRQUNULElBQUluRywrREFBYUEsQ0FBQzhMLFlBQVk7WUFDNUJtTixPQUFPaFYsSUFBSTZILFdBQVd3TjtRQUN4QjtRQUNBRixhQUFhRTtJQUNmO0lBQ0EsT0FBTyxDQUFDLEVBQUV6TixhQUFhLENBQUMsRUFBRXVOLFdBQVcsQ0FBQyxDQUFDO0FBQ3pDO0FBRUEseUJBQXlCO0FBQ2lCO0FBQzFDLFNBQVNRLGVBQWUsR0FBR0MsT0FBTztJQUNoQyxPQUFPLFNBQVNDLGNBQWNuUyxPQUFPO1FBQ25DLE1BQU1rTSx5QkFBeUI4Rix3REFBY0EsQ0FBQyxDQUFDbEgsU0FBVzlLLFFBQVFrTSxzQkFBc0IsR0FBR3BCLFFBQVE7Z0JBQ2pHOUYsYUFBYWhGLFFBQVFnRixXQUFXLElBQUk7WUFDdEM7UUFDQSxNQUFNb04sc0JBQXNCO1lBQzFCcE4sYUFBYTtZQUNicU4sbUJBQW1CO1lBQ25COUksMkJBQTJCO1lBQzNCK0ksZ0JBQWdCO1lBQ2hCQyxvQkFBb0I7WUFDcEJDLHNCQUFzQjtZQUN0QixHQUFHeFMsT0FBTztZQUNWa007WUFDQWpKLG9CQUFtQndQLFlBQVk7Z0JBQzdCLElBQUlDLDBCQUEwQmxCO2dCQUM5QixJQUFJLHdCQUF3QmlCLGFBQWFyTyxrQkFBa0IsRUFBRTtvQkFDM0QsTUFBTXVPLGNBQWNGLGFBQWFyTyxrQkFBa0IsQ0FBQ25CLGtCQUFrQjtvQkFDdEV5UCwwQkFBMEIsQ0FBQ0U7d0JBQ3pCLE1BQU1DLGdCQUFnQkYsWUFBWUM7d0JBQ2xDLElBQUksT0FBT0Msa0JBQWtCLFVBQVU7NEJBQ3JDLE9BQU9BO3dCQUNULE9BQU87NEJBQ0wsT0FBT3JCLDBCQUEwQjtnQ0FDL0IsR0FBR29CLGFBQWE7Z0NBQ2hCek8sV0FBVzBPOzRCQUNiO3dCQUNGO29CQUNGO2dCQUNGLE9BQU8sSUFBSTdTLFFBQVFpRCxrQkFBa0IsRUFBRTtvQkFDckN5UCwwQkFBMEIxUyxRQUFRaUQsa0JBQWtCO2dCQUN0RDtnQkFDQSxPQUFPeVAsd0JBQXdCRDtZQUNqQztZQUNBSyxVQUFVO21CQUFJOVMsUUFBUThTLFFBQVEsSUFBSSxFQUFFO2FBQUM7UUFDdkM7UUFDQSxNQUFNMVAsVUFBVTtZQUNkaUIscUJBQXFCLENBQUM7WUFDdEIwTyxPQUFNQyxFQUFFO2dCQUNOQTtZQUNGO1lBQ0EvRyxRQUFRM1Qsd0RBQU1BO1lBQ2Q0VDtZQUNBQyxvQkFBb0I2Rix3REFBY0EsQ0FBQyxDQUFDbEgsU0FBV29CLHVCQUF1QnBCLFdBQVc7UUFDbkY7UUFDQSxNQUFNeFAsTUFBTTtZQUNWMlg7WUFDQUMsa0JBQWlCLEVBQ2ZDLFdBQVcsRUFDWDFOLFNBQVMsRUFDVjtnQkFDQyxJQUFJME4sYUFBYTtvQkFDZixLQUFLLE1BQU1DLE1BQU1ELFlBQWE7d0JBQzVCLElBQUksQ0FBQ2Ysb0JBQW9CVSxRQUFRLENBQUMzRSxRQUFRLENBQUNpRixLQUFLOzs0QkFFOUNoQixvQkFBb0JVLFFBQVEsQ0FBQy9LLElBQUksQ0FBQ3FMO3dCQUNwQztvQkFDRjtnQkFDRjtnQkFDQSxJQUFJM04sV0FBVztvQkFDYixLQUFLLE1BQU0sQ0FBQ3ZCLGNBQWNtUCxrQkFBa0IsSUFBSXZhLE9BQU9vQixPQUFPLENBQUN1TCxXQUFZO3dCQUN6RSxJQUFJLE9BQU80TixzQkFBc0IsWUFBWTs0QkFDM0NBLGtCQUFrQmpRLFFBQVFpQixtQkFBbUIsQ0FBQ0gsYUFBYTt3QkFDN0QsT0FBTzs0QkFDTHBMLE9BQU9xRyxNQUFNLENBQUNpRSxRQUFRaUIsbUJBQW1CLENBQUNILGFBQWEsSUFBSSxDQUFDLEdBQUdtUDt3QkFDakU7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0EsT0FBTy9YO1lBQ1Q7UUFDRjtRQUNBLE1BQU1nWSxxQkFBcUJwQixRQUFRbFEsR0FBRyxDQUFDLENBQUN1UixJQUFNQSxFQUFFQyxJQUFJLENBQUNsWSxLQUFLOFcscUJBQXFCaFA7UUFDL0UsU0FBUzZQLGdCQUFnQlEsTUFBTTtZQUM3QixNQUFNQyxxQkFBcUJELE9BQU9oTyxTQUFTLENBQUM7Z0JBQzFDOUksT0FBTyxDQUFDckMsSUFBTzt3QkFDYixHQUFHQSxDQUFDO3dCQUNKc0IsTUFBTSxRQUFRLFNBQVM7b0JBQ3pCO2dCQUNBK1gsVUFBVSxDQUFDclosSUFBTzt3QkFDaEIsR0FBR0EsQ0FBQzt3QkFDSnNCLE1BQU0sV0FBVyxZQUFZO29CQUMvQjtZQUNGO1lBQ0EsS0FBSyxNQUFNLENBQUNzSSxjQUFjMFAsV0FBVyxJQUFJOWEsT0FBT29CLE9BQU8sQ0FBQ3daLG9CQUFxQjtnQkFDM0UsSUFBSSxDQUFDRCxPQUFPSSxnQkFBZ0IsSUFBSTNQLGdCQUFnQmQsUUFBUWlCLG1CQUFtQixFQUFFO29CQUMzRSxJQUFJLE9BQU9NLFlBQVksZUFBZUEsa0JBQXlCLGVBQWU7d0JBQzVFeEosUUFBUWtDLEtBQUssQ0FBQyxDQUFDLHFFQUFxRSxFQUFFNkcsYUFBYSw4Q0FBOEMsQ0FBQztvQkFDcEo7b0JBQ0E7Z0JBQ0Y7Z0JBQ0FkLFFBQVFpQixtQkFBbUIsQ0FBQ0gsYUFBYSxHQUFHMFA7Z0JBQzVDLEtBQUssTUFBTUwsS0FBS0QsbUJBQW9CO29CQUNsQ0MsRUFBRU8sY0FBYyxDQUFDNVAsY0FBYzBQO2dCQUNqQztZQUNGO1lBQ0EsT0FBT3RZO1FBQ1Q7UUFDQSxPQUFPQSxJQUFJMlgsZUFBZSxDQUFDO1lBQ3pCeE4sV0FBV3pGLFFBQVF5RixTQUFTO1FBQzlCO0lBQ0Y7QUFDRjtBQUVBLDZCQUE2QjtBQUN5RDtBQUN0RixTQUFTdU87SUFDUCxPQUFPO1FBQ0wsTUFBTSxJQUFJalAsTUFBTUosTUFBcUMsR0FBR29QLENBQTRCLEdBQUc7SUFDekY7QUFDRjtBQUVBLG9EQUFvRDtBQUNwRCxTQUFTRSxjQUFjbmEsR0FBRztJQUN4QixJQUFLLElBQUlFLEtBQUtGLElBQUs7UUFDakIsT0FBTztJQUNUO0lBQ0EsT0FBTztBQUNUO0FBQ0EsSUFBSW9hLG1DQUFtQyxhQUFhLE1BQU07QUFDMUQsSUFBSUMsOEJBQThCLENBQUMsRUFDakNuUCxXQUFXLEVBQ1gxSixHQUFHLEVBQ0g4SCxPQUFPLEVBQ1BnUixhQUFhLEVBQ2Q7SUFDQyxNQUFNLEVBQ0o1SCxpQkFBaUIsRUFDakJoSixzQkFBc0IsRUFDdkIsR0FBR2xJLElBQUlxSSxlQUFlO0lBQ3ZCLFNBQVMwUSxnQ0FBZ0MvUCxhQUFhO1FBQ3BELE1BQU02SyxnQkFBZ0JpRixjQUFjRSxvQkFBb0IsQ0FBQ2hRLGNBQWM7UUFDdkUsT0FBTyxDQUFDLENBQUM2SyxpQkFBaUIsQ0FBQzhFLGNBQWM5RTtJQUMzQztJQUNBLE1BQU1vRix5QkFBeUIsQ0FBQztJQUNoQyxNQUFNQyxVQUFVLENBQUMxSixRQUFRMkosT0FBT0M7UUFDOUIsSUFBSWxSLHVCQUF1QjRMLEtBQUssQ0FBQ3RFLFNBQVM7WUFDeEMsTUFBTTNCLFFBQVFzTCxNQUFNalosUUFBUSxFQUFFLENBQUN3SixZQUFZO1lBQzNDLE1BQU0sRUFDSlYsYUFBYSxFQUNkLEdBQUd3RyxPQUFPTSxPQUFPO1lBQ2xCdUosa0JBQWtCclEsZUFBZTZFLE1BQU1FLE9BQU8sQ0FBQy9FLGNBQWMsRUFBRUosY0FBY3VRLE9BQU90TCxNQUFNbE4sTUFBTTtRQUNsRztRQUNBLElBQUlYLElBQUl3TSxJQUFJLENBQUNzRSxhQUFhLENBQUNnRCxLQUFLLENBQUN0RSxTQUFTO1lBQ3hDLEtBQUssTUFBTSxDQUFDMVIsS0FBS3dCLFFBQVEsSUFBSTlCLE9BQU9vQixPQUFPLENBQUNxYSx3QkFBeUI7Z0JBQ25FLElBQUkzWixTQUNGMkMsYUFBYTNDO2dCQUNmLE9BQU8yWixzQkFBc0IsQ0FBQ25iLElBQUk7WUFDcEM7UUFDRjtRQUNBLElBQUlnSyxRQUFRK0ksa0JBQWtCLENBQUNyQixTQUFTO1lBQ3RDLE1BQU0zQixRQUFRc0wsTUFBTWpaLFFBQVEsRUFBRSxDQUFDd0osWUFBWTtZQUMzQyxNQUFNLEVBQ0pxRSxPQUFPLEVBQ1IsR0FBR2pHLFFBQVE4SSxzQkFBc0IsQ0FBQ3BCO1lBQ25DLEtBQUssTUFBTSxDQUFDeEcsZUFBZXNRLFdBQVcsSUFBSTliLE9BQU9vQixPQUFPLENBQUNtUCxTQUFVO2dCQUNqRXNMLGtCQUFrQnJRLGVBQWVzUSxZQUFZMVEsY0FBY3VRLE9BQU90TCxNQUFNbE4sTUFBTTtZQUNoRjtRQUNGO0lBQ0Y7SUFDQSxTQUFTMFksa0JBQWtCclEsYUFBYSxFQUFFSixZQUFZLEVBQUUyUSxJQUFJLEVBQUU1WSxNQUFNO1FBQ2xFLE1BQU1tSSxxQkFBcUJoQixRQUFRaUIsbUJBQW1CLENBQUNILGFBQWE7UUFDcEUsTUFBTW1PLG9CQUFvQmpPLG9CQUFvQmlPLHFCQUFxQnBXLE9BQU9vVyxpQkFBaUI7UUFDM0YsSUFBSUEsc0JBQXNCeUMsVUFBVTtZQUNsQztRQUNGO1FBQ0EsTUFBTUMseUJBQXlCbFcsS0FBS21XLEdBQUcsQ0FBQyxHQUFHblcsS0FBS0MsR0FBRyxDQUFDdVQsbUJBQW1CNkI7UUFDdkUsSUFBSSxDQUFDRyxnQ0FBZ0MvUCxnQkFBZ0I7WUFDbkQsTUFBTTJRLGlCQUFpQlYsc0JBQXNCLENBQUNqUSxjQUFjO1lBQzVELElBQUkyUSxnQkFBZ0I7Z0JBQ2xCMVgsYUFBYTBYO1lBQ2Y7WUFDQVYsc0JBQXNCLENBQUNqUSxjQUFjLEdBQUdwSCxXQUFXO2dCQUNqRCxJQUFJLENBQUNtWCxnQ0FBZ0MvUCxnQkFBZ0I7b0JBQ25EdVEsS0FBS2hVLFFBQVEsQ0FBQzJMLGtCQUFrQjt3QkFDOUJsSTtvQkFDRjtnQkFDRjtnQkFDQSxPQUFPaVEsc0JBQXNCLENBQUNqUSxjQUFjO1lBQzlDLEdBQUd5USx5QkFBeUI7UUFDOUI7SUFDRjtJQUNBLE9BQU9QO0FBQ1Q7QUFFQSx1REFBdUQ7QUFDdkQsSUFBSVUsaUNBQWlDLENBQUMsRUFDcENsUSxXQUFXLEVBQ1g1QixPQUFPLEVBQ1BBLFNBQVMsRUFDUGlCLG1CQUFtQixFQUNwQixFQUNEbEIsYUFBYSxFQUNiRCxVQUFVLEVBQ1Y1SCxHQUFHLEVBQ0gwTCxhQUFhLEVBQ2JtTyxZQUFZLEVBQ1pmLGFBQWEsRUFDZDtJQUNDLE1BQU0sRUFDSjVILGlCQUFpQixFQUNsQixHQUFHbFIsSUFBSXFJLGVBQWU7SUFDdkIsTUFBTXlSLHdCQUF3QnpkLHlEQUFPQSxDQUFDSyw2REFBV0EsQ0FBQ21MLGdCQUFnQmxMLHFFQUFtQkEsQ0FBQ2tMO0lBQ3RGLE1BQU1rUyxhQUFhMWQseURBQU9BLENBQUNLLDZEQUFXQSxDQUFDbUwsZUFBZUQsYUFBYW5MLDREQUFVQSxDQUFDb0wsZUFBZUQ7SUFDN0YsSUFBSW9TLDBCQUEwQixFQUFFO0lBQ2hDLE1BQU1kLFVBQVUsQ0FBQzFKLFFBQVEySjtRQUN2QixJQUFJVyxzQkFBc0J0SyxTQUFTO1lBQ2pDeUssZUFBZXBLLHlCQUF5QkwsUUFBUSxtQkFBbUJ6RyxxQkFBcUIyQyxnQkFBZ0J5TjtRQUMxRyxPQUFPLElBQUlZLFdBQVd2SyxTQUFTO1lBQzdCeUssZUFBZSxFQUFFLEVBQUVkO1FBQ3JCLE9BQU8sSUFBSW5aLElBQUl3TSxJQUFJLENBQUN5TixjQUFjLENBQUNuRyxLQUFLLENBQUN0RSxTQUFTO1lBQ2hEeUssZUFBZTVULG9CQUFvQm1KLE9BQU9NLE9BQU8sRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHLEtBQUssR0FBRyxLQUFLLEdBQUdwRSxnQkFBZ0J5TjtRQUNyRztJQUNGO0lBQ0EsU0FBU2UsbUJBQW1Cck0sS0FBSztRQUMvQixJQUFLLE1BQU0vUCxPQUFPK1AsTUFBTUUsT0FBTyxDQUFFO1lBQy9CLElBQUlGLE1BQU1FLE9BQU8sQ0FBQ2pRLElBQUksRUFBRXpELFdBQVcsVUFBVSxXQUFXLEtBQ3RELE9BQU87UUFDWDtRQUNBLElBQUssTUFBTXlELE9BQU8rUCxNQUFNd0UsU0FBUyxDQUFFO1lBQ2pDLElBQUl4RSxNQUFNd0UsU0FBUyxDQUFDdlUsSUFBSSxFQUFFekQsV0FBVyxVQUFVLFdBQVcsS0FDeEQsT0FBTztRQUNYO1FBQ0EsT0FBTztJQUNUO0lBQ0EsU0FBUzRmLGVBQWVFLE9BQU8sRUFBRWhCLEtBQUs7UUFDcEMsTUFBTXJFLFlBQVlxRSxNQUFNalosUUFBUTtRQUNoQyxNQUFNMk4sUUFBUWlILFNBQVMsQ0FBQ3BMLFlBQVk7UUFDcENzUSx3QkFBd0J2TixJQUFJLElBQUkwTjtRQUNoQyxJQUFJdE0sTUFBTWxOLE1BQU0sQ0FBQ3VXLG9CQUFvQixLQUFLLGFBQWFnRCxtQkFBbUJyTSxRQUFRO1lBQ2hGO1FBQ0Y7UUFDQSxNQUFNd0gsT0FBTzJFO1FBQ2JBLDBCQUEwQixFQUFFO1FBQzVCLElBQUkzRSxLQUFLelgsTUFBTSxLQUFLLEdBQ2xCO1FBQ0YsTUFBTTJYLGVBQWV2VixJQUFJd00sSUFBSSxDQUFDa0ksbUJBQW1CLENBQUNJLFdBQVdPO1FBQzdEdk4sUUFBUTJQLEtBQUssQ0FBQztZQUNaLE1BQU0yQyxjQUFjL2MsTUFBTXdZLElBQUksQ0FBQ04sYUFBYXBNLE1BQU07WUFDbEQsS0FBSyxNQUFNLEVBQ1RILGFBQWEsRUFDZCxJQUFJb1IsWUFBYTtnQkFDaEIsTUFBTXRFLGdCQUFnQmpJLE1BQU1FLE9BQU8sQ0FBQy9FLGNBQWM7Z0JBQ2xELE1BQU1xUix1QkFBdUJ2QixjQUFjRSxvQkFBb0IsQ0FBQ2hRLGNBQWMsSUFBSSxDQUFDO2dCQUNuRixJQUFJOE0sZUFBZTtvQkFDakIsSUFBSTlPLGdCQUFnQnFULDBCQUEwQixHQUFHO3dCQUMvQ2xCLE1BQU01VCxRQUFRLENBQUMyTCxrQkFBa0I7NEJBQy9CbEk7d0JBQ0Y7b0JBQ0YsT0FBTyxJQUFJOE0sY0FBY3piLE1BQU0sS0FBSyxnQkFBZ0IsaUJBQWlCLEtBQUk7d0JBQ3ZFOGUsTUFBTTVULFFBQVEsQ0FBQ3NVLGFBQWEvRCxlQUFlOU07b0JBQzdDO2dCQUNGO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EsT0FBT2tRO0FBQ1Q7QUFFQSw0Q0FBNEM7QUFDNUMsSUFBSW9CLHNCQUFzQixDQUFDLEVBQ3pCNVEsV0FBVyxFQUNYOUIsVUFBVSxFQUNWNUgsR0FBRyxFQUNINlosWUFBWSxFQUNaZixhQUFhLEVBQ2Q7SUFDQyxNQUFNeUIsZUFBZSxDQUFDO0lBQ3RCLE1BQU1yQixVQUFVLENBQUMxSixRQUFRMko7UUFDdkIsSUFBSW5aLElBQUlxSSxlQUFlLENBQUNELHlCQUF5QixDQUFDMEwsS0FBSyxDQUFDdEUsV0FBV3hQLElBQUlxSSxlQUFlLENBQUNILHNCQUFzQixDQUFDNEwsS0FBSyxDQUFDdEUsU0FBUztZQUMzSGdMLHNCQUFzQmhMLE9BQU9NLE9BQU8sRUFBRXFKO1FBQ3hDO1FBQ0EsSUFBSXZSLFdBQVc2SixPQUFPLENBQUNxQyxLQUFLLENBQUN0RSxXQUFXNUgsV0FBV29LLFFBQVEsQ0FBQzhCLEtBQUssQ0FBQ3RFLFdBQVdBLE9BQU9qUCxJQUFJLENBQUNnTyxTQUFTLEVBQUU7WUFDbEdpTSxzQkFBc0JoTCxPQUFPalAsSUFBSSxDQUFDUixHQUFHLEVBQUVvWjtRQUN6QztRQUNBLElBQUl2UixXQUFXK0osU0FBUyxDQUFDbUMsS0FBSyxDQUFDdEUsV0FBVzVILFdBQVdvSyxRQUFRLENBQUM4QixLQUFLLENBQUN0RSxXQUFXLENBQUNBLE9BQU9qUCxJQUFJLENBQUNnTyxTQUFTLEVBQUU7WUFDckdrTSxjQUFjakwsT0FBT2pQLElBQUksQ0FBQ1IsR0FBRyxFQUFFb1o7UUFDakM7UUFDQSxJQUFJblosSUFBSXdNLElBQUksQ0FBQ3NFLGFBQWEsQ0FBQ2dELEtBQUssQ0FBQ3RFLFNBQVM7WUFDeENrTDtRQUNGO0lBQ0Y7SUFDQSxTQUFTRCxjQUFjLEVBQ3JCelIsYUFBYSxFQUNkLEVBQUV1USxJQUFJO1FBQ0wsTUFBTTFMLFFBQVEwTCxLQUFLclosUUFBUSxFQUFFLENBQUN3SixZQUFZO1FBQzFDLE1BQU1vTSxnQkFBZ0JqSSxNQUFNRSxPQUFPLENBQUMvRSxjQUFjO1FBQ2xELE1BQU02SyxnQkFBZ0JpRixjQUFjRSxvQkFBb0IsQ0FBQ2hRLGNBQWM7UUFDdkUsSUFBSSxDQUFDOE0saUJBQWlCQSxjQUFjemIsTUFBTSxLQUFLLGdCQUFnQixpQkFBaUIsS0FDOUU7UUFDRixNQUFNLEVBQ0pzZ0IscUJBQXFCLEVBQ3JCQyxzQkFBc0IsRUFDdkIsR0FBR0MsMEJBQTBCaEg7UUFDOUIsSUFBSSxDQUFDekYsT0FBTzBNLFFBQVEsQ0FBQ0gsd0JBQ25CO1FBQ0YsTUFBTUksY0FBY1IsWUFBWSxDQUFDdlIsY0FBYztRQUMvQyxJQUFJK1IsYUFBYXpiLFNBQVM7WUFDeEIyQyxhQUFhOFksWUFBWXpiLE9BQU87WUFDaEN5YixZQUFZemIsT0FBTyxHQUFHLEtBQUs7UUFDN0I7UUFDQSxNQUFNMGIsb0JBQW9CeE4sS0FBS0MsR0FBRyxLQUFLa047UUFDdkNKLFlBQVksQ0FBQ3ZSLGNBQWMsR0FBRztZQUM1QmdTO1lBQ0FDLGlCQUFpQk47WUFDakJyYixTQUFTc0MsV0FBVztnQkFDbEIsSUFBSWlNLE1BQU1sTixNQUFNLENBQUMrUyxPQUFPLElBQUksQ0FBQ2tILHdCQUF3QjtvQkFDbkRyQixLQUFLaFUsUUFBUSxDQUFDc1UsYUFBYS9ELGVBQWU5TTtnQkFDNUM7Z0JBQ0F5UixjQUFjO29CQUNaelI7Z0JBQ0YsR0FBR3VRO1lBQ0wsR0FBR29CO1FBQ0w7SUFDRjtJQUNBLFNBQVNILHNCQUFzQixFQUM3QnhSLGFBQWEsRUFDZCxFQUFFdVEsSUFBSTtRQUNMLE1BQU0xTCxRQUFRMEwsS0FBS3JaLFFBQVEsRUFBRSxDQUFDd0osWUFBWTtRQUMxQyxNQUFNb00sZ0JBQWdCakksTUFBTUUsT0FBTyxDQUFDL0UsY0FBYztRQUNsRCxNQUFNNkssZ0JBQWdCaUYsY0FBY0Usb0JBQW9CLENBQUNoUSxjQUFjO1FBQ3ZFLElBQUksQ0FBQzhNLGlCQUFpQkEsY0FBY3piLE1BQU0sS0FBSyxnQkFBZ0IsaUJBQWlCLEtBQUk7WUFDbEY7UUFDRjtRQUNBLE1BQU0sRUFDSnNnQixxQkFBcUIsRUFDdEIsR0FBR0UsMEJBQTBCaEg7UUFDOUIsSUFBSSxDQUFDekYsT0FBTzBNLFFBQVEsQ0FBQ0gsd0JBQXdCO1lBQzNDTyxrQkFBa0JsUztZQUNsQjtRQUNGO1FBQ0EsTUFBTStSLGNBQWNSLFlBQVksQ0FBQ3ZSLGNBQWM7UUFDL0MsTUFBTWdTLG9CQUFvQnhOLEtBQUtDLEdBQUcsS0FBS2tOO1FBQ3ZDLElBQUksQ0FBQ0ksZUFBZUMsb0JBQW9CRCxZQUFZQyxpQkFBaUIsRUFBRTtZQUNyRVAsY0FBYztnQkFDWnpSO1lBQ0YsR0FBR3VRO1FBQ0w7SUFDRjtJQUNBLFNBQVMyQixrQkFBa0JwZCxHQUFHO1FBQzVCLE1BQU1xZCxlQUFlWixZQUFZLENBQUN6YyxJQUFJO1FBQ3RDLElBQUlxZCxjQUFjN2IsU0FBUztZQUN6QjJDLGFBQWFrWixhQUFhN2IsT0FBTztRQUNuQztRQUNBLE9BQU9pYixZQUFZLENBQUN6YyxJQUFJO0lBQzFCO0lBQ0EsU0FBUzRjO1FBQ1AsS0FBSyxNQUFNNWMsT0FBT04sT0FBT0MsSUFBSSxDQUFDOGMsY0FBZTtZQUMzQ1csa0JBQWtCcGQ7UUFDcEI7SUFDRjtJQUNBLFNBQVMrYywwQkFBMEJPLGNBQWMsQ0FBQyxDQUFDO1FBQ2pELElBQUlSLHlCQUF5QjtRQUM3QixJQUFJRCx3QkFBd0J2TSxPQUFPaU4saUJBQWlCO1FBQ3BELElBQUssSUFBSXZkLE9BQU9zZCxZQUFhO1lBQzNCLElBQUksQ0FBQyxDQUFDQSxXQUFXLENBQUN0ZCxJQUFJLENBQUNtZCxlQUFlLEVBQUU7Z0JBQ3RDTix3QkFBd0JwWCxLQUFLQyxHQUFHLENBQUM0WCxXQUFXLENBQUN0ZCxJQUFJLENBQUNtZCxlQUFlLEVBQUVOO2dCQUNuRUMseUJBQXlCUSxXQUFXLENBQUN0ZCxJQUFJLENBQUM4YyxzQkFBc0IsSUFBSUE7WUFDdEU7UUFDRjtRQUNBLE9BQU87WUFDTEQ7WUFDQUM7UUFDRjtJQUNGO0lBQ0EsT0FBTzFCO0FBQ1Q7QUFFQSx3REFBd0Q7QUFDeEQsSUFBSW9DLDBCQUEwQixDQUFDLEVBQzdCNVIsV0FBVyxFQUNYNUIsT0FBTyxFQUNQOUgsR0FBRyxFQUNINlosWUFBWSxFQUNaZixhQUFhLEVBQ2Q7SUFDQyxNQUFNLEVBQ0o1SCxpQkFBaUIsRUFDbEIsR0FBR2xSLElBQUlxSSxlQUFlO0lBQ3ZCLE1BQU02USxVQUFVLENBQUMxSixRQUFRMko7UUFDdkIsSUFBSWxVLFFBQVE2TyxLQUFLLENBQUN0RSxTQUFTO1lBQ3pCK0wsb0JBQW9CcEMsT0FBTztRQUM3QjtRQUNBLElBQUloVSxTQUFTMk8sS0FBSyxDQUFDdEUsU0FBUztZQUMxQitMLG9CQUFvQnBDLE9BQU87UUFDN0I7SUFDRjtJQUNBLFNBQVNvQyxvQkFBb0JoQyxJQUFJLEVBQUVqWixJQUFJO1FBQ3JDLE1BQU11TixRQUFRMEwsS0FBS3JaLFFBQVEsRUFBRSxDQUFDd0osWUFBWTtRQUMxQyxNQUFNcUUsVUFBVUYsTUFBTUUsT0FBTztRQUM3QixNQUFNOEYsZ0JBQWdCaUYsY0FBY0Usb0JBQW9CO1FBQ3hEbFIsUUFBUTJQLEtBQUssQ0FBQztZQUNaLEtBQUssTUFBTXpPLGlCQUFpQnhMLE9BQU9DLElBQUksQ0FBQ29XLGVBQWdCO2dCQUN0RCxNQUFNaUMsZ0JBQWdCL0gsT0FBTyxDQUFDL0UsY0FBYztnQkFDNUMsTUFBTXFSLHVCQUF1QnhHLGFBQWEsQ0FBQzdLLGNBQWM7Z0JBQ3pELElBQUksQ0FBQ3FSLHdCQUF3QixDQUFDdkUsZUFDNUI7Z0JBQ0YsTUFBTTBGLGdCQUFnQmhlLE9BQU8yTCxNQUFNLENBQUNrUixzQkFBc0JvQixJQUFJLENBQUMsQ0FBQ0MsTUFBUUEsR0FBRyxDQUFDcGIsS0FBSyxLQUFLLFNBQVM5QyxPQUFPMkwsTUFBTSxDQUFDa1Isc0JBQXNCc0IsS0FBSyxDQUFDLENBQUNELE1BQVFBLEdBQUcsQ0FBQ3BiLEtBQUssS0FBSyxLQUFLLE1BQU11TixNQUFNbE4sTUFBTSxDQUFDTCxLQUFLO2dCQUM3TCxJQUFJa2IsZUFBZTtvQkFDakIsSUFBSXhVLGdCQUFnQnFULDBCQUEwQixHQUFHO3dCQUMvQ2QsS0FBS2hVLFFBQVEsQ0FBQzJMLGtCQUFrQjs0QkFDOUJsSTt3QkFDRjtvQkFDRixPQUFPLElBQUk4TSxjQUFjemIsTUFBTSxLQUFLLGdCQUFnQixpQkFBaUIsS0FBSTt3QkFDdkVrZixLQUFLaFUsUUFBUSxDQUFDc1UsYUFBYS9ELGVBQWU5TTtvQkFDNUM7Z0JBQ0Y7WUFDRjtRQUNGO0lBQ0Y7SUFDQSxPQUFPa1E7QUFDVDtBQUVBLG1EQUFtRDtBQUNuRCxJQUFJMEMscUJBQXFCLElBQUluUyxNQUFNO0FBQ25DLElBQUlvUyw2QkFBNkIsQ0FBQyxFQUNoQzdiLEdBQUcsRUFDSDBKLFdBQVcsRUFDWDVCLE9BQU8sRUFDUEYsVUFBVSxFQUNWQyxhQUFhLEVBQ2JpUixhQUFhLEVBQ2Q7SUFDQyxNQUFNZ0QsZUFBZWxmLG9FQUFrQkEsQ0FBQ2dMO0lBQ3hDLE1BQU1tVSxrQkFBa0JuZixvRUFBa0JBLENBQUNpTDtJQUMzQyxNQUFNbVUsbUJBQW1CdGYsNkRBQVdBLENBQUNrTCxZQUFZQztJQUNqRCxNQUFNb1UsZUFBZSxDQUFDO0lBQ3RCLE1BQU0vQyxVQUFVLENBQUMxSixRQUFRMkosT0FBTytDO1FBQzlCLE1BQU05SixXQUFXK0osWUFBWTNNO1FBQzdCLElBQUk1SCxXQUFXNkosT0FBTyxDQUFDcUMsS0FBSyxDQUFDdEUsU0FBUztZQUNwQyxNQUFNNE0sV0FBV0YsV0FBVyxDQUFDeFMsWUFBWSxDQUFDcUUsT0FBTyxDQUFDcUUsU0FBUztZQUMzRCxNQUFNdkUsUUFBUXNMLE1BQU1qWixRQUFRLEVBQUUsQ0FBQ3dKLFlBQVksQ0FBQ3FFLE9BQU8sQ0FBQ3FFLFNBQVM7WUFDN0QsSUFBSSxDQUFDZ0ssWUFBWXZPLE9BQU87Z0JBQ3RCd08sYUFBYTdNLE9BQU9qUCxJQUFJLENBQUNSLEdBQUcsQ0FBQzZJLFlBQVksRUFBRTRHLE9BQU9qUCxJQUFJLENBQUNSLEdBQUcsQ0FBQ2tLLFlBQVksRUFBRW1JLFVBQVUrRyxPQUFPM0osT0FBT2pQLElBQUksQ0FBQ2dLLFNBQVM7WUFDakg7UUFDRixPQUFPLElBQUkxQyxjQUFjNEosT0FBTyxDQUFDcUMsS0FBSyxDQUFDdEUsU0FBUztZQUM5QyxNQUFNM0IsUUFBUXNMLE1BQU1qWixRQUFRLEVBQUUsQ0FBQ3dKLFlBQVksQ0FBQzJJLFNBQVMsQ0FBQ0QsU0FBUztZQUMvRCxJQUFJdkUsT0FBTztnQkFDVHdPLGFBQWE3TSxPQUFPalAsSUFBSSxDQUFDUixHQUFHLENBQUM2SSxZQUFZLEVBQUU0RyxPQUFPalAsSUFBSSxDQUFDUixHQUFHLENBQUNrSyxZQUFZLEVBQUVtSSxVQUFVK0csT0FBTzNKLE9BQU9qUCxJQUFJLENBQUNnSyxTQUFTO1lBQ2pIO1FBQ0YsT0FBTyxJQUFJeVIsaUJBQWlCeE0sU0FBUztZQUNuQyxNQUFNOE0sWUFBWUwsWUFBWSxDQUFDN0osU0FBUztZQUN4QyxJQUFJa0ssV0FBV0MsZUFBZTtnQkFDNUJELFVBQVVDLGFBQWEsQ0FBQztvQkFDdEJ6WixNQUFNME0sT0FBT00sT0FBTztvQkFDcEJ2UCxNQUFNaVAsT0FBT2pQLElBQUksQ0FBQ21OLGFBQWE7Z0JBQ2pDO2dCQUNBLE9BQU80TyxVQUFVQyxhQUFhO1lBQ2hDO1FBQ0YsT0FBTyxJQUFJdmMsSUFBSXFJLGVBQWUsQ0FBQzZJLGlCQUFpQixDQUFDNEMsS0FBSyxDQUFDdEUsV0FBV3hQLElBQUlxSSxlQUFlLENBQUNGLG9CQUFvQixDQUFDMkwsS0FBSyxDQUFDdEUsU0FBUztZQUN4SCxNQUFNOE0sWUFBWUwsWUFBWSxDQUFDN0osU0FBUztZQUN4QyxJQUFJa0ssV0FBVztnQkFDYixPQUFPTCxZQUFZLENBQUM3SixTQUFTO2dCQUM3QmtLLFVBQVVFLGlCQUFpQjtZQUM3QjtRQUNGLE9BQU8sSUFBSXhjLElBQUl3TSxJQUFJLENBQUNzRSxhQUFhLENBQUNnRCxLQUFLLENBQUN0RSxTQUFTO1lBQy9DLEtBQUssTUFBTSxDQUFDaU4sV0FBV0gsVUFBVSxJQUFJOWUsT0FBT29CLE9BQU8sQ0FBQ3FkLGNBQWU7Z0JBQ2pFLE9BQU9BLFlBQVksQ0FBQ1EsVUFBVTtnQkFDOUJILFVBQVVFLGlCQUFpQjtZQUM3QjtRQUNGO0lBQ0Y7SUFDQSxTQUFTTCxZQUFZM00sTUFBTTtRQUN6QixJQUFJc00sYUFBYXRNLFNBQ2YsT0FBT0EsT0FBT2pQLElBQUksQ0FBQ1IsR0FBRyxDQUFDaUosYUFBYTtRQUN0QyxJQUFJK1MsZ0JBQWdCdk0sU0FBUztZQUMzQixPQUFPQSxPQUFPalAsSUFBSSxDQUFDUixHQUFHLENBQUNrTCxhQUFhLElBQUl1RSxPQUFPalAsSUFBSSxDQUFDZ0ssU0FBUztRQUMvRDtRQUNBLElBQUl2SyxJQUFJcUksZUFBZSxDQUFDNkksaUJBQWlCLENBQUM0QyxLQUFLLENBQUN0RSxTQUM5QyxPQUFPQSxPQUFPTSxPQUFPLENBQUM5RyxhQUFhO1FBQ3JDLElBQUloSixJQUFJcUksZUFBZSxDQUFDRixvQkFBb0IsQ0FBQzJMLEtBQUssQ0FBQ3RFLFNBQ2pELE9BQU9hLG9CQUFvQmIsT0FBT00sT0FBTztRQUMzQyxPQUFPO0lBQ1Q7SUFDQSxTQUFTdU0sYUFBYXpULFlBQVksRUFBRXFCLFlBQVksRUFBRWpCLGFBQWEsRUFBRW1RLEtBQUssRUFBRTVPLFNBQVM7UUFDL0UsTUFBTXpCLHFCQUFxQmhCLFFBQVFpQixtQkFBbUIsQ0FBQ0gsYUFBYTtRQUNwRSxNQUFNOFQsb0JBQW9CNVQsb0JBQW9CNFQ7UUFDOUMsSUFBSSxDQUFDQSxtQkFDSDtRQUNGLElBQUlKLFlBQVksQ0FBQztRQUNqQixNQUFNRSxvQkFBb0IsSUFBSWphLFFBQVEsQ0FBQ21CO1lBQ3JDNFksVUFBVUUsaUJBQWlCLEdBQUc5WTtRQUNoQztRQUNBLE1BQU1pWixrQkFBa0JwYSxRQUFRcWEsSUFBSSxDQUFDO1lBQUMsSUFBSXJhLFFBQVEsQ0FBQ21CO2dCQUNqRDRZLFVBQVVDLGFBQWEsR0FBRzdZO1lBQzVCO1lBQUk4WSxrQkFBa0I5WixJQUFJLENBQUM7Z0JBQ3pCLE1BQU1rWjtZQUNSO1NBQUc7UUFDSGUsZ0JBQWdCclYsS0FBSyxDQUFDLEtBQ3RCO1FBQ0EyVSxZQUFZLENBQUNqVCxjQUFjLEdBQUdzVDtRQUM5QixNQUFNcFMsV0FBV2xLLElBQUltSyxTQUFTLENBQUN2QixhQUFhLENBQUN3QixNQUFNLENBQUN0QixtQkFBbUJ4SSxJQUFJLEtBQUssUUFBUSxTQUFTLE1BQUsySixlQUFlakI7UUFDckgsTUFBTTdJLFFBQVFnWixNQUFNNVQsUUFBUSxDQUFDLENBQUNmLEdBQUdDLElBQUlvWSxTQUFXQTtRQUNoRCxNQUFNQyxlQUFlO1lBQ25CLEdBQUczRCxLQUFLO1lBQ1I0RCxlQUFlLElBQU03UyxTQUFTaVAsTUFBTWpaLFFBQVE7WUFDNUNxSztZQUNBcEs7WUFDQTZjLGtCQUFrQmxVLG1CQUFtQnhJLElBQUksS0FBSyxRQUFRLFNBQVMsTUFBSyxDQUFDOEwsZUFBaUIrTSxNQUFNNVQsUUFBUSxDQUFDdkYsSUFBSXdNLElBQUksQ0FBQ0wsZUFBZSxDQUFDdkQsY0FBY3FCLGNBQWNtQyxpQkFBaUIsS0FBSztZQUNoTHVRO1lBQ0FIO1FBQ0Y7UUFDQSxNQUFNUyxpQkFBaUJQLGtCQUFrQnpTLGNBQWM2UztRQUN2RHZhLFFBQVFtQixPQUFPLENBQUN1WixnQkFBZ0IzVixLQUFLLENBQUMsQ0FBQ3hGO1lBQ3JDLElBQUlBLE1BQU04WixvQkFDUjtZQUNGLE1BQU05WjtRQUNSO0lBQ0Y7SUFDQSxPQUFPb1g7QUFDVDtBQUVBLG1EQUFtRDtBQUNuRCxJQUFJZ0UsNkJBQTZCLENBQUMsRUFDaENsZCxHQUFHLEVBQ0g4SCxPQUFPLEVBQ1BGLFVBQVUsRUFDVkMsYUFBYSxFQUNkO0lBQ0MsTUFBTXNWLGlCQUFpQjNnQiwyREFBU0EsQ0FBQ29MLFlBQVlDO0lBQzdDLE1BQU11VixrQkFBa0IzZ0IsNERBQVVBLENBQUNtTCxZQUFZQztJQUMvQyxNQUFNd1Ysb0JBQW9CM2dCLDZEQUFXQSxDQUFDa0wsWUFBWUM7SUFDbEQsTUFBTW9VLGVBQWUsQ0FBQztJQUN0QixNQUFNL0MsVUFBVSxDQUFDMUosUUFBUTJKO1FBQ3ZCLElBQUlnRSxlQUFlM04sU0FBUztZQUMxQixNQUFNLEVBQ0pqRixTQUFTLEVBQ1R4SyxLQUFLLEVBQ0g2SSxZQUFZLEVBQ1pxQixZQUFZLEVBQ2IsRUFDRixHQUFHdUYsT0FBT2pQLElBQUk7WUFDZixNQUFNdUkscUJBQXFCaEIsUUFBUWlCLG1CQUFtQixDQUFDSCxhQUFhO1lBQ3BFLE1BQU0wVSxpQkFBaUJ4VSxvQkFBb0J3VTtZQUMzQyxJQUFJQSxnQkFBZ0I7Z0JBQ2xCLE1BQU1oQixZQUFZLENBQUM7Z0JBQ25CLE1BQU1pQixpQkFBaUIsSUFBSWhiLFFBQVEsQ0FBQ21CLFNBQVM4WjtvQkFDM0NsQixVQUFVNVksT0FBTyxHQUFHQTtvQkFDcEI0WSxVQUFVa0IsTUFBTSxHQUFHQTtnQkFDckI7Z0JBQ0FELGVBQWVqVyxLQUFLLENBQUMsS0FDckI7Z0JBQ0EyVSxZQUFZLENBQUMxUixVQUFVLEdBQUcrUjtnQkFDMUIsTUFBTXBTLFdBQVdsSyxJQUFJbUssU0FBUyxDQUFDdkIsYUFBYSxDQUFDd0IsTUFBTSxDQUFDdEIsbUJBQW1CeEksSUFBSSxLQUFLLFFBQVEsU0FBUyxNQUFLMkosZUFBZU07Z0JBQ3JILE1BQU1wSyxRQUFRZ1osTUFBTTVULFFBQVEsQ0FBQyxDQUFDZixHQUFHQyxJQUFJb1ksU0FBV0E7Z0JBQ2hELE1BQU1DLGVBQWU7b0JBQ25CLEdBQUczRCxLQUFLO29CQUNSNEQsZUFBZSxJQUFNN1MsU0FBU2lQLE1BQU1qWixRQUFRO29CQUM1Q3FLO29CQUNBcEs7b0JBQ0E2YyxrQkFBa0JsVSxtQkFBbUJ4SSxJQUFJLEtBQUssUUFBUSxTQUFTLE1BQUssQ0FBQzhMLGVBQWlCK00sTUFBTTVULFFBQVEsQ0FBQ3ZGLElBQUl3TSxJQUFJLENBQUNMLGVBQWUsQ0FBQ3ZELGNBQWNxQixjQUFjbUMsaUJBQWlCLEtBQUs7b0JBQ2hMbVI7Z0JBQ0Y7Z0JBQ0FELGVBQWVyVCxjQUFjNlM7WUFDL0I7UUFDRixPQUFPLElBQUlPLGtCQUFrQjdOLFNBQVM7WUFDcEMsTUFBTSxFQUNKakYsU0FBUyxFQUNUbUQsYUFBYSxFQUNkLEdBQUc4QixPQUFPalAsSUFBSTtZQUNmMGIsWUFBWSxDQUFDMVIsVUFBVSxFQUFFN0csUUFBUTtnQkFDL0JaLE1BQU0wTSxPQUFPTSxPQUFPO2dCQUNwQnZQLE1BQU1tTjtZQUNSO1lBQ0EsT0FBT3VPLFlBQVksQ0FBQzFSLFVBQVU7UUFDaEMsT0FBTyxJQUFJNlMsZ0JBQWdCNU4sU0FBUztZQUNsQyxNQUFNLEVBQ0pqRixTQUFTLEVBQ1RrVCxpQkFBaUIsRUFDakIvUCxhQUFhLEVBQ2QsR0FBRzhCLE9BQU9qUCxJQUFJO1lBQ2YwYixZQUFZLENBQUMxUixVQUFVLEVBQUVpVCxPQUFPO2dCQUM5QnpiLE9BQU95TixPQUFPTSxPQUFPLElBQUlOLE9BQU96TixLQUFLO2dCQUNyQzJiLGtCQUFrQixDQUFDRDtnQkFDbkJsZCxNQUFNbU47WUFDUjtZQUNBLE9BQU91TyxZQUFZLENBQUMxUixVQUFVO1FBQ2hDO0lBQ0Y7SUFDQSxPQUFPMk87QUFDVDtBQUVBLGtEQUFrRDtBQUNsRCxJQUFJeUUsdUJBQXVCLENBQUMsRUFDMUIzZCxHQUFHLEVBQ0g4SCxTQUFTLEVBQ1A2SSxNQUFNLEVBQ1AsRUFDRGpILFdBQVcsRUFDWjtJQUNDLE9BQU8sQ0FBQzhGLFFBQVEySjtRQUNkLElBQUluWixJQUFJd00sSUFBSSxDQUFDc0UsYUFBYSxDQUFDZ0QsS0FBSyxDQUFDdEUsU0FBUztZQUN4QzJKLE1BQU01VCxRQUFRLENBQUN2RixJQUFJcUksZUFBZSxDQUFDc0wsb0JBQW9CLENBQUNoRDtRQUMxRDtRQUNBLElBQUksT0FBT3RILFlBQVksZUFBZUEsa0JBQXlCLGVBQWU7WUFDNUUsSUFBSXJKLElBQUlxSSxlQUFlLENBQUNzTCxvQkFBb0IsQ0FBQ0csS0FBSyxDQUFDdEUsV0FBV0EsT0FBT00sT0FBTyxLQUFLYSxVQUFVd0ksTUFBTWpaLFFBQVEsRUFBRSxDQUFDd0osWUFBWSxFQUFFL0ksUUFBUWdULHlCQUF5QixZQUFZO2dCQUNySzlULFFBQVFDLElBQUksQ0FBQyxDQUFDLHNFQUFzRSxFQUFFNEosWUFBWTs0RkFDZCxFQUFFQSxnQkFBZ0IsUUFBUSxDQUFDOzZGQUMxQixDQUFDLEdBQUcsR0FBRyxDQUFDO1lBQy9GO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsaURBQWlEO0FBQ2lCO0FBQ2xFLElBQUltVSw2QkFBNkIsQ0FBQyxFQUNoQzdkLEdBQUcsRUFDSDRILFVBQVUsRUFDVmtSLGFBQWEsRUFDZDtJQUNDLE1BQU1nRixzQkFBc0IsQ0FBQyxFQUFFOWQsSUFBSTBKLFdBQVcsQ0FBQyxjQUFjLENBQUM7SUFDOUQsSUFBSXFVLHdCQUF3QjtJQUM1QixJQUFJQyxrQkFBa0I7SUFDdEIsTUFBTSxFQUNKNVYseUJBQXlCLEVBQ3pCRixzQkFBc0IsRUFDdkIsR0FBR2xJLElBQUlxSSxlQUFlO0lBQ3ZCLE1BQU00Viw4QkFBOEIsQ0FBQ0MsY0FBYzFPO1FBQ2pELElBQUlwSCwwQkFBMEIwTCxLQUFLLENBQUN0RSxTQUFTO1lBQzNDLE1BQU0sRUFDSnhHLGFBQWEsRUFDYnVCLFNBQVMsRUFDVDdGLE9BQU8sRUFDUixHQUFHOEssT0FBT00sT0FBTztZQUNsQixJQUFJb08sY0FBYyxDQUFDbFYsY0FBYyxFQUFFLENBQUN1QixVQUFVLEVBQUU7Z0JBQzlDMlQsWUFBWSxDQUFDbFYsY0FBYyxDQUFDdUIsVUFBVSxHQUFHN0Y7WUFDM0M7WUFDQSxPQUFPO1FBQ1Q7UUFDQSxJQUFJd0QsdUJBQXVCNEwsS0FBSyxDQUFDdEUsU0FBUztZQUN4QyxNQUFNLEVBQ0p4RyxhQUFhLEVBQ2J1QixTQUFTLEVBQ1YsR0FBR2lGLE9BQU9NLE9BQU87WUFDbEIsSUFBSW9PLFlBQVksQ0FBQ2xWLGNBQWMsRUFBRTtnQkFDL0IsT0FBT2tWLFlBQVksQ0FBQ2xWLGNBQWMsQ0FBQ3VCLFVBQVU7WUFDL0M7WUFDQSxPQUFPO1FBQ1Q7UUFDQSxJQUFJdkssSUFBSXFJLGVBQWUsQ0FBQzZJLGlCQUFpQixDQUFDNEMsS0FBSyxDQUFDdEUsU0FBUztZQUN2RCxPQUFPME8sWUFBWSxDQUFDMU8sT0FBT00sT0FBTyxDQUFDOUcsYUFBYSxDQUFDO1lBQ2pELE9BQU87UUFDVDtRQUNBLElBQUlwQixXQUFXNkosT0FBTyxDQUFDcUMsS0FBSyxDQUFDdEUsU0FBUztZQUNwQyxNQUFNLEVBQ0pqUCxNQUFNLEVBQ0pSLEdBQUcsRUFDSHdLLFNBQVMsRUFDVixFQUNGLEdBQUdpRjtZQUNKLE1BQU1ZLFdBQVc4TixZQUFZLENBQUNuZSxJQUFJaUosYUFBYSxDQUFDLEtBQUssQ0FBQztZQUN0RG9ILFFBQVEsQ0FBQyxDQUFDLEVBQUU3RixVQUFVLFFBQVEsQ0FBQyxDQUFDLEdBQUcsQ0FBQztZQUNwQyxJQUFJeEssSUFBSTZKLFNBQVMsRUFBRTtnQkFDakJ3RyxRQUFRLENBQUM3RixVQUFVLEdBQUd4SyxJQUFJK0osbUJBQW1CLElBQUlzRyxRQUFRLENBQUM3RixVQUFVLElBQUksQ0FBQztZQUMzRTtZQUNBLE9BQU87UUFDVDtRQUNBLElBQUk0VCxVQUFVO1FBQ2QsSUFBSXZXLFdBQVcrSixTQUFTLENBQUNtQyxLQUFLLENBQUN0RSxXQUFXNUgsV0FBV29LLFFBQVEsQ0FBQzhCLEtBQUssQ0FBQ3RFLFNBQVM7WUFDM0UsTUFBTTNCLFFBQVFxUSxZQUFZLENBQUMxTyxPQUFPalAsSUFBSSxDQUFDUixHQUFHLENBQUNpSixhQUFhLENBQUMsSUFBSSxDQUFDO1lBQzlELE1BQU1sTCxNQUFNLENBQUMsRUFBRTBSLE9BQU9qUCxJQUFJLENBQUNnSyxTQUFTLENBQUMsUUFBUSxDQUFDO1lBQzlDNFQsWUFBWSxDQUFDLENBQUN0USxLQUFLLENBQUMvUCxJQUFJO1lBQ3hCLE9BQU8rUCxLQUFLLENBQUMvUCxJQUFJO1FBQ25CO1FBQ0EsSUFBSThKLFdBQVdvSyxRQUFRLENBQUM4QixLQUFLLENBQUN0RSxTQUFTO1lBQ3JDLE1BQU0sRUFDSmpQLE1BQU0sRUFDSmdPLFNBQVMsRUFDVHhPLEdBQUcsRUFDSHdLLFNBQVMsRUFDVixFQUNGLEdBQUdpRjtZQUNKLElBQUlqQixhQUFheE8sSUFBSTZKLFNBQVMsRUFBRTtnQkFDOUIsTUFBTXdHLFdBQVc4TixZQUFZLENBQUNuZSxJQUFJaUosYUFBYSxDQUFDLEtBQUssQ0FBQztnQkFDdERvSCxRQUFRLENBQUM3RixVQUFVLEdBQUd4SyxJQUFJK0osbUJBQW1CLElBQUlzRyxRQUFRLENBQUM3RixVQUFVLElBQUksQ0FBQztnQkFDekU0VCxVQUFVO1lBQ1o7UUFDRjtRQUNBLE9BQU9BO0lBQ1Q7SUFDQSxNQUFNQyxtQkFBbUIsSUFBTXRGLGNBQWNFLG9CQUFvQjtJQUNqRSxNQUFNcUYsdUJBQXVCLENBQUNyVjtRQUM1QixNQUFNNkssZ0JBQWdCdUs7UUFDdEIsTUFBTUUsMkJBQTJCekssYUFBYSxDQUFDN0ssY0FBYyxJQUFJLENBQUM7UUFDbEUsT0FBT2hDLGdCQUFnQnNYO0lBQ3pCO0lBQ0EsTUFBTUMsc0JBQXNCLENBQUN2VixlQUFldUI7UUFDMUMsTUFBTXNKLGdCQUFnQnVLO1FBQ3RCLE9BQU8sQ0FBQyxDQUFDdkssZUFBZSxDQUFDN0ssY0FBYyxFQUFFLENBQUN1QixVQUFVO0lBQ3REO0lBQ0EsTUFBTWlVLHdCQUF3QjtRQUM1Qko7UUFDQUM7UUFDQUU7SUFDRjtJQUNBLE9BQU8sQ0FBQy9PLFFBQVEySjtRQUNkLElBQUksQ0FBQzRFLHVCQUF1QjtZQUMxQkEsd0JBQXdCOWMsS0FBSzhCLEtBQUssQ0FBQzlCLEtBQUtDLFNBQVMsQ0FBQzRYLGNBQWNFLG9CQUFvQjtRQUN0RjtRQUNBLElBQUloWixJQUFJd00sSUFBSSxDQUFDc0UsYUFBYSxDQUFDZ0QsS0FBSyxDQUFDdEUsU0FBUztZQUN4Q3VPLHdCQUF3QmpGLGNBQWNFLG9CQUFvQixHQUFHLENBQUM7WUFDOURnRixrQkFBa0I7WUFDbEIsT0FBTztnQkFBQztnQkFBTTthQUFNO1FBQ3RCO1FBQ0EsSUFBSWhlLElBQUlxSSxlQUFlLENBQUNtQiw2QkFBNkIsQ0FBQ3NLLEtBQUssQ0FBQ3RFLFNBQVM7WUFDbkUsT0FBTztnQkFBQztnQkFBT2dQO2FBQXNCO1FBQ3ZDO1FBQ0EsTUFBTUMsWUFBWVIsNEJBQTRCbkYsY0FBY0Usb0JBQW9CLEVBQUV4SjtRQUNsRixJQUFJa1AsdUJBQXVCO1FBQzNCLElBQUlELFdBQVc7WUFDYixJQUFJLENBQUNULGlCQUFpQjtnQkFDcEJBLGtCQUFrQnBjLFdBQVc7b0JBQzNCLE1BQU0rYyxtQkFBbUIxZCxLQUFLOEIsS0FBSyxDQUFDOUIsS0FBS0MsU0FBUyxDQUFDNFgsY0FBY0Usb0JBQW9CO29CQUNyRixNQUFNLEdBQUdwTixRQUFRLEdBQUdnUyx5REFBbUJBLENBQUNHLHVCQUF1QixJQUFNWTtvQkFDckV4RixNQUFNeUYsSUFBSSxDQUFDNWUsSUFBSXFJLGVBQWUsQ0FBQ2tMLG9CQUFvQixDQUFDM0g7b0JBQ3BEbVMsd0JBQXdCWTtvQkFDeEJYLGtCQUFrQjtnQkFDcEIsR0FBRztZQUNMO1lBQ0EsTUFBTWEsNEJBQTRCLE9BQU9yUCxPQUFPbFAsSUFBSSxJQUFJLFlBQVksQ0FBQyxDQUFDa1AsT0FBT2xQLElBQUksQ0FBQ2pGLFVBQVUsQ0FBQ3lpQjtZQUM3RixNQUFNZ0IsaUNBQWlDbFgsV0FBV29LLFFBQVEsQ0FBQzhCLEtBQUssQ0FBQ3RFLFdBQVdBLE9BQU9qUCxJQUFJLENBQUNnTyxTQUFTLElBQUksQ0FBQyxDQUFDaUIsT0FBT2pQLElBQUksQ0FBQ1IsR0FBRyxDQUFDNkosU0FBUztZQUNoSThVLHVCQUF1QixDQUFDRyw2QkFBNkIsQ0FBQ0M7UUFDeEQ7UUFDQSxPQUFPO1lBQUNKO1lBQXNCO1NBQU07SUFDdEM7QUFDRjtBQUVBLDBDQUEwQztBQUMxQyxTQUFTSyxnQkFBZ0JDLEtBQUs7SUFDNUIsTUFBTSxFQUNKdFYsV0FBVyxFQUNYOUIsVUFBVSxFQUNWNUgsR0FBRyxFQUNIOEgsT0FBTyxFQUNSLEdBQUdrWDtJQUNKLE1BQU0sRUFDSnJPLE1BQU0sRUFDUCxHQUFHN0k7SUFDSixNQUFNZ0wsVUFBVTtRQUNkbUgsZ0JBQWdCbGUsOERBQVlBLENBQUMsQ0FBQyxFQUFFMk4sWUFBWSxlQUFlLENBQUM7SUFDOUQ7SUFDQSxNQUFNdVYsdUJBQXVCLENBQUN6UCxTQUFXQSxPQUFPbFAsSUFBSSxDQUFDakYsVUFBVSxDQUFDLENBQUMsRUFBRXFPLFlBQVksQ0FBQyxDQUFDO0lBQ2pGLE1BQU13VixrQkFBa0I7UUFBQ3ZCO1FBQXNCOUU7UUFBNkJlO1FBQWdDVTtRQUFxQnVCO1FBQTRCcUI7S0FBMkI7SUFDeEwsTUFBTWlDLGFBQWEsQ0FBQ2hHO1FBQ2xCLElBQUlpRyxlQUFlO1FBQ25CLElBQUl0RyxnQkFBZ0I7WUFDbEJFLHNCQUFzQixDQUFDO1FBQ3pCO1FBQ0EsTUFBTXFHLGNBQWM7WUFDbEIsR0FBR0wsS0FBSztZQUNSbEc7WUFDQWU7WUFDQW9GO1FBQ0Y7UUFDQSxNQUFNSyxXQUFXSixnQkFBZ0J4WSxHQUFHLENBQUMsQ0FBQzZZLFFBQVVBLE1BQU1GO1FBQ3RELE1BQU1HLHdCQUF3QjNCLDJCQUEyQndCO1FBQ3pELE1BQU1JLHNCQUFzQm5FLHdCQUF3QitEO1FBQ3BELE9BQU8sQ0FBQ1Q7WUFDTixPQUFPLENBQUNwUDtnQkFDTixJQUFJLENBQUNqVCwwREFBUUEsQ0FBQ2lULFNBQVM7b0JBQ3JCLE9BQU9vUCxLQUFLcFA7Z0JBQ2Q7Z0JBQ0EsSUFBSSxDQUFDNFAsY0FBYztvQkFDakJBLGVBQWU7b0JBQ2ZqRyxNQUFNNVQsUUFBUSxDQUFDdkYsSUFBSXFJLGVBQWUsQ0FBQ3NMLG9CQUFvQixDQUFDaEQ7Z0JBQzFEO2dCQUNBLE1BQU0rTyxnQkFBZ0I7b0JBQ3BCLEdBQUd2RyxLQUFLO29CQUNSeUY7Z0JBQ0Y7Z0JBQ0EsTUFBTTFDLGNBQWMvQyxNQUFNalosUUFBUTtnQkFDbEMsTUFBTSxDQUFDd2Usc0JBQXNCaUIsb0JBQW9CLEdBQUdILHNCQUFzQmhRLFFBQVFrUSxlQUFleEQ7Z0JBQ2pHLElBQUl2WTtnQkFDSixJQUFJK2Esc0JBQXNCO29CQUN4Qi9hLE1BQU1pYixLQUFLcFA7Z0JBQ2IsT0FBTztvQkFDTDdMLE1BQU1nYztnQkFDUjtnQkFDQSxJQUFJLENBQUMsQ0FBQ3hHLE1BQU1qWixRQUFRLEVBQUUsQ0FBQ3dKLFlBQVksRUFBRTtvQkFDbkMrVixvQkFBb0JqUSxRQUFRa1EsZUFBZXhEO29CQUMzQyxJQUFJK0MscUJBQXFCelAsV0FBVzFILFFBQVErSSxrQkFBa0IsQ0FBQ3JCLFNBQVM7d0JBQ3RFLEtBQUssSUFBSTBKLFdBQVdvRyxTQUFVOzRCQUM1QnBHLFFBQVExSixRQUFRa1EsZUFBZXhEO3dCQUNqQztvQkFDRjtnQkFDRjtnQkFDQSxPQUFPdlk7WUFDVDtRQUNGO0lBQ0Y7SUFDQSxPQUFPO1FBQ0x3YjtRQUNBck07SUFDRjtJQUNBLFNBQVMrRyxhQUFhL0QsYUFBYSxFQUFFOU0sYUFBYSxFQUFFNFcsV0FBVyxDQUFDLENBQUM7UUFDL0QsT0FBT2hZLFdBQVc7WUFDaEJ0SCxNQUFNO1lBQ05zSSxjQUFja04sY0FBY2xOLFlBQVk7WUFDeENxQixjQUFjNkwsY0FBYzdMLFlBQVk7WUFDeENMLFdBQVc7WUFDWEMsY0FBYztZQUNkYjtZQUNBLEdBQUc0VyxRQUFRO1FBQ2I7SUFDRjtBQUNGO0FBRUEseUJBQXlCO0FBQ3pCLFNBQVNDLFdBQVdsaEIsQ0FBQyxHQUNyQjtBQUNBLFNBQVNtaEIsV0FBV0MsTUFBTSxFQUFFLEdBQUcvaEIsSUFBSTtJQUNqQyxPQUFPUixPQUFPcUcsTUFBTSxDQUFDa2MsV0FBVy9oQjtBQUNsQztBQUVBLDJCQUEyQjtBQUNXO0FBQ3RDLElBQUlpaUIsaUJBQWlCLGFBQWEsR0FBR3pZO0FBQ3JDLElBQUkwWSxhQUFhLENBQUMsRUFDaEJqa0IsZ0JBQWdCb1ksa0JBQWtCcFksb0RBQWMsRUFDakQsR0FBRyxDQUFDLENBQUMsR0FBTTtRQUNWK1UsTUFBTWlQO1FBQ04vSCxNQUFLbFksR0FBRyxFQUFFLEVBQ1JpRSxTQUFTLEVBQ1R1VCxRQUFRLEVBQ1I5TixXQUFXLEVBQ1gvQixrQkFBa0IsRUFDbEJvUCxpQkFBaUIsRUFDakI5SSx5QkFBeUIsRUFDekIrSSxjQUFjLEVBQ2RDLGtCQUFrQixFQUNsQkMsb0JBQW9CLEVBQ3JCLEVBQUVwUCxPQUFPO1lBQ1JrWSxvREFBYUE7WUFDYkgsV0FBV2xZO1lBQ1gsTUFBTStELGdCQUFnQixDQUFDK0o7Z0JBQ3JCLElBQUksT0FBT3BNLFlBQVksZUFBZUEsa0JBQXlCLGVBQWU7b0JBQzVFLElBQUksQ0FBQ21PLFNBQVMzRSxRQUFRLENBQUM0QyxJQUFJblYsSUFBSSxHQUFHO3dCQUNoQ1QsUUFBUWtDLEtBQUssQ0FBQyxDQUFDLFVBQVUsRUFBRTBULElBQUluVixJQUFJLENBQUMsOENBQThDLENBQUM7b0JBQ3JGO2dCQUNGO2dCQUNBLE9BQU9tVjtZQUNUO1lBQ0FqWSxPQUFPcUcsTUFBTSxDQUFDN0QsS0FBSztnQkFDakIwSjtnQkFDQVMsV0FBVyxDQUFDO2dCQUNaOUIsaUJBQWlCO29CQUNmbEQ7b0JBQ0FDO29CQUNBSDtvQkFDQUM7Z0JBQ0Y7Z0JBQ0FzSCxNQUFNLENBQUM7WUFDVDtZQUNBLE1BQU0sRUFDSjVFLFVBQVUsRUFDVkMsYUFBYSxFQUNiOEQsY0FBYyxFQUNkUSxlQUFlLEVBQ2ZTLGVBQWUsRUFDZm1DLFFBQVEsRUFDUlUsc0JBQXNCLEVBQ3ZCLEdBQUdoRSxZQUFZO2dCQUNkeEg7Z0JBQ0F5RjtnQkFDQTVCO2dCQUNBOUg7Z0JBQ0EySDtnQkFDQStEO1lBQ0Y7WUFDQSxNQUFNLEVBQ0p5RixPQUFPLEVBQ1AyQixTQUFTcU4sWUFBWSxFQUN0QixHQUFHMVAsV0FBVztnQkFDYjNJO2dCQUNBRjtnQkFDQUM7Z0JBQ0E2QjtnQkFDQWdDO2dCQUNBL0ssUUFBUTtvQkFDTnFXO29CQUNBQztvQkFDQWhKO29CQUNBOEk7b0JBQ0FyTjtvQkFDQXdOO2dCQUNGO1lBQ0Y7WUFDQTRJLFdBQVc5ZixJQUFJd00sSUFBSSxFQUFFO2dCQUNuQmI7Z0JBQ0FRO2dCQUNBUztnQkFDQW1DO2dCQUNBK0IsZUFBZXFQLGFBQWFyUCxhQUFhO1lBQzNDO1lBQ0FnUCxXQUFXOWYsSUFBSXFJLGVBQWUsRUFBRThYO1lBQ2hDLE1BQU0sRUFDSmhCLFVBQVUsRUFDVnJNLFNBQVNzTixpQkFBaUIsRUFDM0IsR0FBR3JCLGdCQUFnQjtnQkFDbEJyVjtnQkFDQTVCO2dCQUNBRjtnQkFDQUM7Z0JBQ0E3SDtnQkFDQTBMO1lBQ0Y7WUFDQW9VLFdBQVc5ZixJQUFJd00sSUFBSSxFQUFFNFQ7WUFDckJOLFdBQVc5ZixLQUFLO2dCQUNkbVI7Z0JBQ0FnTztZQUNGO1lBQ0EsTUFBTSxFQUNKM0ssa0JBQWtCLEVBQ2xCQyxxQkFBcUIsRUFDckJDLG1CQUFtQixFQUNuQkMsd0JBQXdCLEVBQ3pCLEdBQUdQLGVBQWU7Z0JBQ2pCek07Z0JBQ0ErQjtnQkFDQXpOLGdCQUFnQm9ZO1lBQ2xCO1lBQ0F5TCxXQUFXOWYsSUFBSXdNLElBQUksRUFBRTtnQkFDbkJrSTtnQkFDQUM7WUFDRjtZQUNBLE1BQU0sRUFDSnJNLGtCQUFrQixFQUNsQkMscUJBQXFCLEVBQ3JCRSx1QkFBdUIsRUFDdkJFLHdCQUF3QixFQUN4QkQsc0JBQXNCLEVBQ3RCRixvQkFBb0IsRUFDckIsR0FBR2QsY0FBYztnQkFDaEJFO2dCQUNBQztnQkFDQTdIO2dCQUNBMkg7Z0JBQ0FHO1lBQ0Y7WUFDQWdZLFdBQVc5ZixJQUFJd00sSUFBSSxFQUFFO2dCQUNuQi9EO2dCQUNBRTtnQkFDQUg7Z0JBQ0FFO1lBQ0Y7WUFDQSxPQUFPO2dCQUNMc0ksTUFBTWlQO2dCQUNOekgsZ0JBQWU1UCxZQUFZLEVBQUUwUCxVQUFVO29CQUNyQyxNQUFNK0gsU0FBU3JnQjtvQkFDZnFnQixPQUFPbFcsU0FBUyxDQUFDdkIsYUFBYSxLQUFLLENBQUM7b0JBQ3BDLElBQUl6QyxrQkFBa0JtUyxhQUFhO3dCQUNqQ3dILFdBQVdPLE9BQU9sVyxTQUFTLENBQUN2QixhQUFhLEVBQUU7NEJBQ3pDb0ksTUFBTXBJOzRCQUNOd0IsUUFBUW9LLG1CQUFtQjVMLGNBQWMwUDs0QkFDekN6TCxVQUFVdkUsbUJBQW1CTSxjQUFjMFA7d0JBQzdDLEdBQUc3SSx1QkFBdUI3SCxZQUFZZ0I7b0JBQ3hDLE9BQU8sSUFBSXhDLHFCQUFxQmtTLGFBQWE7d0JBQzNDd0gsV0FBV08sT0FBT2xXLFNBQVMsQ0FBQ3ZCLGFBQWEsRUFBRTs0QkFDekNvSSxNQUFNcEk7NEJBQ053QixRQUFRcUs7NEJBQ1I1SCxVQUFVdEUsc0JBQXNCSzt3QkFDbEMsR0FBRzZHLHVCQUF1QjVILGVBQWVlO29CQUMzQztnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtBQUVBLDBCQUEwQjtBQUMxQixJQUFJMFgsWUFBWSxhQUFhLEdBQUczSixlQUFldUo7QUFjN0MsQ0FDRiw2Q0FBNkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbmNob3JzLmluX2Fzc2lnbm1lbnQvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L3F1ZXJ5L3J0ay1xdWVyeS5tb2Rlcm4ubWpzPzc3OTMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3F1ZXJ5L2NvcmUvYXBpU3RhdGUudHNcbnZhciBRdWVyeVN0YXR1cyA9IC8qIEBfX1BVUkVfXyAqLyAoKFF1ZXJ5U3RhdHVzMikgPT4ge1xuICBRdWVyeVN0YXR1czJbXCJ1bmluaXRpYWxpemVkXCJdID0gXCJ1bmluaXRpYWxpemVkXCI7XG4gIFF1ZXJ5U3RhdHVzMltcInBlbmRpbmdcIl0gPSBcInBlbmRpbmdcIjtcbiAgUXVlcnlTdGF0dXMyW1wiZnVsZmlsbGVkXCJdID0gXCJmdWxmaWxsZWRcIjtcbiAgUXVlcnlTdGF0dXMyW1wicmVqZWN0ZWRcIl0gPSBcInJlamVjdGVkXCI7XG4gIHJldHVybiBRdWVyeVN0YXR1czI7XG59KShRdWVyeVN0YXR1cyB8fCB7fSk7XG5mdW5jdGlvbiBnZXRSZXF1ZXN0U3RhdHVzRmxhZ3Moc3RhdHVzKSB7XG4gIHJldHVybiB7XG4gICAgc3RhdHVzLFxuICAgIGlzVW5pbml0aWFsaXplZDogc3RhdHVzID09PSBcInVuaW5pdGlhbGl6ZWRcIiAvKiB1bmluaXRpYWxpemVkICovLFxuICAgIGlzTG9hZGluZzogc3RhdHVzID09PSBcInBlbmRpbmdcIiAvKiBwZW5kaW5nICovLFxuICAgIGlzU3VjY2Vzczogc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiIC8qIGZ1bGZpbGxlZCAqLyxcbiAgICBpc0Vycm9yOiBzdGF0dXMgPT09IFwicmVqZWN0ZWRcIiAvKiByZWplY3RlZCAqL1xuICB9O1xufVxuXG4vLyBzcmMvcXVlcnkvdXRpbHMvaXNBYnNvbHV0ZVVybC50c1xuZnVuY3Rpb24gaXNBYnNvbHV0ZVVybCh1cmwpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoYChefDopLy9gKS50ZXN0KHVybCk7XG59XG5cbi8vIHNyYy9xdWVyeS91dGlscy9qb2luVXJscy50c1xudmFyIHdpdGhvdXRUcmFpbGluZ1NsYXNoID0gKHVybCkgPT4gdXJsLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcbnZhciB3aXRob3V0TGVhZGluZ1NsYXNoID0gKHVybCkgPT4gdXJsLnJlcGxhY2UoL15cXC8vLCBcIlwiKTtcbmZ1bmN0aW9uIGpvaW5VcmxzKGJhc2UsIHVybCkge1xuICBpZiAoIWJhc2UpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIGlmICghdXJsKSB7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbiAgaWYgKGlzQWJzb2x1dGVVcmwodXJsKSkge1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgY29uc3QgZGVsaW1pdGVyID0gYmFzZS5lbmRzV2l0aChcIi9cIikgfHwgIXVybC5zdGFydHNXaXRoKFwiP1wiKSA/IFwiL1wiIDogXCJcIjtcbiAgYmFzZSA9IHdpdGhvdXRUcmFpbGluZ1NsYXNoKGJhc2UpO1xuICB1cmwgPSB3aXRob3V0TGVhZGluZ1NsYXNoKHVybCk7XG4gIHJldHVybiBgJHtiYXNlfSR7ZGVsaW1pdGVyfSR7dXJsfWA7XG59XG5cbi8vIHNyYy9xdWVyeS91dGlscy9mbGF0dGVuLnRzXG52YXIgZmxhdHRlbiA9IChhcnIpID0+IFtdLmNvbmNhdCguLi5hcnIpO1xuXG4vLyBzcmMvcXVlcnkvdXRpbHMvaXNPbmxpbmUudHNcbmZ1bmN0aW9uIGlzT25saW5lKCkge1xuICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciA9PT0gXCJ1bmRlZmluZWRcIiA/IHRydWUgOiBuYXZpZ2F0b3Iub25MaW5lID09PSB2b2lkIDAgPyB0cnVlIDogbmF2aWdhdG9yLm9uTGluZTtcbn1cblxuLy8gc3JjL3F1ZXJ5L3V0aWxzL2lzRG9jdW1lbnRWaXNpYmxlLnRzXG5mdW5jdGlvbiBpc0RvY3VtZW50VmlzaWJsZSgpIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgIT09IFwiaGlkZGVuXCI7XG59XG5cbi8vIHNyYy9xdWVyeS9jb3JlL3J0a0ltcG9ydHMudHNcbmltcG9ydCB7IGNyZWF0ZUFjdGlvbiwgY3JlYXRlU2xpY2UsIGNyZWF0ZVNlbGVjdG9yLCBjcmVhdGVBc3luY1RodW5rLCBjb21iaW5lUmVkdWNlcnMsIGNyZWF0ZU5leHRTdGF0ZSwgaXNBbnlPZiwgaXNBbGxPZiwgaXNBY3Rpb24sIGlzUGVuZGluZywgaXNSZWplY3RlZCwgaXNGdWxmaWxsZWQsIGlzUmVqZWN0ZWRXaXRoVmFsdWUsIGlzQXN5bmNUaHVua0FjdGlvbiwgcHJlcGFyZUF1dG9CYXRjaGVkLCBTSE9VTERfQVVUT0JBVENILCBpc1BsYWluT2JqZWN0LCBuYW5vaWQgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xuXG4vLyBzcmMvcXVlcnkvdXRpbHMvY29weVdpdGhTdHJ1Y3R1cmFsU2hhcmluZy50c1xudmFyIGlzUGxhaW5PYmplY3QyID0gaXNQbGFpbk9iamVjdDtcbmZ1bmN0aW9uIGNvcHlXaXRoU3RydWN0dXJhbFNoYXJpbmcob2xkT2JqLCBuZXdPYmopIHtcbiAgaWYgKG9sZE9iaiA9PT0gbmV3T2JqIHx8ICEoaXNQbGFpbk9iamVjdDIob2xkT2JqKSAmJiBpc1BsYWluT2JqZWN0MihuZXdPYmopIHx8IEFycmF5LmlzQXJyYXkob2xkT2JqKSAmJiBBcnJheS5pc0FycmF5KG5ld09iaikpKSB7XG4gICAgcmV0dXJuIG5ld09iajtcbiAgfVxuICBjb25zdCBuZXdLZXlzID0gT2JqZWN0LmtleXMobmV3T2JqKTtcbiAgY29uc3Qgb2xkS2V5cyA9IE9iamVjdC5rZXlzKG9sZE9iaik7XG4gIGxldCBpc1NhbWVPYmplY3QgPSBuZXdLZXlzLmxlbmd0aCA9PT0gb2xkS2V5cy5sZW5ndGg7XG4gIGNvbnN0IG1lcmdlT2JqID0gQXJyYXkuaXNBcnJheShuZXdPYmopID8gW10gOiB7fTtcbiAgZm9yIChjb25zdCBrZXkgb2YgbmV3S2V5cykge1xuICAgIG1lcmdlT2JqW2tleV0gPSBjb3B5V2l0aFN0cnVjdHVyYWxTaGFyaW5nKG9sZE9ialtrZXldLCBuZXdPYmpba2V5XSk7XG4gICAgaWYgKGlzU2FtZU9iamVjdClcbiAgICAgIGlzU2FtZU9iamVjdCA9IG9sZE9ialtrZXldID09PSBtZXJnZU9ialtrZXldO1xuICB9XG4gIHJldHVybiBpc1NhbWVPYmplY3QgPyBvbGRPYmogOiBtZXJnZU9iajtcbn1cblxuLy8gc3JjL3F1ZXJ5L2ZldGNoQmFzZVF1ZXJ5LnRzXG52YXIgZGVmYXVsdEZldGNoRm4gPSAoLi4uYXJncykgPT4gZmV0Y2goLi4uYXJncyk7XG52YXIgZGVmYXVsdFZhbGlkYXRlU3RhdHVzID0gKHJlc3BvbnNlKSA9PiByZXNwb25zZS5zdGF0dXMgPj0gMjAwICYmIHJlc3BvbnNlLnN0YXR1cyA8PSAyOTk7XG52YXIgZGVmYXVsdElzSnNvbkNvbnRlbnRUeXBlID0gKGhlYWRlcnMpID0+IChcbiAgLyphcHBsaWNhdCovXG4gIC9pb25cXC8odm5kXFwuYXBpXFwrKT9qc29uLy50ZXN0KGhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpIHx8IFwiXCIpXG4pO1xuZnVuY3Rpb24gc3RyaXBVbmRlZmluZWQob2JqKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBjb25zdCBjb3B5ID0ge1xuICAgIC4uLm9ialxuICB9O1xuICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhjb3B5KSkge1xuICAgIGlmICh2ID09PSB2b2lkIDApXG4gICAgICBkZWxldGUgY29weVtrXTtcbiAgfVxuICByZXR1cm4gY29weTtcbn1cbmZ1bmN0aW9uIGZldGNoQmFzZVF1ZXJ5KHtcbiAgYmFzZVVybCxcbiAgcHJlcGFyZUhlYWRlcnMgPSAoeCkgPT4geCxcbiAgZmV0Y2hGbiA9IGRlZmF1bHRGZXRjaEZuLFxuICBwYXJhbXNTZXJpYWxpemVyLFxuICBpc0pzb25Db250ZW50VHlwZSA9IGRlZmF1bHRJc0pzb25Db250ZW50VHlwZSxcbiAganNvbkNvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gIGpzb25SZXBsYWNlcixcbiAgdGltZW91dDogZGVmYXVsdFRpbWVvdXQsXG4gIHJlc3BvbnNlSGFuZGxlcjogZ2xvYmFsUmVzcG9uc2VIYW5kbGVyLFxuICB2YWxpZGF0ZVN0YXR1czogZ2xvYmFsVmFsaWRhdGVTdGF0dXMsXG4gIC4uLmJhc2VGZXRjaE9wdGlvbnNcbn0gPSB7fSkge1xuICBpZiAodHlwZW9mIGZldGNoID09PSBcInVuZGVmaW5lZFwiICYmIGZldGNoRm4gPT09IGRlZmF1bHRGZXRjaEZuKSB7XG4gICAgY29uc29sZS53YXJuKFwiV2FybmluZzogYGZldGNoYCBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2Ugc3VwcGx5IGEgY3VzdG9tIGBmZXRjaEZuYCBwcm9wZXJ0eSB0byB1c2UgYGZldGNoQmFzZVF1ZXJ5YCBvbiBTU1IgZW52aXJvbm1lbnRzLlwiKTtcbiAgfVxuICByZXR1cm4gYXN5bmMgKGFyZywgYXBpKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgc2lnbmFsLFxuICAgICAgZ2V0U3RhdGUsXG4gICAgICBleHRyYSxcbiAgICAgIGVuZHBvaW50LFxuICAgICAgZm9yY2VkLFxuICAgICAgdHlwZVxuICAgIH0gPSBhcGk7XG4gICAgbGV0IG1ldGE7XG4gICAgbGV0IHtcbiAgICAgIHVybCxcbiAgICAgIGhlYWRlcnMgPSBuZXcgSGVhZGVycyhiYXNlRmV0Y2hPcHRpb25zLmhlYWRlcnMpLFxuICAgICAgcGFyYW1zID0gdm9pZCAwLFxuICAgICAgcmVzcG9uc2VIYW5kbGVyID0gZ2xvYmFsUmVzcG9uc2VIYW5kbGVyID8/IFwianNvblwiLFxuICAgICAgdmFsaWRhdGVTdGF0dXMgPSBnbG9iYWxWYWxpZGF0ZVN0YXR1cyA/PyBkZWZhdWx0VmFsaWRhdGVTdGF0dXMsXG4gICAgICB0aW1lb3V0ID0gZGVmYXVsdFRpbWVvdXQsXG4gICAgICAuLi5yZXN0XG4gICAgfSA9IHR5cGVvZiBhcmcgPT0gXCJzdHJpbmdcIiA/IHtcbiAgICAgIHVybDogYXJnXG4gICAgfSA6IGFyZztcbiAgICBsZXQgY29uZmlnID0ge1xuICAgICAgLi4uYmFzZUZldGNoT3B0aW9ucyxcbiAgICAgIHNpZ25hbCxcbiAgICAgIC4uLnJlc3RcbiAgICB9O1xuICAgIGhlYWRlcnMgPSBuZXcgSGVhZGVycyhzdHJpcFVuZGVmaW5lZChoZWFkZXJzKSk7XG4gICAgY29uZmlnLmhlYWRlcnMgPSBhd2FpdCBwcmVwYXJlSGVhZGVycyhoZWFkZXJzLCB7XG4gICAgICBnZXRTdGF0ZSxcbiAgICAgIGV4dHJhLFxuICAgICAgZW5kcG9pbnQsXG4gICAgICBmb3JjZWQsXG4gICAgICB0eXBlXG4gICAgfSkgfHwgaGVhZGVycztcbiAgICBjb25zdCBpc0pzb25pZmlhYmxlID0gKGJvZHkpID0+IHR5cGVvZiBib2R5ID09PSBcIm9iamVjdFwiICYmIChpc1BsYWluT2JqZWN0KGJvZHkpIHx8IEFycmF5LmlzQXJyYXkoYm9keSkgfHwgdHlwZW9mIGJvZHkudG9KU09OID09PSBcImZ1bmN0aW9uXCIpO1xuICAgIGlmICghY29uZmlnLmhlYWRlcnMuaGFzKFwiY29udGVudC10eXBlXCIpICYmIGlzSnNvbmlmaWFibGUoY29uZmlnLmJvZHkpKSB7XG4gICAgICBjb25maWcuaGVhZGVycy5zZXQoXCJjb250ZW50LXR5cGVcIiwganNvbkNvbnRlbnRUeXBlKTtcbiAgICB9XG4gICAgaWYgKGlzSnNvbmlmaWFibGUoY29uZmlnLmJvZHkpICYmIGlzSnNvbkNvbnRlbnRUeXBlKGNvbmZpZy5oZWFkZXJzKSkge1xuICAgICAgY29uZmlnLmJvZHkgPSBKU09OLnN0cmluZ2lmeShjb25maWcuYm9keSwganNvblJlcGxhY2VyKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcykge1xuICAgICAgY29uc3QgZGl2aWRlciA9IH51cmwuaW5kZXhPZihcIj9cIikgPyBcIiZcIiA6IFwiP1wiO1xuICAgICAgY29uc3QgcXVlcnkgPSBwYXJhbXNTZXJpYWxpemVyID8gcGFyYW1zU2VyaWFsaXplcihwYXJhbXMpIDogbmV3IFVSTFNlYXJjaFBhcmFtcyhzdHJpcFVuZGVmaW5lZChwYXJhbXMpKTtcbiAgICAgIHVybCArPSBkaXZpZGVyICsgcXVlcnk7XG4gICAgfVxuICAgIHVybCA9IGpvaW5VcmxzKGJhc2VVcmwsIHVybCk7XG4gICAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHVybCwgY29uZmlnKTtcbiAgICBjb25zdCByZXF1ZXN0Q2xvbmUgPSBuZXcgUmVxdWVzdCh1cmwsIGNvbmZpZyk7XG4gICAgbWV0YSA9IHtcbiAgICAgIHJlcXVlc3Q6IHJlcXVlc3RDbG9uZVxuICAgIH07XG4gICAgbGV0IHJlc3BvbnNlLCB0aW1lZE91dCA9IGZhbHNlLCB0aW1lb3V0SWQgPSB0aW1lb3V0ICYmIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGltZWRPdXQgPSB0cnVlO1xuICAgICAgYXBpLmFib3J0KCk7XG4gICAgfSwgdGltZW91dCk7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hGbihyZXF1ZXN0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcjoge1xuICAgICAgICAgIHN0YXR1czogdGltZWRPdXQgPyBcIlRJTUVPVVRfRVJST1JcIiA6IFwiRkVUQ0hfRVJST1JcIixcbiAgICAgICAgICBlcnJvcjogU3RyaW5nKGUpXG4gICAgICAgIH0sXG4gICAgICAgIG1ldGFcbiAgICAgIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICh0aW1lb3V0SWQpXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZUNsb25lID0gcmVzcG9uc2UuY2xvbmUoKTtcbiAgICBtZXRhLnJlc3BvbnNlID0gcmVzcG9uc2VDbG9uZTtcbiAgICBsZXQgcmVzdWx0RGF0YTtcbiAgICBsZXQgcmVzcG9uc2VUZXh0ID0gXCJcIjtcbiAgICB0cnkge1xuICAgICAgbGV0IGhhbmRsZVJlc3BvbnNlRXJyb3I7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIGhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlLCByZXNwb25zZUhhbmRsZXIpLnRoZW4oKHIpID0+IHJlc3VsdERhdGEgPSByLCAoZSkgPT4gaGFuZGxlUmVzcG9uc2VFcnJvciA9IGUpLFxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGUtZmV0Y2gvbm9kZS1mZXRjaC9pc3N1ZXMvNjY1I2lzc3VlY29tbWVudC01Mzg5OTUxODJcbiAgICAgICAgLy8gd2UgKmhhdmUqIHRvIFwidXNlIHVwXCIgYm90aCBzdHJlYW1zIGF0IHRoZSBzYW1lIHRpbWUgb3IgdGhleSB3aWxsIHN0b3AgcnVubmluZyBpbiBub2RlLWZldGNoIHNjZW5hcmlvc1xuICAgICAgICByZXNwb25zZUNsb25lLnRleHQoKS50aGVuKChyKSA9PiByZXNwb25zZVRleHQgPSByLCAoKSA9PiB7XG4gICAgICAgIH0pXG4gICAgICBdKTtcbiAgICAgIGlmIChoYW5kbGVSZXNwb25zZUVycm9yKVxuICAgICAgICB0aHJvdyBoYW5kbGVSZXNwb25zZUVycm9yO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgc3RhdHVzOiBcIlBBUlNJTkdfRVJST1JcIixcbiAgICAgICAgICBvcmlnaW5hbFN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgIGRhdGE6IHJlc3BvbnNlVGV4dCxcbiAgICAgICAgICBlcnJvcjogU3RyaW5nKGUpXG4gICAgICAgIH0sXG4gICAgICAgIG1ldGFcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB2YWxpZGF0ZVN0YXR1cyhyZXNwb25zZSwgcmVzdWx0RGF0YSkgPyB7XG4gICAgICBkYXRhOiByZXN1bHREYXRhLFxuICAgICAgbWV0YVxuICAgIH0gOiB7XG4gICAgICBlcnJvcjoge1xuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgZGF0YTogcmVzdWx0RGF0YVxuICAgICAgfSxcbiAgICAgIG1ldGFcbiAgICB9O1xuICB9O1xuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVSZXNwb25zZShyZXNwb25zZSwgcmVzcG9uc2VIYW5kbGVyKSB7XG4gICAgaWYgKHR5cGVvZiByZXNwb25zZUhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlSGFuZGxlcihyZXNwb25zZSk7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZUhhbmRsZXIgPT09IFwiY29udGVudC10eXBlXCIpIHtcbiAgICAgIHJlc3BvbnNlSGFuZGxlciA9IGlzSnNvbkNvbnRlbnRUeXBlKHJlc3BvbnNlLmhlYWRlcnMpID8gXCJqc29uXCIgOiBcInRleHRcIjtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlSGFuZGxlciA9PT0gXCJqc29uXCIpIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICByZXR1cm4gdGV4dC5sZW5ndGggPyBKU09OLnBhcnNlKHRleHQpIDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgfVxufVxuXG4vLyBzcmMvcXVlcnkvSGFuZGxlZEVycm9yLnRzXG52YXIgSGFuZGxlZEVycm9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgbWV0YSA9IHZvaWQgMCkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLm1ldGEgPSBtZXRhO1xuICB9XG59O1xuXG4vLyBzcmMvcXVlcnkvcmV0cnkudHNcbmFzeW5jIGZ1bmN0aW9uIGRlZmF1bHRCYWNrb2ZmKGF0dGVtcHQgPSAwLCBtYXhSZXRyaWVzID0gNSkge1xuICBjb25zdCBhdHRlbXB0cyA9IE1hdGgubWluKGF0dGVtcHQsIG1heFJldHJpZXMpO1xuICBjb25zdCB0aW1lb3V0ID0gfn4oKE1hdGgucmFuZG9tKCkgKyAwLjQpICogKDMwMCA8PCBhdHRlbXB0cykpO1xuICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dCgocmVzKSA9PiByZXNvbHZlKHJlcyksIHRpbWVvdXQpKTtcbn1cbmZ1bmN0aW9uIGZhaWwoZSkge1xuICB0aHJvdyBPYmplY3QuYXNzaWduKG5ldyBIYW5kbGVkRXJyb3Ioe1xuICAgIGVycm9yOiBlXG4gIH0pLCB7XG4gICAgdGhyb3dJbW1lZGlhdGVseTogdHJ1ZVxuICB9KTtcbn1cbnZhciBFTVBUWV9PUFRJT05TID0ge307XG52YXIgcmV0cnlXaXRoQmFja29mZiA9IChiYXNlUXVlcnksIGRlZmF1bHRPcHRpb25zKSA9PiBhc3luYyAoYXJncywgYXBpLCBleHRyYU9wdGlvbnMpID0+IHtcbiAgY29uc3QgcG9zc2libGVNYXhSZXRyaWVzID0gWzUsIChkZWZhdWx0T3B0aW9ucyB8fCBFTVBUWV9PUFRJT05TKS5tYXhSZXRyaWVzLCAoZXh0cmFPcHRpb25zIHx8IEVNUFRZX09QVElPTlMpLm1heFJldHJpZXNdLmZpbHRlcigoeCkgPT4geCAhPT0gdm9pZCAwKTtcbiAgY29uc3QgW21heFJldHJpZXNdID0gcG9zc2libGVNYXhSZXRyaWVzLnNsaWNlKC0xKTtcbiAgY29uc3QgZGVmYXVsdFJldHJ5Q29uZGl0aW9uID0gKF8sIF9fLCB7XG4gICAgYXR0ZW1wdFxuICB9KSA9PiBhdHRlbXB0IDw9IG1heFJldHJpZXM7XG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgbWF4UmV0cmllcyxcbiAgICBiYWNrb2ZmOiBkZWZhdWx0QmFja29mZixcbiAgICByZXRyeUNvbmRpdGlvbjogZGVmYXVsdFJldHJ5Q29uZGl0aW9uLFxuICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgIC4uLmV4dHJhT3B0aW9uc1xuICB9O1xuICBsZXQgcmV0cnkyID0gMDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYmFzZVF1ZXJ5KGFyZ3MsIGFwaSwgZXh0cmFPcHRpb25zKTtcbiAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEhhbmRsZWRFcnJvcihyZXN1bHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXRyeTIrKztcbiAgICAgIGlmIChlLnRocm93SW1tZWRpYXRlbHkpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBIYW5kbGVkRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBIYW5kbGVkRXJyb3IgJiYgIW9wdGlvbnMucmV0cnlDb25kaXRpb24oZS52YWx1ZS5lcnJvciwgYXJncywge1xuICAgICAgICBhdHRlbXB0OiByZXRyeTIsXG4gICAgICAgIGJhc2VRdWVyeUFwaTogYXBpLFxuICAgICAgICBleHRyYU9wdGlvbnNcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybiBlLnZhbHVlO1xuICAgICAgfVxuICAgICAgYXdhaXQgb3B0aW9ucy5iYWNrb2ZmKHJldHJ5Miwgb3B0aW9ucy5tYXhSZXRyaWVzKTtcbiAgICB9XG4gIH1cbn07XG52YXIgcmV0cnkgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmFzc2lnbihyZXRyeVdpdGhCYWNrb2ZmLCB7XG4gIGZhaWxcbn0pO1xuXG4vLyBzcmMvcXVlcnkvY29yZS9zZXR1cExpc3RlbmVycy50c1xudmFyIG9uRm9jdXMgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlQWN0aW9uKFwiX19ydGtxL2ZvY3VzZWRcIik7XG52YXIgb25Gb2N1c0xvc3QgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlQWN0aW9uKFwiX19ydGtxL3VuZm9jdXNlZFwiKTtcbnZhciBvbk9ubGluZSA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVBY3Rpb24oXCJfX3J0a3Evb25saW5lXCIpO1xudmFyIG9uT2ZmbGluZSA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVBY3Rpb24oXCJfX3J0a3Evb2ZmbGluZVwiKTtcbnZhciBpbml0aWFsaXplZCA9IGZhbHNlO1xuZnVuY3Rpb24gc2V0dXBMaXN0ZW5lcnMoZGlzcGF0Y2gsIGN1c3RvbUhhbmRsZXIpIHtcbiAgZnVuY3Rpb24gZGVmYXVsdEhhbmRsZXIoKSB7XG4gICAgY29uc3QgaGFuZGxlRm9jdXMgPSAoKSA9PiBkaXNwYXRjaChvbkZvY3VzKCkpO1xuICAgIGNvbnN0IGhhbmRsZUZvY3VzTG9zdCA9ICgpID0+IGRpc3BhdGNoKG9uRm9jdXNMb3N0KCkpO1xuICAgIGNvbnN0IGhhbmRsZU9ubGluZSA9ICgpID0+IGRpc3BhdGNoKG9uT25saW5lKCkpO1xuICAgIGNvbnN0IGhhbmRsZU9mZmxpbmUgPSAoKSA9PiBkaXNwYXRjaChvbk9mZmxpbmUoKSk7XG4gICAgY29uc3QgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSA9ICgpID0+IHtcbiAgICAgIGlmICh3aW5kb3cuZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSBcInZpc2libGVcIikge1xuICAgICAgICBoYW5kbGVGb2N1cygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlRm9jdXNMb3N0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoIWluaXRpYWxpemVkKSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSwgZmFsc2UpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIGhhbmRsZUZvY3VzLCBmYWxzZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib25saW5lXCIsIGhhbmRsZU9ubGluZSwgZmFsc2UpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIiwgaGFuZGxlT2ZmbGluZSwgZmFsc2UpO1xuICAgICAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBoYW5kbGVGb2N1cyk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCBoYW5kbGVPbmxpbmUpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIGhhbmRsZU9mZmxpbmUpO1xuICAgICAgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiB1bnN1YnNjcmliZTtcbiAgfVxuICByZXR1cm4gY3VzdG9tSGFuZGxlciA/IGN1c3RvbUhhbmRsZXIoZGlzcGF0Y2gsIHtcbiAgICBvbkZvY3VzLFxuICAgIG9uRm9jdXNMb3N0LFxuICAgIG9uT2ZmbGluZSxcbiAgICBvbk9ubGluZVxuICB9KSA6IGRlZmF1bHRIYW5kbGVyKCk7XG59XG5cbi8vIHNyYy9xdWVyeS9lbmRwb2ludERlZmluaXRpb25zLnRzXG5mdW5jdGlvbiBpc1F1ZXJ5RGVmaW5pdGlvbihlKSB7XG4gIHJldHVybiBlLnR5cGUgPT09IFwicXVlcnlcIiAvKiBxdWVyeSAqLztcbn1cbmZ1bmN0aW9uIGlzTXV0YXRpb25EZWZpbml0aW9uKGUpIHtcbiAgcmV0dXJuIGUudHlwZSA9PT0gXCJtdXRhdGlvblwiIC8qIG11dGF0aW9uICovO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlUHJvdmlkZWRCeShkZXNjcmlwdGlvbiwgcmVzdWx0LCBlcnJvciwgcXVlcnlBcmcsIG1ldGEsIGFzc2VydFRhZ1R5cGVzKSB7XG4gIGlmIChpc0Z1bmN0aW9uKGRlc2NyaXB0aW9uKSkge1xuICAgIHJldHVybiBkZXNjcmlwdGlvbihyZXN1bHQsIGVycm9yLCBxdWVyeUFyZywgbWV0YSkubWFwKGV4cGFuZFRhZ0Rlc2NyaXB0aW9uKS5tYXAoYXNzZXJ0VGFnVHlwZXMpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGRlc2NyaXB0aW9uKSkge1xuICAgIHJldHVybiBkZXNjcmlwdGlvbi5tYXAoZXhwYW5kVGFnRGVzY3JpcHRpb24pLm1hcChhc3NlcnRUYWdUeXBlcyk7XG4gIH1cbiAgcmV0dXJuIFtdO1xufVxuZnVuY3Rpb24gaXNGdW5jdGlvbih0KSB7XG4gIHJldHVybiB0eXBlb2YgdCA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gZXhwYW5kVGFnRGVzY3JpcHRpb24oZGVzY3JpcHRpb24pIHtcbiAgcmV0dXJuIHR5cGVvZiBkZXNjcmlwdGlvbiA9PT0gXCJzdHJpbmdcIiA/IHtcbiAgICB0eXBlOiBkZXNjcmlwdGlvblxuICB9IDogZGVzY3JpcHRpb247XG59XG5cbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkSW5pdGlhdGUudHNcbmltcG9ydCB7IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UgYXMgX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UgfSBmcm9tIFwiQHJlZHV4anMvdG9vbGtpdFwiO1xuXG4vLyBzcmMvcXVlcnkvdXRpbHMvaXNOb3ROdWxsaXNoLnRzXG5mdW5jdGlvbiBpc05vdE51bGxpc2godikge1xuICByZXR1cm4gdiAhPSBudWxsO1xufVxuXG4vLyBzcmMvcXVlcnkvdXRpbHMvY291bnRPYmplY3RLZXlzLnRzXG5mdW5jdGlvbiBjb3VudE9iamVjdEtleXMob2JqKSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGZvciAoY29uc3QgX2tleSBpbiBvYmopIHtcbiAgICBjb3VudCsrO1xuICB9XG4gIHJldHVybiBjb3VudDtcbn1cblxuLy8gc3JjL3RzSGVscGVycy50c1xuZnVuY3Rpb24gYXNTYWZlUHJvbWlzZShwcm9taXNlLCBmYWxsYmFjaykge1xuICByZXR1cm4gcHJvbWlzZS5jYXRjaChmYWxsYmFjayk7XG59XG5cbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkSW5pdGlhdGUudHNcbnZhciBmb3JjZVF1ZXJ5Rm5TeW1ib2wgPSBTeW1ib2woXCJmb3JjZVF1ZXJ5Rm5cIik7XG52YXIgaXNVcHNlcnRRdWVyeSA9IChhcmcpID0+IHR5cGVvZiBhcmdbZm9yY2VRdWVyeUZuU3ltYm9sXSA9PT0gXCJmdW5jdGlvblwiO1xuZnVuY3Rpb24gYnVpbGRJbml0aWF0ZSh7XG4gIHNlcmlhbGl6ZVF1ZXJ5QXJncyxcbiAgcXVlcnlUaHVuayxcbiAgbXV0YXRpb25UaHVuayxcbiAgYXBpLFxuICBjb250ZXh0XG59KSB7XG4gIGNvbnN0IHJ1bm5pbmdRdWVyaWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgcnVubmluZ011dGF0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHtcbiAgICB1bnN1YnNjcmliZVF1ZXJ5UmVzdWx0LFxuICAgIHJlbW92ZU11dGF0aW9uUmVzdWx0LFxuICAgIHVwZGF0ZVN1YnNjcmlwdGlvbk9wdGlvbnNcbiAgfSA9IGFwaS5pbnRlcm5hbEFjdGlvbnM7XG4gIHJldHVybiB7XG4gICAgYnVpbGRJbml0aWF0ZVF1ZXJ5LFxuICAgIGJ1aWxkSW5pdGlhdGVNdXRhdGlvbixcbiAgICBnZXRSdW5uaW5nUXVlcnlUaHVuayxcbiAgICBnZXRSdW5uaW5nTXV0YXRpb25UaHVuayxcbiAgICBnZXRSdW5uaW5nUXVlcmllc1RodW5rLFxuICAgIGdldFJ1bm5pbmdNdXRhdGlvbnNUaHVua1xuICB9O1xuICBmdW5jdGlvbiBnZXRSdW5uaW5nUXVlcnlUaHVuayhlbmRwb2ludE5hbWUsIHF1ZXJ5QXJncykge1xuICAgIHJldHVybiAoZGlzcGF0Y2gpID0+IHtcbiAgICAgIGNvbnN0IGVuZHBvaW50RGVmaW5pdGlvbiA9IGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9uc1tlbmRwb2ludE5hbWVdO1xuICAgICAgY29uc3QgcXVlcnlDYWNoZUtleSA9IHNlcmlhbGl6ZVF1ZXJ5QXJncyh7XG4gICAgICAgIHF1ZXJ5QXJncyxcbiAgICAgICAgZW5kcG9pbnREZWZpbml0aW9uLFxuICAgICAgICBlbmRwb2ludE5hbWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJ1bm5pbmdRdWVyaWVzLmdldChkaXNwYXRjaCk/LltxdWVyeUNhY2hlS2V5XTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGdldFJ1bm5pbmdNdXRhdGlvblRodW5rKF9lbmRwb2ludE5hbWUsIGZpeGVkQ2FjaGVLZXlPclJlcXVlc3RJZCkge1xuICAgIHJldHVybiAoZGlzcGF0Y2gpID0+IHtcbiAgICAgIHJldHVybiBydW5uaW5nTXV0YXRpb25zLmdldChkaXNwYXRjaCk/LltmaXhlZENhY2hlS2V5T3JSZXF1ZXN0SWRdO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UnVubmluZ1F1ZXJpZXNUaHVuaygpIHtcbiAgICByZXR1cm4gKGRpc3BhdGNoKSA9PiBPYmplY3QudmFsdWVzKHJ1bm5pbmdRdWVyaWVzLmdldChkaXNwYXRjaCkgfHwge30pLmZpbHRlcihpc05vdE51bGxpc2gpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFJ1bm5pbmdNdXRhdGlvbnNUaHVuaygpIHtcbiAgICByZXR1cm4gKGRpc3BhdGNoKSA9PiBPYmplY3QudmFsdWVzKHJ1bm5pbmdNdXRhdGlvbnMuZ2V0KGRpc3BhdGNoKSB8fCB7fSkuZmlsdGVyKGlzTm90TnVsbGlzaCk7XG4gIH1cbiAgZnVuY3Rpb24gbWlkZGxld2FyZVdhcm5pbmcoZGlzcGF0Y2gpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAobWlkZGxld2FyZVdhcm5pbmcudHJpZ2dlcmVkKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCByZXR1cm5lZFZhbHVlID0gZGlzcGF0Y2goYXBpLmludGVybmFsQWN0aW9ucy5pbnRlcm5hbF9nZXRSVEtRU3Vic2NyaXB0aW9ucygpKTtcbiAgICAgIG1pZGRsZXdhcmVXYXJuaW5nLnRyaWdnZXJlZCA9IHRydWU7XG4gICAgICBpZiAodHlwZW9mIHJldHVybmVkVmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHJldHVybmVkVmFsdWU/LnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDM0KSA6IGBXYXJuaW5nOiBNaWRkbGV3YXJlIGZvciBSVEstUXVlcnkgQVBJIGF0IHJlZHVjZXJQYXRoIFwiJHthcGkucmVkdWNlclBhdGh9XCIgaGFzIG5vdCBiZWVuIGFkZGVkIHRvIHRoZSBzdG9yZS5cbllvdSBtdXN0IGFkZCB0aGUgbWlkZGxld2FyZSBmb3IgUlRLLVF1ZXJ5IHRvIGZ1bmN0aW9uIGNvcnJlY3RseSFgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRJbml0aWF0ZVF1ZXJ5KGVuZHBvaW50TmFtZSwgZW5kcG9pbnREZWZpbml0aW9uKSB7XG4gICAgY29uc3QgcXVlcnlBY3Rpb24gPSAoYXJnLCB7XG4gICAgICBzdWJzY3JpYmUgPSB0cnVlLFxuICAgICAgZm9yY2VSZWZldGNoLFxuICAgICAgc3Vic2NyaXB0aW9uT3B0aW9ucyxcbiAgICAgIFtmb3JjZVF1ZXJ5Rm5TeW1ib2xdOiBmb3JjZVF1ZXJ5Rm5cbiAgICB9ID0ge30pID0+IChkaXNwYXRjaCwgZ2V0U3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IHF1ZXJ5Q2FjaGVLZXkgPSBzZXJpYWxpemVRdWVyeUFyZ3Moe1xuICAgICAgICBxdWVyeUFyZ3M6IGFyZyxcbiAgICAgICAgZW5kcG9pbnREZWZpbml0aW9uLFxuICAgICAgICBlbmRwb2ludE5hbWVcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdGh1bmsgPSBxdWVyeVRodW5rKHtcbiAgICAgICAgdHlwZTogXCJxdWVyeVwiLFxuICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgIGZvcmNlUmVmZXRjaCxcbiAgICAgICAgc3Vic2NyaXB0aW9uT3B0aW9ucyxcbiAgICAgICAgZW5kcG9pbnROYW1lLFxuICAgICAgICBvcmlnaW5hbEFyZ3M6IGFyZyxcbiAgICAgICAgcXVlcnlDYWNoZUtleSxcbiAgICAgICAgW2ZvcmNlUXVlcnlGblN5bWJvbF06IGZvcmNlUXVlcnlGblxuICAgICAgfSk7XG4gICAgICBjb25zdCBzZWxlY3RvciA9IGFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXS5zZWxlY3QoYXJnKTtcbiAgICAgIGNvbnN0IHRodW5rUmVzdWx0ID0gZGlzcGF0Y2godGh1bmspO1xuICAgICAgY29uc3Qgc3RhdGVBZnRlciA9IHNlbGVjdG9yKGdldFN0YXRlKCkpO1xuICAgICAgbWlkZGxld2FyZVdhcm5pbmcoZGlzcGF0Y2gpO1xuICAgICAgY29uc3Qge1xuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIGFib3J0XG4gICAgICB9ID0gdGh1bmtSZXN1bHQ7XG4gICAgICBjb25zdCBza2lwcGVkU3luY2hyb25vdXNseSA9IHN0YXRlQWZ0ZXIucmVxdWVzdElkICE9PSByZXF1ZXN0SWQ7XG4gICAgICBjb25zdCBydW5uaW5nUXVlcnkgPSBydW5uaW5nUXVlcmllcy5nZXQoZGlzcGF0Y2gpPy5bcXVlcnlDYWNoZUtleV07XG4gICAgICBjb25zdCBzZWxlY3RGcm9tU3RhdGUgPSAoKSA9PiBzZWxlY3RvcihnZXRTdGF0ZSgpKTtcbiAgICAgIGNvbnN0IHN0YXRlUHJvbWlzZSA9IE9iamVjdC5hc3NpZ24oZm9yY2VRdWVyeUZuID8gKFxuICAgICAgICAvLyBhIHF1ZXJ5IGhhcyBiZWVuIGZvcmNlZCAodXBzZXJ0UXVlcnlEYXRhKVxuICAgICAgICAvLyAtPiB3ZSB3YW50IHRvIHJlc29sdmUgaXQgb25jZSBkYXRhIGhhcyBiZWVuIHdyaXR0ZW4gd2l0aCB0aGUgZGF0YSB0aGF0IHdpbGwgYmUgd3JpdHRlblxuICAgICAgICB0aHVua1Jlc3VsdC50aGVuKHNlbGVjdEZyb21TdGF0ZSlcbiAgICAgICkgOiBza2lwcGVkU3luY2hyb25vdXNseSAmJiAhcnVubmluZ1F1ZXJ5ID8gKFxuICAgICAgICAvLyBhIHF1ZXJ5IGhhcyBiZWVuIHNraXBwZWQgZHVlIHRvIGEgY29uZGl0aW9uIGFuZCB3ZSBkbyBub3QgaGF2ZSBhbnkgY3VycmVudGx5IHJ1bm5pbmcgcXVlcnlcbiAgICAgICAgLy8gLT4gd2Ugd2FudCB0byByZXNvbHZlIGl0IGltbWVkaWF0ZWx5IHdpdGggdGhlIGN1cnJlbnQgZGF0YVxuICAgICAgICBQcm9taXNlLnJlc29sdmUoc3RhdGVBZnRlcilcbiAgICAgICkgOiAoXG4gICAgICAgIC8vIHF1ZXJ5IGp1c3Qgc3RhcnRlZCBvciBvbmUgaXMgYWxyZWFkeSBpbiBmbGlnaHRcbiAgICAgICAgLy8gLT4gd2FpdCBmb3IgdGhlIHJ1bm5pbmcgcXVlcnksIHRoZW4gcmVzb2x2ZSB3aXRoIGRhdGEgZnJvbSBhZnRlciB0aGF0XG4gICAgICAgIFByb21pc2UuYWxsKFtydW5uaW5nUXVlcnksIHRodW5rUmVzdWx0XSkudGhlbihzZWxlY3RGcm9tU3RhdGUpXG4gICAgICApLCB7XG4gICAgICAgIGFyZyxcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICBzdWJzY3JpcHRpb25PcHRpb25zLFxuICAgICAgICBxdWVyeUNhY2hlS2V5LFxuICAgICAgICBhYm9ydCxcbiAgICAgICAgYXN5bmMgdW53cmFwKCkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN0YXRlUHJvbWlzZTtcbiAgICAgICAgICBpZiAocmVzdWx0LmlzRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICB9LFxuICAgICAgICByZWZldGNoOiAoKSA9PiBkaXNwYXRjaChxdWVyeUFjdGlvbihhcmcsIHtcbiAgICAgICAgICBzdWJzY3JpYmU6IGZhbHNlLFxuICAgICAgICAgIGZvcmNlUmVmZXRjaDogdHJ1ZVxuICAgICAgICB9KSksXG4gICAgICAgIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICAgIGlmIChzdWJzY3JpYmUpXG4gICAgICAgICAgICBkaXNwYXRjaCh1bnN1YnNjcmliZVF1ZXJ5UmVzdWx0KHtcbiAgICAgICAgICAgICAgcXVlcnlDYWNoZUtleSxcbiAgICAgICAgICAgICAgcmVxdWVzdElkXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZVN1YnNjcmlwdGlvbk9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICAgIHN0YXRlUHJvbWlzZS5zdWJzY3JpcHRpb25PcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICBkaXNwYXRjaCh1cGRhdGVTdWJzY3JpcHRpb25PcHRpb25zKHtcbiAgICAgICAgICAgIGVuZHBvaW50TmFtZSxcbiAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXksXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghcnVubmluZ1F1ZXJ5ICYmICFza2lwcGVkU3luY2hyb25vdXNseSAmJiAhZm9yY2VRdWVyeUZuKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5pbmcgPSBydW5uaW5nUXVlcmllcy5nZXQoZGlzcGF0Y2gpIHx8IHt9O1xuICAgICAgICBydW5uaW5nW3F1ZXJ5Q2FjaGVLZXldID0gc3RhdGVQcm9taXNlO1xuICAgICAgICBydW5uaW5nUXVlcmllcy5zZXQoZGlzcGF0Y2gsIHJ1bm5pbmcpO1xuICAgICAgICBzdGF0ZVByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgZGVsZXRlIHJ1bm5pbmdbcXVlcnlDYWNoZUtleV07XG4gICAgICAgICAgaWYgKCFjb3VudE9iamVjdEtleXMocnVubmluZykpIHtcbiAgICAgICAgICAgIHJ1bm5pbmdRdWVyaWVzLmRlbGV0ZShkaXNwYXRjaCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGF0ZVByb21pc2U7XG4gICAgfTtcbiAgICByZXR1cm4gcXVlcnlBY3Rpb247XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRJbml0aWF0ZU11dGF0aW9uKGVuZHBvaW50TmFtZSkge1xuICAgIHJldHVybiAoYXJnLCB7XG4gICAgICB0cmFjayA9IHRydWUsXG4gICAgICBmaXhlZENhY2hlS2V5XG4gICAgfSA9IHt9KSA9PiAoZGlzcGF0Y2gsIGdldFN0YXRlKSA9PiB7XG4gICAgICBjb25zdCB0aHVuayA9IG11dGF0aW9uVGh1bmsoe1xuICAgICAgICB0eXBlOiBcIm11dGF0aW9uXCIsXG4gICAgICAgIGVuZHBvaW50TmFtZSxcbiAgICAgICAgb3JpZ2luYWxBcmdzOiBhcmcsXG4gICAgICAgIHRyYWNrLFxuICAgICAgICBmaXhlZENhY2hlS2V5XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHRodW5rUmVzdWx0ID0gZGlzcGF0Y2godGh1bmspO1xuICAgICAgbWlkZGxld2FyZVdhcm5pbmcoZGlzcGF0Y2gpO1xuICAgICAgY29uc3Qge1xuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIGFib3J0LFxuICAgICAgICB1bndyYXBcbiAgICAgIH0gPSB0aHVua1Jlc3VsdDtcbiAgICAgIGNvbnN0IHJldHVyblZhbHVlUHJvbWlzZSA9IGFzU2FmZVByb21pc2UodGh1bmtSZXN1bHQudW53cmFwKCkudGhlbigoZGF0YSkgPT4gKHtcbiAgICAgICAgZGF0YVxuICAgICAgfSkpLCAoZXJyb3IpID0+ICh7XG4gICAgICAgIGVycm9yXG4gICAgICB9KSk7XG4gICAgICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICAgICAgZGlzcGF0Y2gocmVtb3ZlTXV0YXRpb25SZXN1bHQoe1xuICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICBmaXhlZENhY2hlS2V5XG4gICAgICAgIH0pKTtcbiAgICAgIH07XG4gICAgICBjb25zdCByZXQgPSBPYmplY3QuYXNzaWduKHJldHVyblZhbHVlUHJvbWlzZSwge1xuICAgICAgICBhcmc6IHRodW5rUmVzdWx0LmFyZyxcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICBhYm9ydCxcbiAgICAgICAgdW53cmFwLFxuICAgICAgICByZXNldFxuICAgICAgfSk7XG4gICAgICBjb25zdCBydW5uaW5nID0gcnVubmluZ011dGF0aW9ucy5nZXQoZGlzcGF0Y2gpIHx8IHt9O1xuICAgICAgcnVubmluZ011dGF0aW9ucy5zZXQoZGlzcGF0Y2gsIHJ1bm5pbmcpO1xuICAgICAgcnVubmluZ1tyZXF1ZXN0SWRdID0gcmV0O1xuICAgICAgcmV0LnRoZW4oKCkgPT4ge1xuICAgICAgICBkZWxldGUgcnVubmluZ1tyZXF1ZXN0SWRdO1xuICAgICAgICBpZiAoIWNvdW50T2JqZWN0S2V5cyhydW5uaW5nKSkge1xuICAgICAgICAgIHJ1bm5pbmdNdXRhdGlvbnMuZGVsZXRlKGRpc3BhdGNoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoZml4ZWRDYWNoZUtleSkge1xuICAgICAgICBydW5uaW5nW2ZpeGVkQ2FjaGVLZXldID0gcmV0O1xuICAgICAgICByZXQudGhlbigoKSA9PiB7XG4gICAgICAgICAgaWYgKHJ1bm5pbmdbZml4ZWRDYWNoZUtleV0gPT09IHJldCkge1xuICAgICAgICAgICAgZGVsZXRlIHJ1bm5pbmdbZml4ZWRDYWNoZUtleV07XG4gICAgICAgICAgICBpZiAoIWNvdW50T2JqZWN0S2V5cyhydW5uaW5nKSkge1xuICAgICAgICAgICAgICBydW5uaW5nTXV0YXRpb25zLmRlbGV0ZShkaXNwYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgfVxufVxuXG4vLyBzcmMvcXVlcnkvY29yZS9idWlsZFRodW5rcy50c1xuaW1wb3J0IHsgaXNEcmFmdGFibGUsIHByb2R1Y2VXaXRoUGF0Y2hlcyB9IGZyb20gXCJpbW1lclwiO1xuZnVuY3Rpb24gZGVmYXVsdFRyYW5zZm9ybVJlc3BvbnNlKGJhc2VRdWVyeVJldHVyblZhbHVlKSB7XG4gIHJldHVybiBiYXNlUXVlcnlSZXR1cm5WYWx1ZTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVGh1bmtzKHtcbiAgcmVkdWNlclBhdGgsXG4gIGJhc2VRdWVyeSxcbiAgY29udGV4dDoge1xuICAgIGVuZHBvaW50RGVmaW5pdGlvbnNcbiAgfSxcbiAgc2VyaWFsaXplUXVlcnlBcmdzLFxuICBhcGksXG4gIGFzc2VydFRhZ1R5cGVcbn0pIHtcbiAgY29uc3QgcGF0Y2hRdWVyeURhdGEgPSAoZW5kcG9pbnROYW1lLCBhcmdzLCBwYXRjaGVzLCB1cGRhdGVQcm92aWRlZCkgPT4gKGRpc3BhdGNoLCBnZXRTdGF0ZSkgPT4ge1xuICAgIGNvbnN0IGVuZHBvaW50RGVmaW5pdGlvbiA9IGVuZHBvaW50RGVmaW5pdGlvbnNbZW5kcG9pbnROYW1lXTtcbiAgICBjb25zdCBxdWVyeUNhY2hlS2V5ID0gc2VyaWFsaXplUXVlcnlBcmdzKHtcbiAgICAgIHF1ZXJ5QXJnczogYXJncyxcbiAgICAgIGVuZHBvaW50RGVmaW5pdGlvbixcbiAgICAgIGVuZHBvaW50TmFtZVxuICAgIH0pO1xuICAgIGRpc3BhdGNoKGFwaS5pbnRlcm5hbEFjdGlvbnMucXVlcnlSZXN1bHRQYXRjaGVkKHtcbiAgICAgIHF1ZXJ5Q2FjaGVLZXksXG4gICAgICBwYXRjaGVzXG4gICAgfSkpO1xuICAgIGlmICghdXBkYXRlUHJvdmlkZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmV3VmFsdWUgPSBhcGkuZW5kcG9pbnRzW2VuZHBvaW50TmFtZV0uc2VsZWN0KGFyZ3MpKFxuICAgICAgLy8gV29yayBhcm91bmQgVFMgNC4xIG1pc21hdGNoXG4gICAgICBnZXRTdGF0ZSgpXG4gICAgKTtcbiAgICBjb25zdCBwcm92aWRlZFRhZ3MgPSBjYWxjdWxhdGVQcm92aWRlZEJ5KGVuZHBvaW50RGVmaW5pdGlvbi5wcm92aWRlc1RhZ3MsIG5ld1ZhbHVlLmRhdGEsIHZvaWQgMCwgYXJncywge30sIGFzc2VydFRhZ1R5cGUpO1xuICAgIGRpc3BhdGNoKGFwaS5pbnRlcm5hbEFjdGlvbnMudXBkYXRlUHJvdmlkZWRCeSh7XG4gICAgICBxdWVyeUNhY2hlS2V5LFxuICAgICAgcHJvdmlkZWRUYWdzXG4gICAgfSkpO1xuICB9O1xuICBjb25zdCB1cGRhdGVRdWVyeURhdGEgPSAoZW5kcG9pbnROYW1lLCBhcmdzLCB1cGRhdGVSZWNpcGUsIHVwZGF0ZVByb3ZpZGVkID0gdHJ1ZSkgPT4gKGRpc3BhdGNoLCBnZXRTdGF0ZSkgPT4ge1xuICAgIGNvbnN0IGVuZHBvaW50RGVmaW5pdGlvbiA9IGFwaS5lbmRwb2ludHNbZW5kcG9pbnROYW1lXTtcbiAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBlbmRwb2ludERlZmluaXRpb24uc2VsZWN0KGFyZ3MpKFxuICAgICAgLy8gV29yayBhcm91bmQgVFMgNC4xIG1pc21hdGNoXG4gICAgICBnZXRTdGF0ZSgpXG4gICAgKTtcbiAgICBsZXQgcmV0ID0ge1xuICAgICAgcGF0Y2hlczogW10sXG4gICAgICBpbnZlcnNlUGF0Y2hlczogW10sXG4gICAgICB1bmRvOiAoKSA9PiBkaXNwYXRjaChhcGkudXRpbC5wYXRjaFF1ZXJ5RGF0YShlbmRwb2ludE5hbWUsIGFyZ3MsIHJldC5pbnZlcnNlUGF0Y2hlcywgdXBkYXRlUHJvdmlkZWQpKVxuICAgIH07XG4gICAgaWYgKGN1cnJlbnRTdGF0ZS5zdGF0dXMgPT09IFwidW5pbml0aWFsaXplZFwiIC8qIHVuaW5pdGlhbGl6ZWQgKi8pIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGxldCBuZXdWYWx1ZTtcbiAgICBpZiAoXCJkYXRhXCIgaW4gY3VycmVudFN0YXRlKSB7XG4gICAgICBpZiAoaXNEcmFmdGFibGUoY3VycmVudFN0YXRlLmRhdGEpKSB7XG4gICAgICAgIGNvbnN0IFt2YWx1ZSwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXNdID0gcHJvZHVjZVdpdGhQYXRjaGVzKGN1cnJlbnRTdGF0ZS5kYXRhLCB1cGRhdGVSZWNpcGUpO1xuICAgICAgICByZXQucGF0Y2hlcy5wdXNoKC4uLnBhdGNoZXMpO1xuICAgICAgICByZXQuaW52ZXJzZVBhdGNoZXMucHVzaCguLi5pbnZlcnNlUGF0Y2hlcyk7XG4gICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdWYWx1ZSA9IHVwZGF0ZVJlY2lwZShjdXJyZW50U3RhdGUuZGF0YSk7XG4gICAgICAgIHJldC5wYXRjaGVzLnB1c2goe1xuICAgICAgICAgIG9wOiBcInJlcGxhY2VcIixcbiAgICAgICAgICBwYXRoOiBbXSxcbiAgICAgICAgICB2YWx1ZTogbmV3VmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldC5pbnZlcnNlUGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICBvcDogXCJyZXBsYWNlXCIsXG4gICAgICAgICAgcGF0aDogW10sXG4gICAgICAgICAgdmFsdWU6IGN1cnJlbnRTdGF0ZS5kYXRhXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBkaXNwYXRjaChhcGkudXRpbC5wYXRjaFF1ZXJ5RGF0YShlbmRwb2ludE5hbWUsIGFyZ3MsIHJldC5wYXRjaGVzLCB1cGRhdGVQcm92aWRlZCkpO1xuICAgIHJldHVybiByZXQ7XG4gIH07XG4gIGNvbnN0IHVwc2VydFF1ZXJ5RGF0YSA9IChlbmRwb2ludE5hbWUsIGFyZ3MsIHZhbHVlKSA9PiAoZGlzcGF0Y2gpID0+IHtcbiAgICByZXR1cm4gZGlzcGF0Y2goYXBpLmVuZHBvaW50c1tlbmRwb2ludE5hbWVdLmluaXRpYXRlKGFyZ3MsIHtcbiAgICAgIHN1YnNjcmliZTogZmFsc2UsXG4gICAgICBmb3JjZVJlZmV0Y2g6IHRydWUsXG4gICAgICBbZm9yY2VRdWVyeUZuU3ltYm9sXTogKCkgPT4gKHtcbiAgICAgICAgZGF0YTogdmFsdWVcbiAgICAgIH0pXG4gICAgfSkpO1xuICB9O1xuICBjb25zdCBleGVjdXRlRW5kcG9pbnQgPSBhc3luYyAoYXJnLCB7XG4gICAgc2lnbmFsLFxuICAgIGFib3J0LFxuICAgIHJlamVjdFdpdGhWYWx1ZSxcbiAgICBmdWxmaWxsV2l0aFZhbHVlLFxuICAgIGRpc3BhdGNoLFxuICAgIGdldFN0YXRlLFxuICAgIGV4dHJhXG4gIH0pID0+IHtcbiAgICBjb25zdCBlbmRwb2ludERlZmluaXRpb24gPSBlbmRwb2ludERlZmluaXRpb25zW2FyZy5lbmRwb2ludE5hbWVdO1xuICAgIHRyeSB7XG4gICAgICBsZXQgdHJhbnNmb3JtUmVzcG9uc2UgPSBkZWZhdWx0VHJhbnNmb3JtUmVzcG9uc2U7XG4gICAgICBsZXQgcmVzdWx0O1xuICAgICAgY29uc3QgYmFzZVF1ZXJ5QXBpID0ge1xuICAgICAgICBzaWduYWwsXG4gICAgICAgIGFib3J0LFxuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgZ2V0U3RhdGUsXG4gICAgICAgIGV4dHJhLFxuICAgICAgICBlbmRwb2ludDogYXJnLmVuZHBvaW50TmFtZSxcbiAgICAgICAgdHlwZTogYXJnLnR5cGUsXG4gICAgICAgIGZvcmNlZDogYXJnLnR5cGUgPT09IFwicXVlcnlcIiA/IGlzRm9yY2VkUXVlcnkoYXJnLCBnZXRTdGF0ZSgpKSA6IHZvaWQgMFxuICAgICAgfTtcbiAgICAgIGNvbnN0IGZvcmNlUXVlcnlGbiA9IGFyZy50eXBlID09PSBcInF1ZXJ5XCIgPyBhcmdbZm9yY2VRdWVyeUZuU3ltYm9sXSA6IHZvaWQgMDtcbiAgICAgIGlmIChmb3JjZVF1ZXJ5Rm4pIHtcbiAgICAgICAgcmVzdWx0ID0gZm9yY2VRdWVyeUZuKCk7XG4gICAgICB9IGVsc2UgaWYgKGVuZHBvaW50RGVmaW5pdGlvbi5xdWVyeSkge1xuICAgICAgICByZXN1bHQgPSBhd2FpdCBiYXNlUXVlcnkoZW5kcG9pbnREZWZpbml0aW9uLnF1ZXJ5KGFyZy5vcmlnaW5hbEFyZ3MpLCBiYXNlUXVlcnlBcGksIGVuZHBvaW50RGVmaW5pdGlvbi5leHRyYU9wdGlvbnMpO1xuICAgICAgICBpZiAoZW5kcG9pbnREZWZpbml0aW9uLnRyYW5zZm9ybVJlc3BvbnNlKSB7XG4gICAgICAgICAgdHJhbnNmb3JtUmVzcG9uc2UgPSBlbmRwb2ludERlZmluaXRpb24udHJhbnNmb3JtUmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGF3YWl0IGVuZHBvaW50RGVmaW5pdGlvbi5xdWVyeUZuKGFyZy5vcmlnaW5hbEFyZ3MsIGJhc2VRdWVyeUFwaSwgZW5kcG9pbnREZWZpbml0aW9uLmV4dHJhT3B0aW9ucywgKGFyZzIpID0+IGJhc2VRdWVyeShhcmcyLCBiYXNlUXVlcnlBcGksIGVuZHBvaW50RGVmaW5pdGlvbi5leHRyYU9wdGlvbnMpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICAgIGNvbnN0IHdoYXQgPSBlbmRwb2ludERlZmluaXRpb24ucXVlcnkgPyBcImBiYXNlUXVlcnlgXCIgOiBcImBxdWVyeUZuYFwiO1xuICAgICAgICBsZXQgZXJyO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgIGVyciA9IGAke3doYXR9IGRpZCBub3QgcmV0dXJuIGFueXRoaW5nLmA7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlc3VsdCAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGVyciA9IGAke3doYXR9IGRpZCBub3QgcmV0dXJuIGFuIG9iamVjdC5gO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5lcnJvciAmJiByZXN1bHQuZGF0YSkge1xuICAgICAgICAgIGVyciA9IGAke3doYXR9IHJldHVybmVkIGFuIG9iamVjdCBjb250YWluaW5nIGJvdGggXFxgZXJyb3JcXGAgYW5kIFxcYHJlc3VsdFxcYC5gO1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5lcnJvciA9PT0gdm9pZCAwICYmIHJlc3VsdC5kYXRhID09PSB2b2lkIDApIHtcbiAgICAgICAgICBlcnIgPSBgJHt3aGF0fSByZXR1cm5lZCBhbiBvYmplY3QgY29udGFpbmluZyBuZWl0aGVyIGEgdmFsaWQgXFxgZXJyb3JcXGAgYW5kIFxcYHJlc3VsdFxcYC4gQXQgbGVhc3Qgb25lIG9mIHRoZW0gc2hvdWxkIG5vdCBiZSBcXGB1bmRlZmluZWRcXGBgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgIT09IFwiZXJyb3JcIiAmJiBrZXkgIT09IFwiZGF0YVwiICYmIGtleSAhPT0gXCJtZXRhXCIpIHtcbiAgICAgICAgICAgICAgZXJyID0gYFRoZSBvYmplY3QgcmV0dXJuZWQgYnkgJHt3aGF0fSBoYXMgdGhlIHVua25vd24gcHJvcGVydHkgJHtrZXl9LmA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZW5jb3VudGVyZWQgaGFuZGxpbmcgdGhlIGVuZHBvaW50ICR7YXJnLmVuZHBvaW50TmFtZX0uXG4gICAgICAgICAgICAgICR7ZXJyfVxuICAgICAgICAgICAgICBJdCBuZWVkcyB0byByZXR1cm4gYW4gb2JqZWN0IHdpdGggZWl0aGVyIHRoZSBzaGFwZSBcXGB7IGRhdGE6IDx2YWx1ZT4gfVxcYCBvciBcXGB7IGVycm9yOiA8dmFsdWU+IH1cXGAgdGhhdCBtYXkgY29udGFpbiBhbiBvcHRpb25hbCBcXGBtZXRhXFxgIHByb3BlcnR5LlxuICAgICAgICAgICAgICBPYmplY3QgcmV0dXJuZWQgd2FzOmAsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQuZXJyb3IpXG4gICAgICAgIHRocm93IG5ldyBIYW5kbGVkRXJyb3IocmVzdWx0LmVycm9yLCByZXN1bHQubWV0YSk7XG4gICAgICByZXR1cm4gZnVsZmlsbFdpdGhWYWx1ZShhd2FpdCB0cmFuc2Zvcm1SZXNwb25zZShyZXN1bHQuZGF0YSwgcmVzdWx0Lm1ldGEsIGFyZy5vcmlnaW5hbEFyZ3MpLCB7XG4gICAgICAgIGZ1bGZpbGxlZFRpbWVTdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgYmFzZVF1ZXJ5TWV0YTogcmVzdWx0Lm1ldGEsXG4gICAgICAgIFtTSE9VTERfQVVUT0JBVENIXTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxldCBjYXRjaGVkRXJyb3IgPSBlcnJvcjtcbiAgICAgIGlmIChjYXRjaGVkRXJyb3IgaW5zdGFuY2VvZiBIYW5kbGVkRXJyb3IpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybUVycm9yUmVzcG9uc2UgPSBkZWZhdWx0VHJhbnNmb3JtUmVzcG9uc2U7XG4gICAgICAgIGlmIChlbmRwb2ludERlZmluaXRpb24ucXVlcnkgJiYgZW5kcG9pbnREZWZpbml0aW9uLnRyYW5zZm9ybUVycm9yUmVzcG9uc2UpIHtcbiAgICAgICAgICB0cmFuc2Zvcm1FcnJvclJlc3BvbnNlID0gZW5kcG9pbnREZWZpbml0aW9uLnRyYW5zZm9ybUVycm9yUmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0V2l0aFZhbHVlKGF3YWl0IHRyYW5zZm9ybUVycm9yUmVzcG9uc2UoY2F0Y2hlZEVycm9yLnZhbHVlLCBjYXRjaGVkRXJyb3IubWV0YSwgYXJnLm9yaWdpbmFsQXJncyksIHtcbiAgICAgICAgICAgIGJhc2VRdWVyeU1ldGE6IGNhdGNoZWRFcnJvci5tZXRhLFxuICAgICAgICAgICAgW1NIT1VMRF9BVVRPQkFUQ0hdOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjYXRjaGVkRXJyb3IgPSBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEFuIHVuaGFuZGxlZCBlcnJvciBvY2N1cnJlZCBwcm9jZXNzaW5nIGEgcmVxdWVzdCBmb3IgdGhlIGVuZHBvaW50IFwiJHthcmcuZW5kcG9pbnROYW1lfVwiLlxuSW4gdGhlIGNhc2Ugb2YgYW4gdW5oYW5kbGVkIGVycm9yLCBubyB0YWdzIHdpbGwgYmUgXCJwcm92aWRlZFwiIG9yIFwiaW52YWxpZGF0ZWRcIi5gLCBjYXRjaGVkRXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihjYXRjaGVkRXJyb3IpO1xuICAgICAgfVxuICAgICAgdGhyb3cgY2F0Y2hlZEVycm9yO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gaXNGb3JjZWRRdWVyeShhcmcsIHN0YXRlKSB7XG4gICAgY29uc3QgcmVxdWVzdFN0YXRlID0gc3RhdGVbcmVkdWNlclBhdGhdPy5xdWVyaWVzPy5bYXJnLnF1ZXJ5Q2FjaGVLZXldO1xuICAgIGNvbnN0IGJhc2VGZXRjaE9uTW91bnRPckFyZ0NoYW5nZSA9IHN0YXRlW3JlZHVjZXJQYXRoXT8uY29uZmlnLnJlZmV0Y2hPbk1vdW50T3JBcmdDaGFuZ2U7XG4gICAgY29uc3QgZnVsZmlsbGVkVmFsID0gcmVxdWVzdFN0YXRlPy5mdWxmaWxsZWRUaW1lU3RhbXA7XG4gICAgY29uc3QgcmVmZXRjaFZhbCA9IGFyZy5mb3JjZVJlZmV0Y2ggPz8gKGFyZy5zdWJzY3JpYmUgJiYgYmFzZUZldGNoT25Nb3VudE9yQXJnQ2hhbmdlKTtcbiAgICBpZiAocmVmZXRjaFZhbCkge1xuICAgICAgcmV0dXJuIHJlZmV0Y2hWYWwgPT09IHRydWUgfHwgKE51bWJlcigvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkgLSBOdW1iZXIoZnVsZmlsbGVkVmFsKSkgLyAxZTMgPj0gcmVmZXRjaFZhbDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHF1ZXJ5VGh1bmsgPSBjcmVhdGVBc3luY1RodW5rKGAke3JlZHVjZXJQYXRofS9leGVjdXRlUXVlcnlgLCBleGVjdXRlRW5kcG9pbnQsIHtcbiAgICBnZXRQZW5kaW5nTWV0YSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0ZWRUaW1lU3RhbXA6IERhdGUubm93KCksXG4gICAgICAgIFtTSE9VTERfQVVUT0JBVENIXTogdHJ1ZVxuICAgICAgfTtcbiAgICB9LFxuICAgIGNvbmRpdGlvbihxdWVyeVRodW5rQXJncywge1xuICAgICAgZ2V0U3RhdGVcbiAgICB9KSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgICBjb25zdCByZXF1ZXN0U3RhdGUgPSBzdGF0ZVtyZWR1Y2VyUGF0aF0/LnF1ZXJpZXM/LltxdWVyeVRodW5rQXJncy5xdWVyeUNhY2hlS2V5XTtcbiAgICAgIGNvbnN0IGZ1bGZpbGxlZFZhbCA9IHJlcXVlc3RTdGF0ZT8uZnVsZmlsbGVkVGltZVN0YW1wO1xuICAgICAgY29uc3QgY3VycmVudEFyZyA9IHF1ZXJ5VGh1bmtBcmdzLm9yaWdpbmFsQXJncztcbiAgICAgIGNvbnN0IHByZXZpb3VzQXJnID0gcmVxdWVzdFN0YXRlPy5vcmlnaW5hbEFyZ3M7XG4gICAgICBjb25zdCBlbmRwb2ludERlZmluaXRpb24gPSBlbmRwb2ludERlZmluaXRpb25zW3F1ZXJ5VGh1bmtBcmdzLmVuZHBvaW50TmFtZV07XG4gICAgICBpZiAoaXNVcHNlcnRRdWVyeShxdWVyeVRodW5rQXJncykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocmVxdWVzdFN0YXRlPy5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0ZvcmNlZFF1ZXJ5KHF1ZXJ5VGh1bmtBcmdzLCBzdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNRdWVyeURlZmluaXRpb24oZW5kcG9pbnREZWZpbml0aW9uKSAmJiBlbmRwb2ludERlZmluaXRpb24/LmZvcmNlUmVmZXRjaD8uKHtcbiAgICAgICAgY3VycmVudEFyZyxcbiAgICAgICAgcHJldmlvdXNBcmcsXG4gICAgICAgIGVuZHBvaW50U3RhdGU6IHJlcXVlc3RTdGF0ZSxcbiAgICAgICAgc3RhdGVcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGZ1bGZpbGxlZFZhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGRpc3BhdGNoQ29uZGl0aW9uUmVqZWN0aW9uOiB0cnVlXG4gIH0pO1xuICBjb25zdCBtdXRhdGlvblRodW5rID0gY3JlYXRlQXN5bmNUaHVuayhgJHtyZWR1Y2VyUGF0aH0vZXhlY3V0ZU11dGF0aW9uYCwgZXhlY3V0ZUVuZHBvaW50LCB7XG4gICAgZ2V0UGVuZGluZ01ldGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFydGVkVGltZVN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICBbU0hPVUxEX0FVVE9CQVRDSF06IHRydWVcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbiAgY29uc3QgaGFzVGhlRm9yY2UgPSAob3B0aW9ucykgPT4gXCJmb3JjZVwiIGluIG9wdGlvbnM7XG4gIGNvbnN0IGhhc01heEFnZSA9IChvcHRpb25zKSA9PiBcImlmT2xkZXJUaGFuXCIgaW4gb3B0aW9ucztcbiAgY29uc3QgcHJlZmV0Y2ggPSAoZW5kcG9pbnROYW1lLCBhcmcsIG9wdGlvbnMpID0+IChkaXNwYXRjaCwgZ2V0U3RhdGUpID0+IHtcbiAgICBjb25zdCBmb3JjZSA9IGhhc1RoZUZvcmNlKG9wdGlvbnMpICYmIG9wdGlvbnMuZm9yY2U7XG4gICAgY29uc3QgbWF4QWdlID0gaGFzTWF4QWdlKG9wdGlvbnMpICYmIG9wdGlvbnMuaWZPbGRlclRoYW47XG4gICAgY29uc3QgcXVlcnlBY3Rpb24gPSAoZm9yY2UyID0gdHJ1ZSkgPT4gYXBpLmVuZHBvaW50c1tlbmRwb2ludE5hbWVdLmluaXRpYXRlKGFyZywge1xuICAgICAgZm9yY2VSZWZldGNoOiBmb3JjZTJcbiAgICB9KTtcbiAgICBjb25zdCBsYXRlc3RTdGF0ZVZhbHVlID0gYXBpLmVuZHBvaW50c1tlbmRwb2ludE5hbWVdLnNlbGVjdChhcmcpKGdldFN0YXRlKCkpO1xuICAgIGlmIChmb3JjZSkge1xuICAgICAgZGlzcGF0Y2gocXVlcnlBY3Rpb24oKSk7XG4gICAgfSBlbHNlIGlmIChtYXhBZ2UpIHtcbiAgICAgIGNvbnN0IGxhc3RGdWxmaWxsZWRUcyA9IGxhdGVzdFN0YXRlVmFsdWU/LmZ1bGZpbGxlZFRpbWVTdGFtcDtcbiAgICAgIGlmICghbGFzdEZ1bGZpbGxlZFRzKSB7XG4gICAgICAgIGRpc3BhdGNoKHF1ZXJ5QWN0aW9uKCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzaG91bGRSZXRyaWdnZXIgPSAoTnVtYmVyKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKSAtIE51bWJlcihuZXcgRGF0ZShsYXN0RnVsZmlsbGVkVHMpKSkgLyAxZTMgPj0gbWF4QWdlO1xuICAgICAgaWYgKHNob3VsZFJldHJpZ2dlcikge1xuICAgICAgICBkaXNwYXRjaChxdWVyeUFjdGlvbigpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGlzcGF0Y2gocXVlcnlBY3Rpb24oZmFsc2UpKTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIG1hdGNoZXNFbmRwb2ludChlbmRwb2ludE5hbWUpIHtcbiAgICByZXR1cm4gKGFjdGlvbikgPT4gYWN0aW9uPy5tZXRhPy5hcmc/LmVuZHBvaW50TmFtZSA9PT0gZW5kcG9pbnROYW1lO1xuICB9XG4gIGZ1bmN0aW9uIGJ1aWxkTWF0Y2hUaHVua0FjdGlvbnModGh1bmssIGVuZHBvaW50TmFtZSkge1xuICAgIHJldHVybiB7XG4gICAgICBtYXRjaFBlbmRpbmc6IGlzQWxsT2YoaXNQZW5kaW5nKHRodW5rKSwgbWF0Y2hlc0VuZHBvaW50KGVuZHBvaW50TmFtZSkpLFxuICAgICAgbWF0Y2hGdWxmaWxsZWQ6IGlzQWxsT2YoaXNGdWxmaWxsZWQodGh1bmspLCBtYXRjaGVzRW5kcG9pbnQoZW5kcG9pbnROYW1lKSksXG4gICAgICBtYXRjaFJlamVjdGVkOiBpc0FsbE9mKGlzUmVqZWN0ZWQodGh1bmspLCBtYXRjaGVzRW5kcG9pbnQoZW5kcG9pbnROYW1lKSlcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgcXVlcnlUaHVuayxcbiAgICBtdXRhdGlvblRodW5rLFxuICAgIHByZWZldGNoLFxuICAgIHVwZGF0ZVF1ZXJ5RGF0YSxcbiAgICB1cHNlcnRRdWVyeURhdGEsXG4gICAgcGF0Y2hRdWVyeURhdGEsXG4gICAgYnVpbGRNYXRjaFRodW5rQWN0aW9uc1xuICB9O1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlUHJvdmlkZWRCeVRodW5rKGFjdGlvbiwgdHlwZSwgZW5kcG9pbnREZWZpbml0aW9ucywgYXNzZXJ0VGFnVHlwZSkge1xuICByZXR1cm4gY2FsY3VsYXRlUHJvdmlkZWRCeShlbmRwb2ludERlZmluaXRpb25zW2FjdGlvbi5tZXRhLmFyZy5lbmRwb2ludE5hbWVdW3R5cGVdLCBpc0Z1bGZpbGxlZChhY3Rpb24pID8gYWN0aW9uLnBheWxvYWQgOiB2b2lkIDAsIGlzUmVqZWN0ZWRXaXRoVmFsdWUoYWN0aW9uKSA/IGFjdGlvbi5wYXlsb2FkIDogdm9pZCAwLCBhY3Rpb24ubWV0YS5hcmcub3JpZ2luYWxBcmdzLCBcImJhc2VRdWVyeU1ldGFcIiBpbiBhY3Rpb24ubWV0YSA/IGFjdGlvbi5tZXRhLmJhc2VRdWVyeU1ldGEgOiB2b2lkIDAsIGFzc2VydFRhZ1R5cGUpO1xufVxuXG4vLyBzcmMvcXVlcnkvY29yZS9idWlsZFNsaWNlLnRzXG5pbXBvcnQgeyBpc0RyYWZ0IH0gZnJvbSBcImltbWVyXCI7XG5pbXBvcnQgeyBhcHBseVBhdGNoZXMsIG9yaWdpbmFsIH0gZnJvbSBcImltbWVyXCI7XG5mdW5jdGlvbiB1cGRhdGVRdWVyeVN1YnN0YXRlSWZFeGlzdHMoc3RhdGUsIHF1ZXJ5Q2FjaGVLZXksIHVwZGF0ZSkge1xuICBjb25zdCBzdWJzdGF0ZSA9IHN0YXRlW3F1ZXJ5Q2FjaGVLZXldO1xuICBpZiAoc3Vic3RhdGUpIHtcbiAgICB1cGRhdGUoc3Vic3RhdGUpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRNdXRhdGlvbkNhY2hlS2V5KGlkKSB7XG4gIHJldHVybiAoXCJhcmdcIiBpbiBpZCA/IGlkLmFyZy5maXhlZENhY2hlS2V5IDogaWQuZml4ZWRDYWNoZUtleSkgPz8gaWQucmVxdWVzdElkO1xufVxuZnVuY3Rpb24gdXBkYXRlTXV0YXRpb25TdWJzdGF0ZUlmRXhpc3RzKHN0YXRlLCBpZCwgdXBkYXRlKSB7XG4gIGNvbnN0IHN1YnN0YXRlID0gc3RhdGVbZ2V0TXV0YXRpb25DYWNoZUtleShpZCldO1xuICBpZiAoc3Vic3RhdGUpIHtcbiAgICB1cGRhdGUoc3Vic3RhdGUpO1xuICB9XG59XG52YXIgaW5pdGlhbFN0YXRlID0ge307XG5mdW5jdGlvbiBidWlsZFNsaWNlKHtcbiAgcmVkdWNlclBhdGgsXG4gIHF1ZXJ5VGh1bmssXG4gIG11dGF0aW9uVGh1bmssXG4gIGNvbnRleHQ6IHtcbiAgICBlbmRwb2ludERlZmluaXRpb25zOiBkZWZpbml0aW9ucyxcbiAgICBhcGlVaWQsXG4gICAgZXh0cmFjdFJlaHlkcmF0aW9uSW5mbyxcbiAgICBoYXNSZWh5ZHJhdGlvbkluZm9cbiAgfSxcbiAgYXNzZXJ0VGFnVHlwZSxcbiAgY29uZmlnXG59KSB7XG4gIGNvbnN0IHJlc2V0QXBpU3RhdGUgPSBjcmVhdGVBY3Rpb24oYCR7cmVkdWNlclBhdGh9L3Jlc2V0QXBpU3RhdGVgKTtcbiAgY29uc3QgcXVlcnlTbGljZSA9IGNyZWF0ZVNsaWNlKHtcbiAgICBuYW1lOiBgJHtyZWR1Y2VyUGF0aH0vcXVlcmllc2AsXG4gICAgaW5pdGlhbFN0YXRlLFxuICAgIHJlZHVjZXJzOiB7XG4gICAgICByZW1vdmVRdWVyeVJlc3VsdDoge1xuICAgICAgICByZWR1Y2VyKGRyYWZ0LCB7XG4gICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgcXVlcnlDYWNoZUtleVxuICAgICAgICAgIH1cbiAgICAgICAgfSkge1xuICAgICAgICAgIGRlbGV0ZSBkcmFmdFtxdWVyeUNhY2hlS2V5XTtcbiAgICAgICAgfSxcbiAgICAgICAgcHJlcGFyZTogcHJlcGFyZUF1dG9CYXRjaGVkKClcbiAgICAgIH0sXG4gICAgICBxdWVyeVJlc3VsdFBhdGNoZWQ6IHtcbiAgICAgICAgcmVkdWNlcihkcmFmdCwge1xuICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXksXG4gICAgICAgICAgICBwYXRjaGVzXG4gICAgICAgICAgfVxuICAgICAgICB9KSB7XG4gICAgICAgICAgdXBkYXRlUXVlcnlTdWJzdGF0ZUlmRXhpc3RzKGRyYWZ0LCBxdWVyeUNhY2hlS2V5LCAoc3Vic3RhdGUpID0+IHtcbiAgICAgICAgICAgIHN1YnN0YXRlLmRhdGEgPSBhcHBseVBhdGNoZXMoc3Vic3RhdGUuZGF0YSwgcGF0Y2hlcy5jb25jYXQoKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHByZXBhcmU6IHByZXBhcmVBdXRvQmF0Y2hlZCgpXG4gICAgICB9XG4gICAgfSxcbiAgICBleHRyYVJlZHVjZXJzKGJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuYWRkQ2FzZShxdWVyeVRodW5rLnBlbmRpbmcsIChkcmFmdCwge1xuICAgICAgICBtZXRhLFxuICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgYXJnXG4gICAgICAgIH1cbiAgICAgIH0pID0+IHtcbiAgICAgICAgY29uc3QgdXBzZXJ0aW5nID0gaXNVcHNlcnRRdWVyeShhcmcpO1xuICAgICAgICBkcmFmdFthcmcucXVlcnlDYWNoZUtleV0gPz89IHtcbiAgICAgICAgICBzdGF0dXM6IFwidW5pbml0aWFsaXplZFwiIC8qIHVuaW5pdGlhbGl6ZWQgKi8sXG4gICAgICAgICAgZW5kcG9pbnROYW1lOiBhcmcuZW5kcG9pbnROYW1lXG4gICAgICAgIH07XG4gICAgICAgIHVwZGF0ZVF1ZXJ5U3Vic3RhdGVJZkV4aXN0cyhkcmFmdCwgYXJnLnF1ZXJ5Q2FjaGVLZXksIChzdWJzdGF0ZSkgPT4ge1xuICAgICAgICAgIHN1YnN0YXRlLnN0YXR1cyA9IFwicGVuZGluZ1wiIC8qIHBlbmRpbmcgKi87XG4gICAgICAgICAgc3Vic3RhdGUucmVxdWVzdElkID0gdXBzZXJ0aW5nICYmIHN1YnN0YXRlLnJlcXVlc3RJZCA/IChcbiAgICAgICAgICAgIC8vIGZvciBgdXBzZXJ0UXVlcnlgICoqdXBkYXRlcyoqLCBrZWVwIHRoZSBjdXJyZW50IGByZXF1ZXN0SWRgXG4gICAgICAgICAgICBzdWJzdGF0ZS5yZXF1ZXN0SWRcbiAgICAgICAgICApIDogKFxuICAgICAgICAgICAgLy8gZm9yIG5vcm1hbCBxdWVyaWVzIG9yIGB1cHNlcnRRdWVyeWAgKippbnNlcnRzKiogYWx3YXlzIHVwZGF0ZSB0aGUgYHJlcXVlc3RJZGBcbiAgICAgICAgICAgIG1ldGEucmVxdWVzdElkXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoYXJnLm9yaWdpbmFsQXJncyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBzdWJzdGF0ZS5vcmlnaW5hbEFyZ3MgPSBhcmcub3JpZ2luYWxBcmdzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdWJzdGF0ZS5zdGFydGVkVGltZVN0YW1wID0gbWV0YS5zdGFydGVkVGltZVN0YW1wO1xuICAgICAgICB9KTtcbiAgICAgIH0pLmFkZENhc2UocXVlcnlUaHVuay5mdWxmaWxsZWQsIChkcmFmdCwge1xuICAgICAgICBtZXRhLFxuICAgICAgICBwYXlsb2FkXG4gICAgICB9KSA9PiB7XG4gICAgICAgIHVwZGF0ZVF1ZXJ5U3Vic3RhdGVJZkV4aXN0cyhkcmFmdCwgbWV0YS5hcmcucXVlcnlDYWNoZUtleSwgKHN1YnN0YXRlKSA9PiB7XG4gICAgICAgICAgaWYgKHN1YnN0YXRlLnJlcXVlc3RJZCAhPT0gbWV0YS5yZXF1ZXN0SWQgJiYgIWlzVXBzZXJ0UXVlcnkobWV0YS5hcmcpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIG1lcmdlXG4gICAgICAgICAgfSA9IGRlZmluaXRpb25zW21ldGEuYXJnLmVuZHBvaW50TmFtZV07XG4gICAgICAgICAgc3Vic3RhdGUuc3RhdHVzID0gXCJmdWxmaWxsZWRcIiAvKiBmdWxmaWxsZWQgKi87XG4gICAgICAgICAgaWYgKG1lcmdlKSB7XG4gICAgICAgICAgICBpZiAoc3Vic3RhdGUuZGF0YSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBmdWxmaWxsZWRUaW1lU3RhbXAsXG4gICAgICAgICAgICAgICAgYXJnLFxuICAgICAgICAgICAgICAgIGJhc2VRdWVyeU1ldGEsXG4gICAgICAgICAgICAgICAgcmVxdWVzdElkXG4gICAgICAgICAgICAgIH0gPSBtZXRhO1xuICAgICAgICAgICAgICBsZXQgbmV3RGF0YSA9IGNyZWF0ZU5leHRTdGF0ZShzdWJzdGF0ZS5kYXRhLCAoZHJhZnRTdWJzdGF0ZURhdGEpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2UoZHJhZnRTdWJzdGF0ZURhdGEsIHBheWxvYWQsIHtcbiAgICAgICAgICAgICAgICAgIGFyZzogYXJnLm9yaWdpbmFsQXJncyxcbiAgICAgICAgICAgICAgICAgIGJhc2VRdWVyeU1ldGEsXG4gICAgICAgICAgICAgICAgICBmdWxmaWxsZWRUaW1lU3RhbXAsXG4gICAgICAgICAgICAgICAgICByZXF1ZXN0SWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHN1YnN0YXRlLmRhdGEgPSBuZXdEYXRhO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3Vic3RhdGUuZGF0YSA9IHBheWxvYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1YnN0YXRlLmRhdGEgPSBkZWZpbml0aW9uc1ttZXRhLmFyZy5lbmRwb2ludE5hbWVdLnN0cnVjdHVyYWxTaGFyaW5nID8/IHRydWUgPyBjb3B5V2l0aFN0cnVjdHVyYWxTaGFyaW5nKGlzRHJhZnQoc3Vic3RhdGUuZGF0YSkgPyBvcmlnaW5hbChzdWJzdGF0ZS5kYXRhKSA6IHN1YnN0YXRlLmRhdGEsIHBheWxvYWQpIDogcGF5bG9hZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVsZXRlIHN1YnN0YXRlLmVycm9yO1xuICAgICAgICAgIHN1YnN0YXRlLmZ1bGZpbGxlZFRpbWVTdGFtcCA9IG1ldGEuZnVsZmlsbGVkVGltZVN0YW1wO1xuICAgICAgICB9KTtcbiAgICAgIH0pLmFkZENhc2UocXVlcnlUaHVuay5yZWplY3RlZCwgKGRyYWZ0LCB7XG4gICAgICAgIG1ldGE6IHtcbiAgICAgICAgICBjb25kaXRpb24sXG4gICAgICAgICAgYXJnLFxuICAgICAgICAgIHJlcXVlc3RJZFxuICAgICAgICB9LFxuICAgICAgICBlcnJvcixcbiAgICAgICAgcGF5bG9hZFxuICAgICAgfSkgPT4ge1xuICAgICAgICB1cGRhdGVRdWVyeVN1YnN0YXRlSWZFeGlzdHMoZHJhZnQsIGFyZy5xdWVyeUNhY2hlS2V5LCAoc3Vic3RhdGUpID0+IHtcbiAgICAgICAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzdWJzdGF0ZS5yZXF1ZXN0SWQgIT09IHJlcXVlc3RJZClcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc3Vic3RhdGUuc3RhdHVzID0gXCJyZWplY3RlZFwiIC8qIHJlamVjdGVkICovO1xuICAgICAgICAgICAgc3Vic3RhdGUuZXJyb3IgPSBwYXlsb2FkID8/IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KS5hZGRNYXRjaGVyKGhhc1JlaHlkcmF0aW9uSW5mbywgKGRyYWZ0LCBhY3Rpb24pID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHF1ZXJpZXNcbiAgICAgICAgfSA9IGV4dHJhY3RSZWh5ZHJhdGlvbkluZm8oYWN0aW9uKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCBlbnRyeV0gb2YgT2JqZWN0LmVudHJpZXMocXVlcmllcykpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBkbyBub3QgcmVoeWRyYXRlIGVudHJpZXMgdGhhdCB3ZXJlIGN1cnJlbnRseSBpbiBmbGlnaHQuXG4gICAgICAgICAgICBlbnRyeT8uc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiIC8qIGZ1bGZpbGxlZCAqLyB8fCBlbnRyeT8uc3RhdHVzID09PSBcInJlamVjdGVkXCIgLyogcmVqZWN0ZWQgKi9cbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGRyYWZ0W2tleV0gPSBlbnRyeTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IG11dGF0aW9uU2xpY2UgPSBjcmVhdGVTbGljZSh7XG4gICAgbmFtZTogYCR7cmVkdWNlclBhdGh9L211dGF0aW9uc2AsXG4gICAgaW5pdGlhbFN0YXRlLFxuICAgIHJlZHVjZXJzOiB7XG4gICAgICByZW1vdmVNdXRhdGlvblJlc3VsdDoge1xuICAgICAgICByZWR1Y2VyKGRyYWZ0LCB7XG4gICAgICAgICAgcGF5bG9hZFxuICAgICAgICB9KSB7XG4gICAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBnZXRNdXRhdGlvbkNhY2hlS2V5KHBheWxvYWQpO1xuICAgICAgICAgIGlmIChjYWNoZUtleSBpbiBkcmFmdCkge1xuICAgICAgICAgICAgZGVsZXRlIGRyYWZ0W2NhY2hlS2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHByZXBhcmU6IHByZXBhcmVBdXRvQmF0Y2hlZCgpXG4gICAgICB9XG4gICAgfSxcbiAgICBleHRyYVJlZHVjZXJzKGJ1aWxkZXIpIHtcbiAgICAgIGJ1aWxkZXIuYWRkQ2FzZShtdXRhdGlvblRodW5rLnBlbmRpbmcsIChkcmFmdCwge1xuICAgICAgICBtZXRhLFxuICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgIGFyZyxcbiAgICAgICAgICBzdGFydGVkVGltZVN0YW1wXG4gICAgICAgIH1cbiAgICAgIH0pID0+IHtcbiAgICAgICAgaWYgKCFhcmcudHJhY2spXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBkcmFmdFtnZXRNdXRhdGlvbkNhY2hlS2V5KG1ldGEpXSA9IHtcbiAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgc3RhdHVzOiBcInBlbmRpbmdcIiAvKiBwZW5kaW5nICovLFxuICAgICAgICAgIGVuZHBvaW50TmFtZTogYXJnLmVuZHBvaW50TmFtZSxcbiAgICAgICAgICBzdGFydGVkVGltZVN0YW1wXG4gICAgICAgIH07XG4gICAgICB9KS5hZGRDYXNlKG11dGF0aW9uVGh1bmsuZnVsZmlsbGVkLCAoZHJhZnQsIHtcbiAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgbWV0YVxuICAgICAgfSkgPT4ge1xuICAgICAgICBpZiAoIW1ldGEuYXJnLnRyYWNrKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdXBkYXRlTXV0YXRpb25TdWJzdGF0ZUlmRXhpc3RzKGRyYWZ0LCBtZXRhLCAoc3Vic3RhdGUpID0+IHtcbiAgICAgICAgICBpZiAoc3Vic3RhdGUucmVxdWVzdElkICE9PSBtZXRhLnJlcXVlc3RJZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBzdWJzdGF0ZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiIC8qIGZ1bGZpbGxlZCAqLztcbiAgICAgICAgICBzdWJzdGF0ZS5kYXRhID0gcGF5bG9hZDtcbiAgICAgICAgICBzdWJzdGF0ZS5mdWxmaWxsZWRUaW1lU3RhbXAgPSBtZXRhLmZ1bGZpbGxlZFRpbWVTdGFtcDtcbiAgICAgICAgfSk7XG4gICAgICB9KS5hZGRDYXNlKG11dGF0aW9uVGh1bmsucmVqZWN0ZWQsIChkcmFmdCwge1xuICAgICAgICBwYXlsb2FkLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgbWV0YVxuICAgICAgfSkgPT4ge1xuICAgICAgICBpZiAoIW1ldGEuYXJnLnRyYWNrKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdXBkYXRlTXV0YXRpb25TdWJzdGF0ZUlmRXhpc3RzKGRyYWZ0LCBtZXRhLCAoc3Vic3RhdGUpID0+IHtcbiAgICAgICAgICBpZiAoc3Vic3RhdGUucmVxdWVzdElkICE9PSBtZXRhLnJlcXVlc3RJZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBzdWJzdGF0ZS5zdGF0dXMgPSBcInJlamVjdGVkXCIgLyogcmVqZWN0ZWQgKi87XG4gICAgICAgICAgc3Vic3RhdGUuZXJyb3IgPSBwYXlsb2FkID8/IGVycm9yO1xuICAgICAgICB9KTtcbiAgICAgIH0pLmFkZE1hdGNoZXIoaGFzUmVoeWRyYXRpb25JbmZvLCAoZHJhZnQsIGFjdGlvbikgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbXV0YXRpb25zXG4gICAgICAgIH0gPSBleHRyYWN0UmVoeWRyYXRpb25JbmZvKGFjdGlvbik7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgZW50cnldIG9mIE9iamVjdC5lbnRyaWVzKG11dGF0aW9ucykpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBkbyBub3QgcmVoeWRyYXRlIGVudHJpZXMgdGhhdCB3ZXJlIGN1cnJlbnRseSBpbiBmbGlnaHQuXG4gICAgICAgICAgICAoZW50cnk/LnN0YXR1cyA9PT0gXCJmdWxmaWxsZWRcIiAvKiBmdWxmaWxsZWQgKi8gfHwgZW50cnk/LnN0YXR1cyA9PT0gXCJyZWplY3RlZFwiIC8qIHJlamVjdGVkICovKSAmJiAvLyBvbmx5IHJlaHlkcmF0ZSBlbmRwb2ludHMgdGhhdCB3ZXJlIHBlcnNpc3RlZCB1c2luZyBhIGBmaXhlZENhY2hlS2V5YFxuICAgICAgICAgICAga2V5ICE9PSBlbnRyeT8ucmVxdWVzdElkXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBkcmFmdFtrZXldID0gZW50cnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBpbnZhbGlkYXRpb25TbGljZSA9IGNyZWF0ZVNsaWNlKHtcbiAgICBuYW1lOiBgJHtyZWR1Y2VyUGF0aH0vaW52YWxpZGF0aW9uYCxcbiAgICBpbml0aWFsU3RhdGUsXG4gICAgcmVkdWNlcnM6IHtcbiAgICAgIHVwZGF0ZVByb3ZpZGVkQnk6IHtcbiAgICAgICAgcmVkdWNlcihkcmFmdCwgYWN0aW9uKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgcXVlcnlDYWNoZUtleSxcbiAgICAgICAgICAgIHByb3ZpZGVkVGFnc1xuICAgICAgICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgICAgICBmb3IgKGNvbnN0IHRhZ1R5cGVTdWJzY3JpcHRpb25zIG9mIE9iamVjdC52YWx1ZXMoZHJhZnQpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlkU3Vic2NyaXB0aW9ucyBvZiBPYmplY3QudmFsdWVzKHRhZ1R5cGVTdWJzY3JpcHRpb25zKSkge1xuICAgICAgICAgICAgICBjb25zdCBmb3VuZEF0ID0gaWRTdWJzY3JpcHRpb25zLmluZGV4T2YocXVlcnlDYWNoZUtleSk7XG4gICAgICAgICAgICAgIGlmIChmb3VuZEF0ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlkU3Vic2NyaXB0aW9ucy5zcGxpY2UoZm91bmRBdCwgMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgaWRcbiAgICAgICAgICB9IG9mIHByb3ZpZGVkVGFncykge1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlZFF1ZXJpZXMgPSAoZHJhZnRbdHlwZV0gPz89IHt9KVtpZCB8fCBcIl9faW50ZXJuYWxfd2l0aG91dF9pZFwiXSA/Pz0gW107XG4gICAgICAgICAgICBjb25zdCBhbHJlYWR5U3Vic2NyaWJlZCA9IHN1YnNjcmliZWRRdWVyaWVzLmluY2x1ZGVzKHF1ZXJ5Q2FjaGVLZXkpO1xuICAgICAgICAgICAgaWYgKCFhbHJlYWR5U3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgICBzdWJzY3JpYmVkUXVlcmllcy5wdXNoKHF1ZXJ5Q2FjaGVLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcHJlcGFyZTogcHJlcGFyZUF1dG9CYXRjaGVkKClcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4dHJhUmVkdWNlcnMoYnVpbGRlcikge1xuICAgICAgYnVpbGRlci5hZGRDYXNlKHF1ZXJ5U2xpY2UuYWN0aW9ucy5yZW1vdmVRdWVyeVJlc3VsdCwgKGRyYWZ0LCB7XG4gICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICBxdWVyeUNhY2hlS2V5XG4gICAgICAgIH1cbiAgICAgIH0pID0+IHtcbiAgICAgICAgZm9yIChjb25zdCB0YWdUeXBlU3Vic2NyaXB0aW9ucyBvZiBPYmplY3QudmFsdWVzKGRyYWZ0KSkge1xuICAgICAgICAgIGZvciAoY29uc3QgaWRTdWJzY3JpcHRpb25zIG9mIE9iamVjdC52YWx1ZXModGFnVHlwZVN1YnNjcmlwdGlvbnMpKSB7XG4gICAgICAgICAgICBjb25zdCBmb3VuZEF0ID0gaWRTdWJzY3JpcHRpb25zLmluZGV4T2YocXVlcnlDYWNoZUtleSk7XG4gICAgICAgICAgICBpZiAoZm91bmRBdCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgaWRTdWJzY3JpcHRpb25zLnNwbGljZShmb3VuZEF0LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pLmFkZE1hdGNoZXIoaGFzUmVoeWRyYXRpb25JbmZvLCAoZHJhZnQsIGFjdGlvbikgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcHJvdmlkZWRcbiAgICAgICAgfSA9IGV4dHJhY3RSZWh5ZHJhdGlvbkluZm8oYWN0aW9uKTtcbiAgICAgICAgZm9yIChjb25zdCBbdHlwZSwgaW5jb21pbmdUYWdzXSBvZiBPYmplY3QuZW50cmllcyhwcm92aWRlZCkpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtpZCwgY2FjaGVLZXlzXSBvZiBPYmplY3QuZW50cmllcyhpbmNvbWluZ1RhZ3MpKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpYmVkUXVlcmllcyA9IChkcmFmdFt0eXBlXSA/Pz0ge30pW2lkIHx8IFwiX19pbnRlcm5hbF93aXRob3V0X2lkXCJdID8/PSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcXVlcnlDYWNoZUtleSBvZiBjYWNoZUtleXMpIHtcbiAgICAgICAgICAgICAgY29uc3QgYWxyZWFkeVN1YnNjcmliZWQgPSBzdWJzY3JpYmVkUXVlcmllcy5pbmNsdWRlcyhxdWVyeUNhY2hlS2V5KTtcbiAgICAgICAgICAgICAgaWYgKCFhbHJlYWR5U3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZWRRdWVyaWVzLnB1c2gocXVlcnlDYWNoZUtleSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pLmFkZE1hdGNoZXIoaXNBbnlPZihpc0Z1bGZpbGxlZChxdWVyeVRodW5rKSwgaXNSZWplY3RlZFdpdGhWYWx1ZShxdWVyeVRodW5rKSksIChkcmFmdCwgYWN0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVkVGFncyA9IGNhbGN1bGF0ZVByb3ZpZGVkQnlUaHVuayhhY3Rpb24sIFwicHJvdmlkZXNUYWdzXCIsIGRlZmluaXRpb25zLCBhc3NlcnRUYWdUeXBlKTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXlcbiAgICAgICAgfSA9IGFjdGlvbi5tZXRhLmFyZztcbiAgICAgICAgaW52YWxpZGF0aW9uU2xpY2UuY2FzZVJlZHVjZXJzLnVwZGF0ZVByb3ZpZGVkQnkoZHJhZnQsIGludmFsaWRhdGlvblNsaWNlLmFjdGlvbnMudXBkYXRlUHJvdmlkZWRCeSh7XG4gICAgICAgICAgcXVlcnlDYWNoZUtleSxcbiAgICAgICAgICBwcm92aWRlZFRhZ3NcbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgY29uc3Qgc3Vic2NyaXB0aW9uU2xpY2UgPSBjcmVhdGVTbGljZSh7XG4gICAgbmFtZTogYCR7cmVkdWNlclBhdGh9L3N1YnNjcmlwdGlvbnNgLFxuICAgIGluaXRpYWxTdGF0ZSxcbiAgICByZWR1Y2Vyczoge1xuICAgICAgdXBkYXRlU3Vic2NyaXB0aW9uT3B0aW9ucyhkLCBhKSB7XG4gICAgICB9LFxuICAgICAgdW5zdWJzY3JpYmVRdWVyeVJlc3VsdChkLCBhKSB7XG4gICAgICB9LFxuICAgICAgaW50ZXJuYWxfZ2V0UlRLUVN1YnNjcmlwdGlvbnMoKSB7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgY29uc3QgaW50ZXJuYWxTdWJzY3JpcHRpb25zU2xpY2UgPSBjcmVhdGVTbGljZSh7XG4gICAgbmFtZTogYCR7cmVkdWNlclBhdGh9L2ludGVybmFsU3Vic2NyaXB0aW9uc2AsXG4gICAgaW5pdGlhbFN0YXRlLFxuICAgIHJlZHVjZXJzOiB7XG4gICAgICBzdWJzY3JpcHRpb25zVXBkYXRlZDoge1xuICAgICAgICByZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gYXBwbHlQYXRjaGVzKHN0YXRlLCBhY3Rpb24ucGF5bG9hZCk7XG4gICAgICAgIH0sXG4gICAgICAgIHByZXBhcmU6IHByZXBhcmVBdXRvQmF0Y2hlZCgpXG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgY29uc3QgY29uZmlnU2xpY2UgPSBjcmVhdGVTbGljZSh7XG4gICAgbmFtZTogYCR7cmVkdWNlclBhdGh9L2NvbmZpZ2AsXG4gICAgaW5pdGlhbFN0YXRlOiB7XG4gICAgICBvbmxpbmU6IGlzT25saW5lKCksXG4gICAgICBmb2N1c2VkOiBpc0RvY3VtZW50VmlzaWJsZSgpLFxuICAgICAgbWlkZGxld2FyZVJlZ2lzdGVyZWQ6IGZhbHNlLFxuICAgICAgLi4uY29uZmlnXG4gICAgfSxcbiAgICByZWR1Y2Vyczoge1xuICAgICAgbWlkZGxld2FyZVJlZ2lzdGVyZWQoc3RhdGUsIHtcbiAgICAgICAgcGF5bG9hZFxuICAgICAgfSkge1xuICAgICAgICBzdGF0ZS5taWRkbGV3YXJlUmVnaXN0ZXJlZCA9IHN0YXRlLm1pZGRsZXdhcmVSZWdpc3RlcmVkID09PSBcImNvbmZsaWN0XCIgfHwgYXBpVWlkICE9PSBwYXlsb2FkID8gXCJjb25mbGljdFwiIDogdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4dHJhUmVkdWNlcnM6IChidWlsZGVyKSA9PiB7XG4gICAgICBidWlsZGVyLmFkZENhc2Uob25PbmxpbmUsIChzdGF0ZSkgPT4ge1xuICAgICAgICBzdGF0ZS5vbmxpbmUgPSB0cnVlO1xuICAgICAgfSkuYWRkQ2FzZShvbk9mZmxpbmUsIChzdGF0ZSkgPT4ge1xuICAgICAgICBzdGF0ZS5vbmxpbmUgPSBmYWxzZTtcbiAgICAgIH0pLmFkZENhc2Uob25Gb2N1cywgKHN0YXRlKSA9PiB7XG4gICAgICAgIHN0YXRlLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgfSkuYWRkQ2FzZShvbkZvY3VzTG9zdCwgKHN0YXRlKSA9PiB7XG4gICAgICAgIHN0YXRlLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgIH0pLmFkZE1hdGNoZXIoaGFzUmVoeWRyYXRpb25JbmZvLCAoZHJhZnQpID0+ICh7XG4gICAgICAgIC4uLmRyYWZ0XG4gICAgICB9KSk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgY29tYmluZWRSZWR1Y2VyID0gY29tYmluZVJlZHVjZXJzKHtcbiAgICBxdWVyaWVzOiBxdWVyeVNsaWNlLnJlZHVjZXIsXG4gICAgbXV0YXRpb25zOiBtdXRhdGlvblNsaWNlLnJlZHVjZXIsXG4gICAgcHJvdmlkZWQ6IGludmFsaWRhdGlvblNsaWNlLnJlZHVjZXIsXG4gICAgc3Vic2NyaXB0aW9uczogaW50ZXJuYWxTdWJzY3JpcHRpb25zU2xpY2UucmVkdWNlcixcbiAgICBjb25maWc6IGNvbmZpZ1NsaWNlLnJlZHVjZXJcbiAgfSk7XG4gIGNvbnN0IHJlZHVjZXIgPSAoc3RhdGUsIGFjdGlvbikgPT4gY29tYmluZWRSZWR1Y2VyKHJlc2V0QXBpU3RhdGUubWF0Y2goYWN0aW9uKSA/IHZvaWQgMCA6IHN0YXRlLCBhY3Rpb24pO1xuICBjb25zdCBhY3Rpb25zID0ge1xuICAgIC4uLmNvbmZpZ1NsaWNlLmFjdGlvbnMsXG4gICAgLi4ucXVlcnlTbGljZS5hY3Rpb25zLFxuICAgIC4uLnN1YnNjcmlwdGlvblNsaWNlLmFjdGlvbnMsXG4gICAgLi4uaW50ZXJuYWxTdWJzY3JpcHRpb25zU2xpY2UuYWN0aW9ucyxcbiAgICAuLi5tdXRhdGlvblNsaWNlLmFjdGlvbnMsXG4gICAgLi4uaW52YWxpZGF0aW9uU2xpY2UuYWN0aW9ucyxcbiAgICByZXNldEFwaVN0YXRlXG4gIH07XG4gIHJldHVybiB7XG4gICAgcmVkdWNlcixcbiAgICBhY3Rpb25zXG4gIH07XG59XG5cbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkU2VsZWN0b3JzLnRzXG52YXIgc2tpcFRva2VuID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJSVEtRL3NraXBUb2tlblwiKTtcbnZhciBpbml0aWFsU3ViU3RhdGUgPSB7XG4gIHN0YXR1czogXCJ1bmluaXRpYWxpemVkXCIgLyogdW5pbml0aWFsaXplZCAqL1xufTtcbnZhciBkZWZhdWx0UXVlcnlTdWJTdGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVOZXh0U3RhdGUoaW5pdGlhbFN1YlN0YXRlLCAoKSA9PiB7XG59KTtcbnZhciBkZWZhdWx0TXV0YXRpb25TdWJTdGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVOZXh0U3RhdGUoaW5pdGlhbFN1YlN0YXRlLCAoKSA9PiB7XG59KTtcbmZ1bmN0aW9uIGJ1aWxkU2VsZWN0b3JzKHtcbiAgc2VyaWFsaXplUXVlcnlBcmdzLFxuICByZWR1Y2VyUGF0aCxcbiAgY3JlYXRlU2VsZWN0b3I6IGNyZWF0ZVNlbGVjdG9yMlxufSkge1xuICBjb25zdCBzZWxlY3RTa2lwcGVkUXVlcnkgPSAoc3RhdGUpID0+IGRlZmF1bHRRdWVyeVN1YlN0YXRlO1xuICBjb25zdCBzZWxlY3RTa2lwcGVkTXV0YXRpb24gPSAoc3RhdGUpID0+IGRlZmF1bHRNdXRhdGlvblN1YlN0YXRlO1xuICByZXR1cm4ge1xuICAgIGJ1aWxkUXVlcnlTZWxlY3RvcixcbiAgICBidWlsZE11dGF0aW9uU2VsZWN0b3IsXG4gICAgc2VsZWN0SW52YWxpZGF0ZWRCeSxcbiAgICBzZWxlY3RDYWNoZWRBcmdzRm9yUXVlcnlcbiAgfTtcbiAgZnVuY3Rpb24gd2l0aFJlcXVlc3RGbGFncyhzdWJzdGF0ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdWJzdGF0ZSxcbiAgICAgIC4uLmdldFJlcXVlc3RTdGF0dXNGbGFncyhzdWJzdGF0ZS5zdGF0dXMpXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBzZWxlY3RJbnRlcm5hbFN0YXRlKHJvb3RTdGF0ZSkge1xuICAgIGNvbnN0IHN0YXRlID0gcm9vdFN0YXRlW3JlZHVjZXJQYXRoXTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgIGlmIChzZWxlY3RJbnRlcm5hbFN0YXRlLnRyaWdnZXJlZClcbiAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIHNlbGVjdEludGVybmFsU3RhdGUudHJpZ2dlcmVkID0gdHJ1ZTtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3I6IE5vIGRhdGEgZm91bmQgYXQgXFxgc3RhdGUuJHtyZWR1Y2VyUGF0aH1cXGAuIERpZCB5b3UgZm9yZ2V0IHRvIGFkZCB0aGUgcmVkdWNlciB0byB0aGUgc3RvcmU/YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBmdW5jdGlvbiBidWlsZFF1ZXJ5U2VsZWN0b3IoZW5kcG9pbnROYW1lLCBlbmRwb2ludERlZmluaXRpb24pIHtcbiAgICByZXR1cm4gKHF1ZXJ5QXJncykgPT4ge1xuICAgICAgY29uc3Qgc2VyaWFsaXplZEFyZ3MgPSBzZXJpYWxpemVRdWVyeUFyZ3Moe1xuICAgICAgICBxdWVyeUFyZ3MsXG4gICAgICAgIGVuZHBvaW50RGVmaW5pdGlvbixcbiAgICAgICAgZW5kcG9pbnROYW1lXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHNlbGVjdFF1ZXJ5U3Vic3RhdGUgPSAoc3RhdGUpID0+IHNlbGVjdEludGVybmFsU3RhdGUoc3RhdGUpPy5xdWVyaWVzPy5bc2VyaWFsaXplZEFyZ3NdID8/IGRlZmF1bHRRdWVyeVN1YlN0YXRlO1xuICAgICAgY29uc3QgZmluYWxTZWxlY3RRdWVyeVN1YlN0YXRlID0gcXVlcnlBcmdzID09PSBza2lwVG9rZW4gPyBzZWxlY3RTa2lwcGVkUXVlcnkgOiBzZWxlY3RRdWVyeVN1YnN0YXRlO1xuICAgICAgcmV0dXJuIGNyZWF0ZVNlbGVjdG9yMihmaW5hbFNlbGVjdFF1ZXJ5U3ViU3RhdGUsIHdpdGhSZXF1ZXN0RmxhZ3MpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRNdXRhdGlvblNlbGVjdG9yKCkge1xuICAgIHJldHVybiAoaWQpID0+IHtcbiAgICAgIGxldCBtdXRhdGlvbklkO1xuICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBtdXRhdGlvbklkID0gZ2V0TXV0YXRpb25DYWNoZUtleShpZCkgPz8gc2tpcFRva2VuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXV0YXRpb25JZCA9IGlkO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2VsZWN0TXV0YXRpb25TdWJzdGF0ZSA9IChzdGF0ZSkgPT4gc2VsZWN0SW50ZXJuYWxTdGF0ZShzdGF0ZSk/Lm11dGF0aW9ucz8uW211dGF0aW9uSWRdID8/IGRlZmF1bHRNdXRhdGlvblN1YlN0YXRlO1xuICAgICAgY29uc3QgZmluYWxTZWxlY3RNdXRhdGlvblN1YnN0YXRlID0gbXV0YXRpb25JZCA9PT0gc2tpcFRva2VuID8gc2VsZWN0U2tpcHBlZE11dGF0aW9uIDogc2VsZWN0TXV0YXRpb25TdWJzdGF0ZTtcbiAgICAgIHJldHVybiBjcmVhdGVTZWxlY3RvcjIoZmluYWxTZWxlY3RNdXRhdGlvblN1YnN0YXRlLCB3aXRoUmVxdWVzdEZsYWdzKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHNlbGVjdEludmFsaWRhdGVkQnkoc3RhdGUsIHRhZ3MpIHtcbiAgICBjb25zdCBhcGlTdGF0ZSA9IHN0YXRlW3JlZHVjZXJQYXRoXTtcbiAgICBjb25zdCB0b0ludmFsaWRhdGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIHRhZ3MubWFwKGV4cGFuZFRhZ0Rlc2NyaXB0aW9uKSkge1xuICAgICAgY29uc3QgcHJvdmlkZWQgPSBhcGlTdGF0ZS5wcm92aWRlZFt0YWcudHlwZV07XG4gICAgICBpZiAoIXByb3ZpZGVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IGludmFsaWRhdGVTdWJzY3JpcHRpb25zID0gKHRhZy5pZCAhPT0gdm9pZCAwID8gKFxuICAgICAgICAvLyBpZCBnaXZlbjogaW52YWxpZGF0ZSBhbGwgcXVlcmllcyB0aGF0IHByb3ZpZGUgdGhpcyB0eXBlICYgaWRcbiAgICAgICAgcHJvdmlkZWRbdGFnLmlkXVxuICAgICAgKSA6IChcbiAgICAgICAgLy8gbm8gaWQ6IGludmFsaWRhdGUgYWxsIHF1ZXJpZXMgdGhhdCBwcm92aWRlIHRoaXMgdHlwZVxuICAgICAgICBmbGF0dGVuKE9iamVjdC52YWx1ZXMocHJvdmlkZWQpKVxuICAgICAgKSkgPz8gW107XG4gICAgICBmb3IgKGNvbnN0IGludmFsaWRhdGUgb2YgaW52YWxpZGF0ZVN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgdG9JbnZhbGlkYXRlLmFkZChpbnZhbGlkYXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZsYXR0ZW4oQXJyYXkuZnJvbSh0b0ludmFsaWRhdGUudmFsdWVzKCkpLm1hcCgocXVlcnlDYWNoZUtleSkgPT4ge1xuICAgICAgY29uc3QgcXVlcnlTdWJTdGF0ZSA9IGFwaVN0YXRlLnF1ZXJpZXNbcXVlcnlDYWNoZUtleV07XG4gICAgICByZXR1cm4gcXVlcnlTdWJTdGF0ZSA/IFt7XG4gICAgICAgIHF1ZXJ5Q2FjaGVLZXksXG4gICAgICAgIGVuZHBvaW50TmFtZTogcXVlcnlTdWJTdGF0ZS5lbmRwb2ludE5hbWUsXG4gICAgICAgIG9yaWdpbmFsQXJnczogcXVlcnlTdWJTdGF0ZS5vcmlnaW5hbEFyZ3NcbiAgICAgIH1dIDogW107XG4gICAgfSkpO1xuICB9XG4gIGZ1bmN0aW9uIHNlbGVjdENhY2hlZEFyZ3NGb3JRdWVyeShzdGF0ZSwgcXVlcnlOYW1lKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoc3RhdGVbcmVkdWNlclBhdGhdLnF1ZXJpZXMpLmZpbHRlcigoZW50cnkpID0+IGVudHJ5Py5lbmRwb2ludE5hbWUgPT09IHF1ZXJ5TmFtZSAmJiBlbnRyeS5zdGF0dXMgIT09IFwidW5pbml0aWFsaXplZFwiIC8qIHVuaW5pdGlhbGl6ZWQgKi8pLm1hcCgoZW50cnkpID0+IGVudHJ5Lm9yaWdpbmFsQXJncyk7XG4gIH1cbn1cblxuLy8gc3JjL3F1ZXJ5L2RlZmF1bHRTZXJpYWxpemVRdWVyeUFyZ3MudHNcbnZhciBjYWNoZSA9IFdlYWtNYXAgPyAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSA6IHZvaWQgMDtcbnZhciBkZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzID0gKHtcbiAgZW5kcG9pbnROYW1lLFxuICBxdWVyeUFyZ3Ncbn0pID0+IHtcbiAgbGV0IHNlcmlhbGl6ZWQgPSBcIlwiO1xuICBjb25zdCBjYWNoZWQgPSBjYWNoZT8uZ2V0KHF1ZXJ5QXJncyk7XG4gIGlmICh0eXBlb2YgY2FjaGVkID09PSBcInN0cmluZ1wiKSB7XG4gICAgc2VyaWFsaXplZCA9IGNhY2hlZDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzdHJpbmdpZmllZCA9IEpTT04uc3RyaW5naWZ5KHF1ZXJ5QXJncywgKGtleSwgdmFsdWUpID0+IGlzUGxhaW5PYmplY3QodmFsdWUpID8gT2JqZWN0LmtleXModmFsdWUpLnNvcnQoKS5yZWR1Y2UoKGFjYywga2V5MikgPT4ge1xuICAgICAgYWNjW2tleTJdID0gdmFsdWVba2V5Ml07XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KSA6IHZhbHVlKTtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChxdWVyeUFyZ3MpKSB7XG4gICAgICBjYWNoZT8uc2V0KHF1ZXJ5QXJncywgc3RyaW5naWZpZWQpO1xuICAgIH1cbiAgICBzZXJpYWxpemVkID0gc3RyaW5naWZpZWQ7XG4gIH1cbiAgcmV0dXJuIGAke2VuZHBvaW50TmFtZX0oJHtzZXJpYWxpemVkfSlgO1xufTtcblxuLy8gc3JjL3F1ZXJ5L2NyZWF0ZUFwaS50c1xuaW1wb3J0IHsgd2Vha01hcE1lbW9pemUgfSBmcm9tIFwicmVzZWxlY3RcIjtcbmZ1bmN0aW9uIGJ1aWxkQ3JlYXRlQXBpKC4uLm1vZHVsZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJhc2VDcmVhdGVBcGkob3B0aW9ucykge1xuICAgIGNvbnN0IGV4dHJhY3RSZWh5ZHJhdGlvbkluZm8gPSB3ZWFrTWFwTWVtb2l6ZSgoYWN0aW9uKSA9PiBvcHRpb25zLmV4dHJhY3RSZWh5ZHJhdGlvbkluZm8/LihhY3Rpb24sIHtcbiAgICAgIHJlZHVjZXJQYXRoOiBvcHRpb25zLnJlZHVjZXJQYXRoID8/IFwiYXBpXCJcbiAgICB9KSk7XG4gICAgY29uc3Qgb3B0aW9uc1dpdGhEZWZhdWx0cyA9IHtcbiAgICAgIHJlZHVjZXJQYXRoOiBcImFwaVwiLFxuICAgICAga2VlcFVudXNlZERhdGFGb3I6IDYwLFxuICAgICAgcmVmZXRjaE9uTW91bnRPckFyZ0NoYW5nZTogZmFsc2UsXG4gICAgICByZWZldGNoT25Gb2N1czogZmFsc2UsXG4gICAgICByZWZldGNoT25SZWNvbm5lY3Q6IGZhbHNlLFxuICAgICAgaW52YWxpZGF0aW9uQmVoYXZpb3I6IFwiZGVsYXllZFwiLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGV4dHJhY3RSZWh5ZHJhdGlvbkluZm8sXG4gICAgICBzZXJpYWxpemVRdWVyeUFyZ3MocXVlcnlBcmdzQXBpKSB7XG4gICAgICAgIGxldCBmaW5hbFNlcmlhbGl6ZVF1ZXJ5QXJncyA9IGRlZmF1bHRTZXJpYWxpemVRdWVyeUFyZ3M7XG4gICAgICAgIGlmIChcInNlcmlhbGl6ZVF1ZXJ5QXJnc1wiIGluIHF1ZXJ5QXJnc0FwaS5lbmRwb2ludERlZmluaXRpb24pIHtcbiAgICAgICAgICBjb25zdCBlbmRwb2ludFNRQSA9IHF1ZXJ5QXJnc0FwaS5lbmRwb2ludERlZmluaXRpb24uc2VyaWFsaXplUXVlcnlBcmdzO1xuICAgICAgICAgIGZpbmFsU2VyaWFsaXplUXVlcnlBcmdzID0gKHF1ZXJ5QXJnc0FwaTIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxSZXN1bHQgPSBlbmRwb2ludFNRQShxdWVyeUFyZ3NBcGkyKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5pdGlhbFJlc3VsdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICByZXR1cm4gaW5pdGlhbFJlc3VsdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzKHtcbiAgICAgICAgICAgICAgICAuLi5xdWVyeUFyZ3NBcGkyLFxuICAgICAgICAgICAgICAgIHF1ZXJ5QXJnczogaW5pdGlhbFJlc3VsdFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc2VyaWFsaXplUXVlcnlBcmdzKSB7XG4gICAgICAgICAgZmluYWxTZXJpYWxpemVRdWVyeUFyZ3MgPSBvcHRpb25zLnNlcmlhbGl6ZVF1ZXJ5QXJncztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmluYWxTZXJpYWxpemVRdWVyeUFyZ3MocXVlcnlBcmdzQXBpKTtcbiAgICAgIH0sXG4gICAgICB0YWdUeXBlczogWy4uLm9wdGlvbnMudGFnVHlwZXMgfHwgW11dXG4gICAgfTtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgZW5kcG9pbnREZWZpbml0aW9uczoge30sXG4gICAgICBiYXRjaChmbikge1xuICAgICAgICBmbigpO1xuICAgICAgfSxcbiAgICAgIGFwaVVpZDogbmFub2lkKCksXG4gICAgICBleHRyYWN0UmVoeWRyYXRpb25JbmZvLFxuICAgICAgaGFzUmVoeWRyYXRpb25JbmZvOiB3ZWFrTWFwTWVtb2l6ZSgoYWN0aW9uKSA9PiBleHRyYWN0UmVoeWRyYXRpb25JbmZvKGFjdGlvbikgIT0gbnVsbClcbiAgICB9O1xuICAgIGNvbnN0IGFwaSA9IHtcbiAgICAgIGluamVjdEVuZHBvaW50cyxcbiAgICAgIGVuaGFuY2VFbmRwb2ludHMoe1xuICAgICAgICBhZGRUYWdUeXBlcyxcbiAgICAgICAgZW5kcG9pbnRzXG4gICAgICB9KSB7XG4gICAgICAgIGlmIChhZGRUYWdUeXBlcykge1xuICAgICAgICAgIGZvciAoY29uc3QgZVQgb2YgYWRkVGFnVHlwZXMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9uc1dpdGhEZWZhdWx0cy50YWdUeXBlcy5pbmNsdWRlcyhlVCkpIHtcbiAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICBvcHRpb25zV2l0aERlZmF1bHRzLnRhZ1R5cGVzLnB1c2goZVQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kcG9pbnRzKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBbZW5kcG9pbnROYW1lLCBwYXJ0aWFsRGVmaW5pdGlvbl0gb2YgT2JqZWN0LmVudHJpZXMoZW5kcG9pbnRzKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0aWFsRGVmaW5pdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIHBhcnRpYWxEZWZpbml0aW9uKGNvbnRleHQuZW5kcG9pbnREZWZpbml0aW9uc1tlbmRwb2ludE5hbWVdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY29udGV4dC5lbmRwb2ludERlZmluaXRpb25zW2VuZHBvaW50TmFtZV0gfHwge30sIHBhcnRpYWxEZWZpbml0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwaTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGluaXRpYWxpemVkTW9kdWxlcyA9IG1vZHVsZXMubWFwKChtKSA9PiBtLmluaXQoYXBpLCBvcHRpb25zV2l0aERlZmF1bHRzLCBjb250ZXh0KSk7XG4gICAgZnVuY3Rpb24gaW5qZWN0RW5kcG9pbnRzKGluamVjdCkge1xuICAgICAgY29uc3QgZXZhbHVhdGVkRW5kcG9pbnRzID0gaW5qZWN0LmVuZHBvaW50cyh7XG4gICAgICAgIHF1ZXJ5OiAoeCkgPT4gKHtcbiAgICAgICAgICAuLi54LFxuICAgICAgICAgIHR5cGU6IFwicXVlcnlcIiAvKiBxdWVyeSAqL1xuICAgICAgICB9KSxcbiAgICAgICAgbXV0YXRpb246ICh4KSA9PiAoe1xuICAgICAgICAgIC4uLngsXG4gICAgICAgICAgdHlwZTogXCJtdXRhdGlvblwiIC8qIG11dGF0aW9uICovXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIGZvciAoY29uc3QgW2VuZHBvaW50TmFtZSwgZGVmaW5pdGlvbl0gb2YgT2JqZWN0LmVudHJpZXMoZXZhbHVhdGVkRW5kcG9pbnRzKSkge1xuICAgICAgICBpZiAoIWluamVjdC5vdmVycmlkZUV4aXN0aW5nICYmIGVuZHBvaW50TmFtZSBpbiBjb250ZXh0LmVuZHBvaW50RGVmaW5pdGlvbnMpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgY2FsbGVkIFxcYGluamVjdEVuZHBvaW50c1xcYCB0byBvdmVycmlkZSBhbHJlYWR5LWV4aXN0aW5nIGVuZHBvaW50TmFtZSAke2VuZHBvaW50TmFtZX0gd2l0aG91dCBzcGVjaWZ5aW5nIFxcYG92ZXJyaWRlRXhpc3Rpbmc6IHRydWVcXGBgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5lbmRwb2ludERlZmluaXRpb25zW2VuZHBvaW50TmFtZV0gPSBkZWZpbml0aW9uO1xuICAgICAgICBmb3IgKGNvbnN0IG0gb2YgaW5pdGlhbGl6ZWRNb2R1bGVzKSB7XG4gICAgICAgICAgbS5pbmplY3RFbmRwb2ludChlbmRwb2ludE5hbWUsIGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXBpO1xuICAgIH1cbiAgICByZXR1cm4gYXBpLmluamVjdEVuZHBvaW50cyh7XG4gICAgICBlbmRwb2ludHM6IG9wdGlvbnMuZW5kcG9pbnRzXG4gICAgfSk7XG4gIH07XG59XG5cbi8vIHNyYy9xdWVyeS9mYWtlQmFzZVF1ZXJ5LnRzXG5pbXBvcnQgeyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIGFzIF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMiB9IGZyb20gXCJAcmVkdXhqcy90b29sa2l0XCI7XG5mdW5jdGlvbiBmYWtlQmFzZVF1ZXJ5KCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMigzMykgOiBcIldoZW4gdXNpbmcgYGZha2VCYXNlUXVlcnlgLCBhbGwgcXVlcmllcyAmIG11dGF0aW9ucyBtdXN0IHVzZSB0aGUgYHF1ZXJ5Rm5gIGRlZmluaXRpb24gc3ludGF4LlwiKTtcbiAgfTtcbn1cblxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRNaWRkbGV3YXJlL2NhY2hlQ29sbGVjdGlvbi50c1xuZnVuY3Rpb24gaXNPYmplY3RFbXB0eShvYmopIHtcbiAgZm9yIChsZXQgayBpbiBvYmopIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG52YXIgVEhJUlRZX1RXT19CSVRfTUFYX1RJTUVSX1NFQ09ORFMgPSAyMTQ3NDgzNjQ3IC8gMWUzIC0gMTtcbnZhciBidWlsZENhY2hlQ29sbGVjdGlvbkhhbmRsZXIgPSAoe1xuICByZWR1Y2VyUGF0aCxcbiAgYXBpLFxuICBjb250ZXh0LFxuICBpbnRlcm5hbFN0YXRlXG59KSA9PiB7XG4gIGNvbnN0IHtcbiAgICByZW1vdmVRdWVyeVJlc3VsdCxcbiAgICB1bnN1YnNjcmliZVF1ZXJ5UmVzdWx0XG4gIH0gPSBhcGkuaW50ZXJuYWxBY3Rpb25zO1xuICBmdW5jdGlvbiBhbnlTdWJzY3JpcHRpb25zUmVtYWluaW5nRm9yS2V5KHF1ZXJ5Q2FjaGVLZXkpIHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gaW50ZXJuYWxTdGF0ZS5jdXJyZW50U3Vic2NyaXB0aW9uc1txdWVyeUNhY2hlS2V5XTtcbiAgICByZXR1cm4gISFzdWJzY3JpcHRpb25zICYmICFpc09iamVjdEVtcHR5KHN1YnNjcmlwdGlvbnMpO1xuICB9XG4gIGNvbnN0IGN1cnJlbnRSZW1vdmFsVGltZW91dHMgPSB7fTtcbiAgY29uc3QgaGFuZGxlciA9IChhY3Rpb24sIG13QXBpLCBpbnRlcm5hbFN0YXRlMikgPT4ge1xuICAgIGlmICh1bnN1YnNjcmliZVF1ZXJ5UmVzdWx0Lm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gbXdBcGkuZ2V0U3RhdGUoKVtyZWR1Y2VyUGF0aF07XG4gICAgICBjb25zdCB7XG4gICAgICAgIHF1ZXJ5Q2FjaGVLZXlcbiAgICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgIGhhbmRsZVVuc3Vic2NyaWJlKHF1ZXJ5Q2FjaGVLZXksIHN0YXRlLnF1ZXJpZXNbcXVlcnlDYWNoZUtleV0/LmVuZHBvaW50TmFtZSwgbXdBcGksIHN0YXRlLmNvbmZpZyk7XG4gICAgfVxuICAgIGlmIChhcGkudXRpbC5yZXNldEFwaVN0YXRlLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdGltZW91dF0gb2YgT2JqZWN0LmVudHJpZXMoY3VycmVudFJlbW92YWxUaW1lb3V0cykpIHtcbiAgICAgICAgaWYgKHRpbWVvdXQpXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICBkZWxldGUgY3VycmVudFJlbW92YWxUaW1lb3V0c1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udGV4dC5oYXNSZWh5ZHJhdGlvbkluZm8oYWN0aW9uKSkge1xuICAgICAgY29uc3Qgc3RhdGUgPSBtd0FwaS5nZXRTdGF0ZSgpW3JlZHVjZXJQYXRoXTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcXVlcmllc1xuICAgICAgfSA9IGNvbnRleHQuZXh0cmFjdFJlaHlkcmF0aW9uSW5mbyhhY3Rpb24pO1xuICAgICAgZm9yIChjb25zdCBbcXVlcnlDYWNoZUtleSwgcXVlcnlTdGF0ZV0gb2YgT2JqZWN0LmVudHJpZXMocXVlcmllcykpIHtcbiAgICAgICAgaGFuZGxlVW5zdWJzY3JpYmUocXVlcnlDYWNoZUtleSwgcXVlcnlTdGF0ZT8uZW5kcG9pbnROYW1lLCBtd0FwaSwgc3RhdGUuY29uZmlnKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGhhbmRsZVVuc3Vic2NyaWJlKHF1ZXJ5Q2FjaGVLZXksIGVuZHBvaW50TmFtZSwgYXBpMiwgY29uZmlnKSB7XG4gICAgY29uc3QgZW5kcG9pbnREZWZpbml0aW9uID0gY29udGV4dC5lbmRwb2ludERlZmluaXRpb25zW2VuZHBvaW50TmFtZV07XG4gICAgY29uc3Qga2VlcFVudXNlZERhdGFGb3IgPSBlbmRwb2ludERlZmluaXRpb24/LmtlZXBVbnVzZWREYXRhRm9yID8/IGNvbmZpZy5rZWVwVW51c2VkRGF0YUZvcjtcbiAgICBpZiAoa2VlcFVudXNlZERhdGFGb3IgPT09IEluZmluaXR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZpbmFsS2VlcFVudXNlZERhdGFGb3IgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihrZWVwVW51c2VkRGF0YUZvciwgVEhJUlRZX1RXT19CSVRfTUFYX1RJTUVSX1NFQ09ORFMpKTtcbiAgICBpZiAoIWFueVN1YnNjcmlwdGlvbnNSZW1haW5pbmdGb3JLZXkocXVlcnlDYWNoZUtleSkpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRUaW1lb3V0ID0gY3VycmVudFJlbW92YWxUaW1lb3V0c1txdWVyeUNhY2hlS2V5XTtcbiAgICAgIGlmIChjdXJyZW50VGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoY3VycmVudFRpbWVvdXQpO1xuICAgICAgfVxuICAgICAgY3VycmVudFJlbW92YWxUaW1lb3V0c1txdWVyeUNhY2hlS2V5XSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoIWFueVN1YnNjcmlwdGlvbnNSZW1haW5pbmdGb3JLZXkocXVlcnlDYWNoZUtleSkpIHtcbiAgICAgICAgICBhcGkyLmRpc3BhdGNoKHJlbW92ZVF1ZXJ5UmVzdWx0KHtcbiAgICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXlcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIGN1cnJlbnRSZW1vdmFsVGltZW91dHNbcXVlcnlDYWNoZUtleV07XG4gICAgICB9LCBmaW5hbEtlZXBVbnVzZWREYXRhRm9yICogMWUzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhbmRsZXI7XG59O1xuXG4vLyBzcmMvcXVlcnkvY29yZS9idWlsZE1pZGRsZXdhcmUvaW52YWxpZGF0aW9uQnlUYWdzLnRzXG52YXIgYnVpbGRJbnZhbGlkYXRpb25CeVRhZ3NIYW5kbGVyID0gKHtcbiAgcmVkdWNlclBhdGgsXG4gIGNvbnRleHQsXG4gIGNvbnRleHQ6IHtcbiAgICBlbmRwb2ludERlZmluaXRpb25zXG4gIH0sXG4gIG11dGF0aW9uVGh1bmssXG4gIHF1ZXJ5VGh1bmssXG4gIGFwaSxcbiAgYXNzZXJ0VGFnVHlwZSxcbiAgcmVmZXRjaFF1ZXJ5LFxuICBpbnRlcm5hbFN0YXRlXG59KSA9PiB7XG4gIGNvbnN0IHtcbiAgICByZW1vdmVRdWVyeVJlc3VsdFxuICB9ID0gYXBpLmludGVybmFsQWN0aW9ucztcbiAgY29uc3QgaXNUaHVua0FjdGlvbldpdGhUYWdzID0gaXNBbnlPZihpc0Z1bGZpbGxlZChtdXRhdGlvblRodW5rKSwgaXNSZWplY3RlZFdpdGhWYWx1ZShtdXRhdGlvblRodW5rKSk7XG4gIGNvbnN0IGlzUXVlcnlFbmQgPSBpc0FueU9mKGlzRnVsZmlsbGVkKG11dGF0aW9uVGh1bmssIHF1ZXJ5VGh1bmspLCBpc1JlamVjdGVkKG11dGF0aW9uVGh1bmssIHF1ZXJ5VGh1bmspKTtcbiAgbGV0IHBlbmRpbmdUYWdJbnZhbGlkYXRpb25zID0gW107XG4gIGNvbnN0IGhhbmRsZXIgPSAoYWN0aW9uLCBtd0FwaSkgPT4ge1xuICAgIGlmIChpc1RodW5rQWN0aW9uV2l0aFRhZ3MoYWN0aW9uKSkge1xuICAgICAgaW52YWxpZGF0ZVRhZ3MoY2FsY3VsYXRlUHJvdmlkZWRCeVRodW5rKGFjdGlvbiwgXCJpbnZhbGlkYXRlc1RhZ3NcIiwgZW5kcG9pbnREZWZpbml0aW9ucywgYXNzZXJ0VGFnVHlwZSksIG13QXBpKTtcbiAgICB9IGVsc2UgaWYgKGlzUXVlcnlFbmQoYWN0aW9uKSkge1xuICAgICAgaW52YWxpZGF0ZVRhZ3MoW10sIG13QXBpKTtcbiAgICB9IGVsc2UgaWYgKGFwaS51dGlsLmludmFsaWRhdGVUYWdzLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGludmFsaWRhdGVUYWdzKGNhbGN1bGF0ZVByb3ZpZGVkQnkoYWN0aW9uLnBheWxvYWQsIHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgYXNzZXJ0VGFnVHlwZSksIG13QXBpKTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGhhc1BlbmRpbmdSZXF1ZXN0cyhzdGF0ZSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHN0YXRlLnF1ZXJpZXMpIHtcbiAgICAgIGlmIChzdGF0ZS5xdWVyaWVzW2tleV0/LnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIgLyogcGVuZGluZyAqLylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHN0YXRlLm11dGF0aW9ucykge1xuICAgICAgaWYgKHN0YXRlLm11dGF0aW9uc1trZXldPy5zdGF0dXMgPT09IFwicGVuZGluZ1wiIC8qIHBlbmRpbmcgKi8pXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gaW52YWxpZGF0ZVRhZ3MobmV3VGFncywgbXdBcGkpIHtcbiAgICBjb25zdCByb290U3RhdGUgPSBtd0FwaS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHN0YXRlID0gcm9vdFN0YXRlW3JlZHVjZXJQYXRoXTtcbiAgICBwZW5kaW5nVGFnSW52YWxpZGF0aW9ucy5wdXNoKC4uLm5ld1RhZ3MpO1xuICAgIGlmIChzdGF0ZS5jb25maWcuaW52YWxpZGF0aW9uQmVoYXZpb3IgPT09IFwiZGVsYXllZFwiICYmIGhhc1BlbmRpbmdSZXF1ZXN0cyhzdGF0ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFncyA9IHBlbmRpbmdUYWdJbnZhbGlkYXRpb25zO1xuICAgIHBlbmRpbmdUYWdJbnZhbGlkYXRpb25zID0gW107XG4gICAgaWYgKHRhZ3MubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHRvSW52YWxpZGF0ZSA9IGFwaS51dGlsLnNlbGVjdEludmFsaWRhdGVkQnkocm9vdFN0YXRlLCB0YWdzKTtcbiAgICBjb250ZXh0LmJhdGNoKCgpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlc0FycmF5ID0gQXJyYXkuZnJvbSh0b0ludmFsaWRhdGUudmFsdWVzKCkpO1xuICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgIHF1ZXJ5Q2FjaGVLZXlcbiAgICAgIH0gb2YgdmFsdWVzQXJyYXkpIHtcbiAgICAgICAgY29uc3QgcXVlcnlTdWJTdGF0ZSA9IHN0YXRlLnF1ZXJpZXNbcXVlcnlDYWNoZUtleV07XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvblN1YlN0YXRlID0gaW50ZXJuYWxTdGF0ZS5jdXJyZW50U3Vic2NyaXB0aW9uc1txdWVyeUNhY2hlS2V5XSA/PyB7fTtcbiAgICAgICAgaWYgKHF1ZXJ5U3ViU3RhdGUpIHtcbiAgICAgICAgICBpZiAoY291bnRPYmplY3RLZXlzKHN1YnNjcmlwdGlvblN1YlN0YXRlKSA9PT0gMCkge1xuICAgICAgICAgICAgbXdBcGkuZGlzcGF0Y2gocmVtb3ZlUXVlcnlSZXN1bHQoe1xuICAgICAgICAgICAgICBxdWVyeUNhY2hlS2V5XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChxdWVyeVN1YlN0YXRlLnN0YXR1cyAhPT0gXCJ1bmluaXRpYWxpemVkXCIgLyogdW5pbml0aWFsaXplZCAqLykge1xuICAgICAgICAgICAgbXdBcGkuZGlzcGF0Y2gocmVmZXRjaFF1ZXJ5KHF1ZXJ5U3ViU3RhdGUsIHF1ZXJ5Q2FjaGVLZXkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaGFuZGxlcjtcbn07XG5cbi8vIHNyYy9xdWVyeS9jb3JlL2J1aWxkTWlkZGxld2FyZS9wb2xsaW5nLnRzXG52YXIgYnVpbGRQb2xsaW5nSGFuZGxlciA9ICh7XG4gIHJlZHVjZXJQYXRoLFxuICBxdWVyeVRodW5rLFxuICBhcGksXG4gIHJlZmV0Y2hRdWVyeSxcbiAgaW50ZXJuYWxTdGF0ZVxufSkgPT4ge1xuICBjb25zdCBjdXJyZW50UG9sbHMgPSB7fTtcbiAgY29uc3QgaGFuZGxlciA9IChhY3Rpb24sIG13QXBpKSA9PiB7XG4gICAgaWYgKGFwaS5pbnRlcm5hbEFjdGlvbnMudXBkYXRlU3Vic2NyaXB0aW9uT3B0aW9ucy5tYXRjaChhY3Rpb24pIHx8IGFwaS5pbnRlcm5hbEFjdGlvbnMudW5zdWJzY3JpYmVRdWVyeVJlc3VsdC5tYXRjaChhY3Rpb24pKSB7XG4gICAgICB1cGRhdGVQb2xsaW5nSW50ZXJ2YWwoYWN0aW9uLnBheWxvYWQsIG13QXBpKTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5VGh1bmsucGVuZGluZy5tYXRjaChhY3Rpb24pIHx8IHF1ZXJ5VGh1bmsucmVqZWN0ZWQubWF0Y2goYWN0aW9uKSAmJiBhY3Rpb24ubWV0YS5jb25kaXRpb24pIHtcbiAgICAgIHVwZGF0ZVBvbGxpbmdJbnRlcnZhbChhY3Rpb24ubWV0YS5hcmcsIG13QXBpKTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5VGh1bmsuZnVsZmlsbGVkLm1hdGNoKGFjdGlvbikgfHwgcXVlcnlUaHVuay5yZWplY3RlZC5tYXRjaChhY3Rpb24pICYmICFhY3Rpb24ubWV0YS5jb25kaXRpb24pIHtcbiAgICAgIHN0YXJ0TmV4dFBvbGwoYWN0aW9uLm1ldGEuYXJnLCBtd0FwaSk7XG4gICAgfVxuICAgIGlmIChhcGkudXRpbC5yZXNldEFwaVN0YXRlLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGNsZWFyUG9sbHMoKTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIHN0YXJ0TmV4dFBvbGwoe1xuICAgIHF1ZXJ5Q2FjaGVLZXlcbiAgfSwgYXBpMikge1xuICAgIGNvbnN0IHN0YXRlID0gYXBpMi5nZXRTdGF0ZSgpW3JlZHVjZXJQYXRoXTtcbiAgICBjb25zdCBxdWVyeVN1YlN0YXRlID0gc3RhdGUucXVlcmllc1txdWVyeUNhY2hlS2V5XTtcbiAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gaW50ZXJuYWxTdGF0ZS5jdXJyZW50U3Vic2NyaXB0aW9uc1txdWVyeUNhY2hlS2V5XTtcbiAgICBpZiAoIXF1ZXJ5U3ViU3RhdGUgfHwgcXVlcnlTdWJTdGF0ZS5zdGF0dXMgPT09IFwidW5pbml0aWFsaXplZFwiIC8qIHVuaW5pdGlhbGl6ZWQgKi8pXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qge1xuICAgICAgbG93ZXN0UG9sbGluZ0ludGVydmFsLFxuICAgICAgc2tpcFBvbGxpbmdJZlVuZm9jdXNlZFxuICAgIH0gPSBmaW5kTG93ZXN0UG9sbGluZ0ludGVydmFsKHN1YnNjcmlwdGlvbnMpO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGxvd2VzdFBvbGxpbmdJbnRlcnZhbCkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgY3VycmVudFBvbGwgPSBjdXJyZW50UG9sbHNbcXVlcnlDYWNoZUtleV07XG4gICAgaWYgKGN1cnJlbnRQb2xsPy50aW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQoY3VycmVudFBvbGwudGltZW91dCk7XG4gICAgICBjdXJyZW50UG9sbC50aW1lb3V0ID0gdm9pZCAwO1xuICAgIH1cbiAgICBjb25zdCBuZXh0UG9sbFRpbWVzdGFtcCA9IERhdGUubm93KCkgKyBsb3dlc3RQb2xsaW5nSW50ZXJ2YWw7XG4gICAgY3VycmVudFBvbGxzW3F1ZXJ5Q2FjaGVLZXldID0ge1xuICAgICAgbmV4dFBvbGxUaW1lc3RhbXAsXG4gICAgICBwb2xsaW5nSW50ZXJ2YWw6IGxvd2VzdFBvbGxpbmdJbnRlcnZhbCxcbiAgICAgIHRpbWVvdXQ6IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoc3RhdGUuY29uZmlnLmZvY3VzZWQgfHwgIXNraXBQb2xsaW5nSWZVbmZvY3VzZWQpIHtcbiAgICAgICAgICBhcGkyLmRpc3BhdGNoKHJlZmV0Y2hRdWVyeShxdWVyeVN1YlN0YXRlLCBxdWVyeUNhY2hlS2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnROZXh0UG9sbCh7XG4gICAgICAgICAgcXVlcnlDYWNoZUtleVxuICAgICAgICB9LCBhcGkyKTtcbiAgICAgIH0sIGxvd2VzdFBvbGxpbmdJbnRlcnZhbClcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVBvbGxpbmdJbnRlcnZhbCh7XG4gICAgcXVlcnlDYWNoZUtleVxuICB9LCBhcGkyKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBhcGkyLmdldFN0YXRlKClbcmVkdWNlclBhdGhdO1xuICAgIGNvbnN0IHF1ZXJ5U3ViU3RhdGUgPSBzdGF0ZS5xdWVyaWVzW3F1ZXJ5Q2FjaGVLZXldO1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSBpbnRlcm5hbFN0YXRlLmN1cnJlbnRTdWJzY3JpcHRpb25zW3F1ZXJ5Q2FjaGVLZXldO1xuICAgIGlmICghcXVlcnlTdWJTdGF0ZSB8fCBxdWVyeVN1YlN0YXRlLnN0YXR1cyA9PT0gXCJ1bmluaXRpYWxpemVkXCIgLyogdW5pbml0aWFsaXplZCAqLykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBsb3dlc3RQb2xsaW5nSW50ZXJ2YWxcbiAgICB9ID0gZmluZExvd2VzdFBvbGxpbmdJbnRlcnZhbChzdWJzY3JpcHRpb25zKTtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShsb3dlc3RQb2xsaW5nSW50ZXJ2YWwpKSB7XG4gICAgICBjbGVhbnVwUG9sbEZvcktleShxdWVyeUNhY2hlS2V5KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFBvbGwgPSBjdXJyZW50UG9sbHNbcXVlcnlDYWNoZUtleV07XG4gICAgY29uc3QgbmV4dFBvbGxUaW1lc3RhbXAgPSBEYXRlLm5vdygpICsgbG93ZXN0UG9sbGluZ0ludGVydmFsO1xuICAgIGlmICghY3VycmVudFBvbGwgfHwgbmV4dFBvbGxUaW1lc3RhbXAgPCBjdXJyZW50UG9sbC5uZXh0UG9sbFRpbWVzdGFtcCkge1xuICAgICAgc3RhcnROZXh0UG9sbCh7XG4gICAgICAgIHF1ZXJ5Q2FjaGVLZXlcbiAgICAgIH0sIGFwaTIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjbGVhbnVwUG9sbEZvcktleShrZXkpIHtcbiAgICBjb25zdCBleGlzdGluZ1BvbGwgPSBjdXJyZW50UG9sbHNba2V5XTtcbiAgICBpZiAoZXhpc3RpbmdQb2xsPy50aW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQoZXhpc3RpbmdQb2xsLnRpbWVvdXQpO1xuICAgIH1cbiAgICBkZWxldGUgY3VycmVudFBvbGxzW2tleV07XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXJQb2xscygpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhjdXJyZW50UG9sbHMpKSB7XG4gICAgICBjbGVhbnVwUG9sbEZvcktleShrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBmaW5kTG93ZXN0UG9sbGluZ0ludGVydmFsKHN1YnNjcmliZXJzID0ge30pIHtcbiAgICBsZXQgc2tpcFBvbGxpbmdJZlVuZm9jdXNlZCA9IGZhbHNlO1xuICAgIGxldCBsb3dlc3RQb2xsaW5nSW50ZXJ2YWwgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgZm9yIChsZXQga2V5IGluIHN1YnNjcmliZXJzKSB7XG4gICAgICBpZiAoISFzdWJzY3JpYmVyc1trZXldLnBvbGxpbmdJbnRlcnZhbCkge1xuICAgICAgICBsb3dlc3RQb2xsaW5nSW50ZXJ2YWwgPSBNYXRoLm1pbihzdWJzY3JpYmVyc1trZXldLnBvbGxpbmdJbnRlcnZhbCwgbG93ZXN0UG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgc2tpcFBvbGxpbmdJZlVuZm9jdXNlZCA9IHN1YnNjcmliZXJzW2tleV0uc2tpcFBvbGxpbmdJZlVuZm9jdXNlZCB8fCBza2lwUG9sbGluZ0lmVW5mb2N1c2VkO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbG93ZXN0UG9sbGluZ0ludGVydmFsLFxuICAgICAgc2tpcFBvbGxpbmdJZlVuZm9jdXNlZFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGhhbmRsZXI7XG59O1xuXG4vLyBzcmMvcXVlcnkvY29yZS9idWlsZE1pZGRsZXdhcmUvd2luZG93RXZlbnRIYW5kbGluZy50c1xudmFyIGJ1aWxkV2luZG93RXZlbnRIYW5kbGVyID0gKHtcbiAgcmVkdWNlclBhdGgsXG4gIGNvbnRleHQsXG4gIGFwaSxcbiAgcmVmZXRjaFF1ZXJ5LFxuICBpbnRlcm5hbFN0YXRlXG59KSA9PiB7XG4gIGNvbnN0IHtcbiAgICByZW1vdmVRdWVyeVJlc3VsdFxuICB9ID0gYXBpLmludGVybmFsQWN0aW9ucztcbiAgY29uc3QgaGFuZGxlciA9IChhY3Rpb24sIG13QXBpKSA9PiB7XG4gICAgaWYgKG9uRm9jdXMubWF0Y2goYWN0aW9uKSkge1xuICAgICAgcmVmZXRjaFZhbGlkUXVlcmllcyhtd0FwaSwgXCJyZWZldGNoT25Gb2N1c1wiKTtcbiAgICB9XG4gICAgaWYgKG9uT25saW5lLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIHJlZmV0Y2hWYWxpZFF1ZXJpZXMobXdBcGksIFwicmVmZXRjaE9uUmVjb25uZWN0XCIpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gcmVmZXRjaFZhbGlkUXVlcmllcyhhcGkyLCB0eXBlKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBhcGkyLmdldFN0YXRlKClbcmVkdWNlclBhdGhdO1xuICAgIGNvbnN0IHF1ZXJpZXMgPSBzdGF0ZS5xdWVyaWVzO1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSBpbnRlcm5hbFN0YXRlLmN1cnJlbnRTdWJzY3JpcHRpb25zO1xuICAgIGNvbnRleHQuYmF0Y2goKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBxdWVyeUNhY2hlS2V5IG9mIE9iamVjdC5rZXlzKHN1YnNjcmlwdGlvbnMpKSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5U3ViU3RhdGUgPSBxdWVyaWVzW3F1ZXJ5Q2FjaGVLZXldO1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25TdWJTdGF0ZSA9IHN1YnNjcmlwdGlvbnNbcXVlcnlDYWNoZUtleV07XG4gICAgICAgIGlmICghc3Vic2NyaXB0aW9uU3ViU3RhdGUgfHwgIXF1ZXJ5U3ViU3RhdGUpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IHNob3VsZFJlZmV0Y2ggPSBPYmplY3QudmFsdWVzKHN1YnNjcmlwdGlvblN1YlN0YXRlKS5zb21lKChzdWIpID0+IHN1Ylt0eXBlXSA9PT0gdHJ1ZSkgfHwgT2JqZWN0LnZhbHVlcyhzdWJzY3JpcHRpb25TdWJTdGF0ZSkuZXZlcnkoKHN1YikgPT4gc3ViW3R5cGVdID09PSB2b2lkIDApICYmIHN0YXRlLmNvbmZpZ1t0eXBlXTtcbiAgICAgICAgaWYgKHNob3VsZFJlZmV0Y2gpIHtcbiAgICAgICAgICBpZiAoY291bnRPYmplY3RLZXlzKHN1YnNjcmlwdGlvblN1YlN0YXRlKSA9PT0gMCkge1xuICAgICAgICAgICAgYXBpMi5kaXNwYXRjaChyZW1vdmVRdWVyeVJlc3VsdCh7XG4gICAgICAgICAgICAgIHF1ZXJ5Q2FjaGVLZXlcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHF1ZXJ5U3ViU3RhdGUuc3RhdHVzICE9PSBcInVuaW5pdGlhbGl6ZWRcIiAvKiB1bmluaXRpYWxpemVkICovKSB7XG4gICAgICAgICAgICBhcGkyLmRpc3BhdGNoKHJlZmV0Y2hRdWVyeShxdWVyeVN1YlN0YXRlLCBxdWVyeUNhY2hlS2V5KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGhhbmRsZXI7XG59O1xuXG4vLyBzcmMvcXVlcnkvY29yZS9idWlsZE1pZGRsZXdhcmUvY2FjaGVMaWZlY3ljbGUudHNcbnZhciBuZXZlclJlc29sdmVkRXJyb3IgPSBuZXcgRXJyb3IoXCJQcm9taXNlIG5ldmVyIHJlc29sdmVkIGJlZm9yZSBjYWNoZUVudHJ5UmVtb3ZlZC5cIik7XG52YXIgYnVpbGRDYWNoZUxpZmVjeWNsZUhhbmRsZXIgPSAoe1xuICBhcGksXG4gIHJlZHVjZXJQYXRoLFxuICBjb250ZXh0LFxuICBxdWVyeVRodW5rLFxuICBtdXRhdGlvblRodW5rLFxuICBpbnRlcm5hbFN0YXRlXG59KSA9PiB7XG4gIGNvbnN0IGlzUXVlcnlUaHVuayA9IGlzQXN5bmNUaHVua0FjdGlvbihxdWVyeVRodW5rKTtcbiAgY29uc3QgaXNNdXRhdGlvblRodW5rID0gaXNBc3luY1RodW5rQWN0aW9uKG11dGF0aW9uVGh1bmspO1xuICBjb25zdCBpc0Z1bGZpbGxlZFRodW5rID0gaXNGdWxmaWxsZWQocXVlcnlUaHVuaywgbXV0YXRpb25UaHVuayk7XG4gIGNvbnN0IGxpZmVjeWNsZU1hcCA9IHt9O1xuICBjb25zdCBoYW5kbGVyID0gKGFjdGlvbiwgbXdBcGksIHN0YXRlQmVmb3JlKSA9PiB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBnZXRDYWNoZUtleShhY3Rpb24pO1xuICAgIGlmIChxdWVyeVRodW5rLnBlbmRpbmcubWF0Y2goYWN0aW9uKSkge1xuICAgICAgY29uc3Qgb2xkU3RhdGUgPSBzdGF0ZUJlZm9yZVtyZWR1Y2VyUGF0aF0ucXVlcmllc1tjYWNoZUtleV07XG4gICAgICBjb25zdCBzdGF0ZSA9IG13QXBpLmdldFN0YXRlKClbcmVkdWNlclBhdGhdLnF1ZXJpZXNbY2FjaGVLZXldO1xuICAgICAgaWYgKCFvbGRTdGF0ZSAmJiBzdGF0ZSkge1xuICAgICAgICBoYW5kbGVOZXdLZXkoYWN0aW9uLm1ldGEuYXJnLmVuZHBvaW50TmFtZSwgYWN0aW9uLm1ldGEuYXJnLm9yaWdpbmFsQXJncywgY2FjaGVLZXksIG13QXBpLCBhY3Rpb24ubWV0YS5yZXF1ZXN0SWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXV0YXRpb25UaHVuay5wZW5kaW5nLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gbXdBcGkuZ2V0U3RhdGUoKVtyZWR1Y2VyUGF0aF0ubXV0YXRpb25zW2NhY2hlS2V5XTtcbiAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICBoYW5kbGVOZXdLZXkoYWN0aW9uLm1ldGEuYXJnLmVuZHBvaW50TmFtZSwgYWN0aW9uLm1ldGEuYXJnLm9yaWdpbmFsQXJncywgY2FjaGVLZXksIG13QXBpLCBhY3Rpb24ubWV0YS5yZXF1ZXN0SWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNGdWxmaWxsZWRUaHVuayhhY3Rpb24pKSB7XG4gICAgICBjb25zdCBsaWZlY3ljbGUgPSBsaWZlY3ljbGVNYXBbY2FjaGVLZXldO1xuICAgICAgaWYgKGxpZmVjeWNsZT8udmFsdWVSZXNvbHZlZCkge1xuICAgICAgICBsaWZlY3ljbGUudmFsdWVSZXNvbHZlZCh7XG4gICAgICAgICAgZGF0YTogYWN0aW9uLnBheWxvYWQsXG4gICAgICAgICAgbWV0YTogYWN0aW9uLm1ldGEuYmFzZVF1ZXJ5TWV0YVxuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRlIGxpZmVjeWNsZS52YWx1ZVJlc29sdmVkO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXBpLmludGVybmFsQWN0aW9ucy5yZW1vdmVRdWVyeVJlc3VsdC5tYXRjaChhY3Rpb24pIHx8IGFwaS5pbnRlcm5hbEFjdGlvbnMucmVtb3ZlTXV0YXRpb25SZXN1bHQubWF0Y2goYWN0aW9uKSkge1xuICAgICAgY29uc3QgbGlmZWN5Y2xlID0gbGlmZWN5Y2xlTWFwW2NhY2hlS2V5XTtcbiAgICAgIGlmIChsaWZlY3ljbGUpIHtcbiAgICAgICAgZGVsZXRlIGxpZmVjeWNsZU1hcFtjYWNoZUtleV07XG4gICAgICAgIGxpZmVjeWNsZS5jYWNoZUVudHJ5UmVtb3ZlZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXBpLnV0aWwucmVzZXRBcGlTdGF0ZS5tYXRjaChhY3Rpb24pKSB7XG4gICAgICBmb3IgKGNvbnN0IFtjYWNoZUtleTIsIGxpZmVjeWNsZV0gb2YgT2JqZWN0LmVudHJpZXMobGlmZWN5Y2xlTWFwKSkge1xuICAgICAgICBkZWxldGUgbGlmZWN5Y2xlTWFwW2NhY2hlS2V5Ml07XG4gICAgICAgIGxpZmVjeWNsZS5jYWNoZUVudHJ5UmVtb3ZlZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZ2V0Q2FjaGVLZXkoYWN0aW9uKSB7XG4gICAgaWYgKGlzUXVlcnlUaHVuayhhY3Rpb24pKVxuICAgICAgcmV0dXJuIGFjdGlvbi5tZXRhLmFyZy5xdWVyeUNhY2hlS2V5O1xuICAgIGlmIChpc011dGF0aW9uVGh1bmsoYWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGFjdGlvbi5tZXRhLmFyZy5maXhlZENhY2hlS2V5ID8/IGFjdGlvbi5tZXRhLnJlcXVlc3RJZDtcbiAgICB9XG4gICAgaWYgKGFwaS5pbnRlcm5hbEFjdGlvbnMucmVtb3ZlUXVlcnlSZXN1bHQubWF0Y2goYWN0aW9uKSlcbiAgICAgIHJldHVybiBhY3Rpb24ucGF5bG9hZC5xdWVyeUNhY2hlS2V5O1xuICAgIGlmIChhcGkuaW50ZXJuYWxBY3Rpb25zLnJlbW92ZU11dGF0aW9uUmVzdWx0Lm1hdGNoKGFjdGlvbikpXG4gICAgICByZXR1cm4gZ2V0TXV0YXRpb25DYWNoZUtleShhY3Rpb24ucGF5bG9hZCk7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlTmV3S2V5KGVuZHBvaW50TmFtZSwgb3JpZ2luYWxBcmdzLCBxdWVyeUNhY2hlS2V5LCBtd0FwaSwgcmVxdWVzdElkKSB7XG4gICAgY29uc3QgZW5kcG9pbnREZWZpbml0aW9uID0gY29udGV4dC5lbmRwb2ludERlZmluaXRpb25zW2VuZHBvaW50TmFtZV07XG4gICAgY29uc3Qgb25DYWNoZUVudHJ5QWRkZWQgPSBlbmRwb2ludERlZmluaXRpb24/Lm9uQ2FjaGVFbnRyeUFkZGVkO1xuICAgIGlmICghb25DYWNoZUVudHJ5QWRkZWQpXG4gICAgICByZXR1cm47XG4gICAgbGV0IGxpZmVjeWNsZSA9IHt9O1xuICAgIGNvbnN0IGNhY2hlRW50cnlSZW1vdmVkID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGxpZmVjeWNsZS5jYWNoZUVudHJ5UmVtb3ZlZCA9IHJlc29sdmU7XG4gICAgfSk7XG4gICAgY29uc3QgY2FjaGVEYXRhTG9hZGVkID0gUHJvbWlzZS5yYWNlKFtuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgbGlmZWN5Y2xlLnZhbHVlUmVzb2x2ZWQgPSByZXNvbHZlO1xuICAgIH0pLCBjYWNoZUVudHJ5UmVtb3ZlZC50aGVuKCgpID0+IHtcbiAgICAgIHRocm93IG5ldmVyUmVzb2x2ZWRFcnJvcjtcbiAgICB9KV0pO1xuICAgIGNhY2hlRGF0YUxvYWRlZC5jYXRjaCgoKSA9PiB7XG4gICAgfSk7XG4gICAgbGlmZWN5Y2xlTWFwW3F1ZXJ5Q2FjaGVLZXldID0gbGlmZWN5Y2xlO1xuICAgIGNvbnN0IHNlbGVjdG9yID0gYXBpLmVuZHBvaW50c1tlbmRwb2ludE5hbWVdLnNlbGVjdChlbmRwb2ludERlZmluaXRpb24udHlwZSA9PT0gXCJxdWVyeVwiIC8qIHF1ZXJ5ICovID8gb3JpZ2luYWxBcmdzIDogcXVlcnlDYWNoZUtleSk7XG4gICAgY29uc3QgZXh0cmEgPSBtd0FwaS5kaXNwYXRjaCgoXywgX18sIGV4dHJhMikgPT4gZXh0cmEyKTtcbiAgICBjb25zdCBsaWZlY3ljbGVBcGkgPSB7XG4gICAgICAuLi5td0FwaSxcbiAgICAgIGdldENhY2hlRW50cnk6ICgpID0+IHNlbGVjdG9yKG13QXBpLmdldFN0YXRlKCkpLFxuICAgICAgcmVxdWVzdElkLFxuICAgICAgZXh0cmEsXG4gICAgICB1cGRhdGVDYWNoZWREYXRhOiBlbmRwb2ludERlZmluaXRpb24udHlwZSA9PT0gXCJxdWVyeVwiIC8qIHF1ZXJ5ICovID8gKHVwZGF0ZVJlY2lwZSkgPT4gbXdBcGkuZGlzcGF0Y2goYXBpLnV0aWwudXBkYXRlUXVlcnlEYXRhKGVuZHBvaW50TmFtZSwgb3JpZ2luYWxBcmdzLCB1cGRhdGVSZWNpcGUpKSA6IHZvaWQgMCxcbiAgICAgIGNhY2hlRGF0YUxvYWRlZCxcbiAgICAgIGNhY2hlRW50cnlSZW1vdmVkXG4gICAgfTtcbiAgICBjb25zdCBydW5uaW5nSGFuZGxlciA9IG9uQ2FjaGVFbnRyeUFkZGVkKG9yaWdpbmFsQXJncywgbGlmZWN5Y2xlQXBpKTtcbiAgICBQcm9taXNlLnJlc29sdmUocnVubmluZ0hhbmRsZXIpLmNhdGNoKChlKSA9PiB7XG4gICAgICBpZiAoZSA9PT0gbmV2ZXJSZXNvbHZlZEVycm9yKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aHJvdyBlO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBoYW5kbGVyO1xufTtcblxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRNaWRkbGV3YXJlL3F1ZXJ5TGlmZWN5Y2xlLnRzXG52YXIgYnVpbGRRdWVyeUxpZmVjeWNsZUhhbmRsZXIgPSAoe1xuICBhcGksXG4gIGNvbnRleHQsXG4gIHF1ZXJ5VGh1bmssXG4gIG11dGF0aW9uVGh1bmtcbn0pID0+IHtcbiAgY29uc3QgaXNQZW5kaW5nVGh1bmsgPSBpc1BlbmRpbmcocXVlcnlUaHVuaywgbXV0YXRpb25UaHVuayk7XG4gIGNvbnN0IGlzUmVqZWN0ZWRUaHVuayA9IGlzUmVqZWN0ZWQocXVlcnlUaHVuaywgbXV0YXRpb25UaHVuayk7XG4gIGNvbnN0IGlzRnVsbGZpbGxlZFRodW5rID0gaXNGdWxmaWxsZWQocXVlcnlUaHVuaywgbXV0YXRpb25UaHVuayk7XG4gIGNvbnN0IGxpZmVjeWNsZU1hcCA9IHt9O1xuICBjb25zdCBoYW5kbGVyID0gKGFjdGlvbiwgbXdBcGkpID0+IHtcbiAgICBpZiAoaXNQZW5kaW5nVGh1bmsoYWN0aW9uKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIGFyZzoge1xuICAgICAgICAgIGVuZHBvaW50TmFtZSxcbiAgICAgICAgICBvcmlnaW5hbEFyZ3NcbiAgICAgICAgfVxuICAgICAgfSA9IGFjdGlvbi5tZXRhO1xuICAgICAgY29uc3QgZW5kcG9pbnREZWZpbml0aW9uID0gY29udGV4dC5lbmRwb2ludERlZmluaXRpb25zW2VuZHBvaW50TmFtZV07XG4gICAgICBjb25zdCBvblF1ZXJ5U3RhcnRlZCA9IGVuZHBvaW50RGVmaW5pdGlvbj8ub25RdWVyeVN0YXJ0ZWQ7XG4gICAgICBpZiAob25RdWVyeVN0YXJ0ZWQpIHtcbiAgICAgICAgY29uc3QgbGlmZWN5Y2xlID0ge307XG4gICAgICAgIGNvbnN0IHF1ZXJ5RnVsZmlsbGVkID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGxpZmVjeWNsZS5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICBsaWZlY3ljbGUucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgcXVlcnlGdWxmaWxsZWQuY2F0Y2goKCkgPT4ge1xuICAgICAgICB9KTtcbiAgICAgICAgbGlmZWN5Y2xlTWFwW3JlcXVlc3RJZF0gPSBsaWZlY3ljbGU7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gYXBpLmVuZHBvaW50c1tlbmRwb2ludE5hbWVdLnNlbGVjdChlbmRwb2ludERlZmluaXRpb24udHlwZSA9PT0gXCJxdWVyeVwiIC8qIHF1ZXJ5ICovID8gb3JpZ2luYWxBcmdzIDogcmVxdWVzdElkKTtcbiAgICAgICAgY29uc3QgZXh0cmEgPSBtd0FwaS5kaXNwYXRjaCgoXywgX18sIGV4dHJhMikgPT4gZXh0cmEyKTtcbiAgICAgICAgY29uc3QgbGlmZWN5Y2xlQXBpID0ge1xuICAgICAgICAgIC4uLm13QXBpLFxuICAgICAgICAgIGdldENhY2hlRW50cnk6ICgpID0+IHNlbGVjdG9yKG13QXBpLmdldFN0YXRlKCkpLFxuICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICBleHRyYSxcbiAgICAgICAgICB1cGRhdGVDYWNoZWREYXRhOiBlbmRwb2ludERlZmluaXRpb24udHlwZSA9PT0gXCJxdWVyeVwiIC8qIHF1ZXJ5ICovID8gKHVwZGF0ZVJlY2lwZSkgPT4gbXdBcGkuZGlzcGF0Y2goYXBpLnV0aWwudXBkYXRlUXVlcnlEYXRhKGVuZHBvaW50TmFtZSwgb3JpZ2luYWxBcmdzLCB1cGRhdGVSZWNpcGUpKSA6IHZvaWQgMCxcbiAgICAgICAgICBxdWVyeUZ1bGZpbGxlZFxuICAgICAgICB9O1xuICAgICAgICBvblF1ZXJ5U3RhcnRlZChvcmlnaW5hbEFyZ3MsIGxpZmVjeWNsZUFwaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0Z1bGxmaWxsZWRUaHVuayhhY3Rpb24pKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgYmFzZVF1ZXJ5TWV0YVxuICAgICAgfSA9IGFjdGlvbi5tZXRhO1xuICAgICAgbGlmZWN5Y2xlTWFwW3JlcXVlc3RJZF0/LnJlc29sdmUoe1xuICAgICAgICBkYXRhOiBhY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgbWV0YTogYmFzZVF1ZXJ5TWV0YVxuICAgICAgfSk7XG4gICAgICBkZWxldGUgbGlmZWN5Y2xlTWFwW3JlcXVlc3RJZF07XG4gICAgfSBlbHNlIGlmIChpc1JlamVjdGVkVGh1bmsoYWN0aW9uKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIHJlamVjdGVkV2l0aFZhbHVlLFxuICAgICAgICBiYXNlUXVlcnlNZXRhXG4gICAgICB9ID0gYWN0aW9uLm1ldGE7XG4gICAgICBsaWZlY3ljbGVNYXBbcmVxdWVzdElkXT8ucmVqZWN0KHtcbiAgICAgICAgZXJyb3I6IGFjdGlvbi5wYXlsb2FkID8/IGFjdGlvbi5lcnJvcixcbiAgICAgICAgaXNVbmhhbmRsZWRFcnJvcjogIXJlamVjdGVkV2l0aFZhbHVlLFxuICAgICAgICBtZXRhOiBiYXNlUXVlcnlNZXRhXG4gICAgICB9KTtcbiAgICAgIGRlbGV0ZSBsaWZlY3ljbGVNYXBbcmVxdWVzdElkXTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBoYW5kbGVyO1xufTtcblxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRNaWRkbGV3YXJlL2Rldk1pZGRsZXdhcmUudHNcbnZhciBidWlsZERldkNoZWNrSGFuZGxlciA9ICh7XG4gIGFwaSxcbiAgY29udGV4dDoge1xuICAgIGFwaVVpZFxuICB9LFxuICByZWR1Y2VyUGF0aFxufSkgPT4ge1xuICByZXR1cm4gKGFjdGlvbiwgbXdBcGkpID0+IHtcbiAgICBpZiAoYXBpLnV0aWwucmVzZXRBcGlTdGF0ZS5tYXRjaChhY3Rpb24pKSB7XG4gICAgICBtd0FwaS5kaXNwYXRjaChhcGkuaW50ZXJuYWxBY3Rpb25zLm1pZGRsZXdhcmVSZWdpc3RlcmVkKGFwaVVpZCkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgaWYgKGFwaS5pbnRlcm5hbEFjdGlvbnMubWlkZGxld2FyZVJlZ2lzdGVyZWQubWF0Y2goYWN0aW9uKSAmJiBhY3Rpb24ucGF5bG9hZCA9PT0gYXBpVWlkICYmIG13QXBpLmdldFN0YXRlKClbcmVkdWNlclBhdGhdPy5jb25maWc/Lm1pZGRsZXdhcmVSZWdpc3RlcmVkID09PSBcImNvbmZsaWN0XCIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBUaGVyZSBpcyBhIG1pc21hdGNoIGJldHdlZW4gc2xpY2UgYW5kIG1pZGRsZXdhcmUgZm9yIHRoZSByZWR1Y2VyUGF0aCBcIiR7cmVkdWNlclBhdGh9XCIuXG5Zb3UgY2FuIG9ubHkgaGF2ZSBvbmUgYXBpIHBlciByZWR1Y2VyIHBhdGgsIHRoaXMgd2lsbCBsZWFkIHRvIGNyYXNoZXMgaW4gdmFyaW91cyBzaXR1YXRpb25zISR7cmVkdWNlclBhdGggPT09IFwiYXBpXCIgPyBgXG5JZiB5b3UgaGF2ZSBtdWx0aXBsZSBhcGlzLCB5b3UgKmhhdmUqIHRvIHNwZWNpZnkgdGhlIHJlZHVjZXJQYXRoIG9wdGlvbiB3aGVuIHVzaW5nIGNyZWF0ZUFwaSFgIDogXCJcIn1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG4vLyBzcmMvcXVlcnkvY29yZS9idWlsZE1pZGRsZXdhcmUvYmF0Y2hBY3Rpb25zLnRzXG5pbXBvcnQgeyBwcm9kdWNlV2l0aFBhdGNoZXMgYXMgcHJvZHVjZVdpdGhQYXRjaGVzMiB9IGZyb20gXCJpbW1lclwiO1xudmFyIGJ1aWxkQmF0Y2hlZEFjdGlvbnNIYW5kbGVyID0gKHtcbiAgYXBpLFxuICBxdWVyeVRodW5rLFxuICBpbnRlcm5hbFN0YXRlXG59KSA9PiB7XG4gIGNvbnN0IHN1YnNjcmlwdGlvbnNQcmVmaXggPSBgJHthcGkucmVkdWNlclBhdGh9L3N1YnNjcmlwdGlvbnNgO1xuICBsZXQgcHJldmlvdXNTdWJzY3JpcHRpb25zID0gbnVsbDtcbiAgbGV0IHVwZGF0ZVN5bmNUaW1lciA9IG51bGw7XG4gIGNvbnN0IHtcbiAgICB1cGRhdGVTdWJzY3JpcHRpb25PcHRpb25zLFxuICAgIHVuc3Vic2NyaWJlUXVlcnlSZXN1bHRcbiAgfSA9IGFwaS5pbnRlcm5hbEFjdGlvbnM7XG4gIGNvbnN0IGFjdHVhbGx5TXV0YXRlU3Vic2NyaXB0aW9ucyA9IChtdXRhYmxlU3RhdGUsIGFjdGlvbikgPT4ge1xuICAgIGlmICh1cGRhdGVTdWJzY3JpcHRpb25PcHRpb25zLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcXVlcnlDYWNoZUtleSxcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICBpZiAobXV0YWJsZVN0YXRlPy5bcXVlcnlDYWNoZUtleV0/LltyZXF1ZXN0SWRdKSB7XG4gICAgICAgIG11dGFibGVTdGF0ZVtxdWVyeUNhY2hlS2V5XVtyZXF1ZXN0SWRdID0gb3B0aW9ucztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodW5zdWJzY3JpYmVRdWVyeVJlc3VsdC5tYXRjaChhY3Rpb24pKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHF1ZXJ5Q2FjaGVLZXksXG4gICAgICAgIHJlcXVlc3RJZFxuICAgICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgaWYgKG11dGFibGVTdGF0ZVtxdWVyeUNhY2hlS2V5XSkge1xuICAgICAgICBkZWxldGUgbXV0YWJsZVN0YXRlW3F1ZXJ5Q2FjaGVLZXldW3JlcXVlc3RJZF07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGFwaS5pbnRlcm5hbEFjdGlvbnMucmVtb3ZlUXVlcnlSZXN1bHQubWF0Y2goYWN0aW9uKSkge1xuICAgICAgZGVsZXRlIG11dGFibGVTdGF0ZVthY3Rpb24ucGF5bG9hZC5xdWVyeUNhY2hlS2V5XTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAocXVlcnlUaHVuay5wZW5kaW5nLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWV0YToge1xuICAgICAgICAgIGFyZyxcbiAgICAgICAgICByZXF1ZXN0SWRcbiAgICAgICAgfVxuICAgICAgfSA9IGFjdGlvbjtcbiAgICAgIGNvbnN0IHN1YnN0YXRlID0gbXV0YWJsZVN0YXRlW2FyZy5xdWVyeUNhY2hlS2V5XSA/Pz0ge307XG4gICAgICBzdWJzdGF0ZVtgJHtyZXF1ZXN0SWR9X3J1bm5pbmdgXSA9IHt9O1xuICAgICAgaWYgKGFyZy5zdWJzY3JpYmUpIHtcbiAgICAgICAgc3Vic3RhdGVbcmVxdWVzdElkXSA9IGFyZy5zdWJzY3JpcHRpb25PcHRpb25zID8/IHN1YnN0YXRlW3JlcXVlc3RJZF0gPz8ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IG11dGF0ZWQgPSBmYWxzZTtcbiAgICBpZiAocXVlcnlUaHVuay5mdWxmaWxsZWQubWF0Y2goYWN0aW9uKSB8fCBxdWVyeVRodW5rLnJlamVjdGVkLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gbXV0YWJsZVN0YXRlW2FjdGlvbi5tZXRhLmFyZy5xdWVyeUNhY2hlS2V5XSB8fCB7fTtcbiAgICAgIGNvbnN0IGtleSA9IGAke2FjdGlvbi5tZXRhLnJlcXVlc3RJZH1fcnVubmluZ2A7XG4gICAgICBtdXRhdGVkIHx8PSAhIXN0YXRlW2tleV07XG4gICAgICBkZWxldGUgc3RhdGVba2V5XTtcbiAgICB9XG4gICAgaWYgKHF1ZXJ5VGh1bmsucmVqZWN0ZWQubWF0Y2goYWN0aW9uKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgY29uZGl0aW9uLFxuICAgICAgICAgIGFyZyxcbiAgICAgICAgICByZXF1ZXN0SWRcbiAgICAgICAgfVxuICAgICAgfSA9IGFjdGlvbjtcbiAgICAgIGlmIChjb25kaXRpb24gJiYgYXJnLnN1YnNjcmliZSkge1xuICAgICAgICBjb25zdCBzdWJzdGF0ZSA9IG11dGFibGVTdGF0ZVthcmcucXVlcnlDYWNoZUtleV0gPz89IHt9O1xuICAgICAgICBzdWJzdGF0ZVtyZXF1ZXN0SWRdID0gYXJnLnN1YnNjcmlwdGlvbk9wdGlvbnMgPz8gc3Vic3RhdGVbcmVxdWVzdElkXSA/PyB7fTtcbiAgICAgICAgbXV0YXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtdXRhdGVkO1xuICB9O1xuICBjb25zdCBnZXRTdWJzY3JpcHRpb25zID0gKCkgPT4gaW50ZXJuYWxTdGF0ZS5jdXJyZW50U3Vic2NyaXB0aW9ucztcbiAgY29uc3QgZ2V0U3Vic2NyaXB0aW9uQ291bnQgPSAocXVlcnlDYWNoZUtleSkgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSBnZXRTdWJzY3JpcHRpb25zKCk7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uc0ZvclF1ZXJ5QXJnID0gc3Vic2NyaXB0aW9uc1txdWVyeUNhY2hlS2V5XSA/PyB7fTtcbiAgICByZXR1cm4gY291bnRPYmplY3RLZXlzKHN1YnNjcmlwdGlvbnNGb3JRdWVyeUFyZyk7XG4gIH07XG4gIGNvbnN0IGlzUmVxdWVzdFN1YnNjcmliZWQgPSAocXVlcnlDYWNoZUtleSwgcmVxdWVzdElkKSA9PiB7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IGdldFN1YnNjcmlwdGlvbnMoKTtcbiAgICByZXR1cm4gISFzdWJzY3JpcHRpb25zPy5bcXVlcnlDYWNoZUtleV0/LltyZXF1ZXN0SWRdO1xuICB9O1xuICBjb25zdCBzdWJzY3JpcHRpb25TZWxlY3RvcnMgPSB7XG4gICAgZ2V0U3Vic2NyaXB0aW9ucyxcbiAgICBnZXRTdWJzY3JpcHRpb25Db3VudCxcbiAgICBpc1JlcXVlc3RTdWJzY3JpYmVkXG4gIH07XG4gIHJldHVybiAoYWN0aW9uLCBtd0FwaSkgPT4ge1xuICAgIGlmICghcHJldmlvdXNTdWJzY3JpcHRpb25zKSB7XG4gICAgICBwcmV2aW91c1N1YnNjcmlwdGlvbnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGludGVybmFsU3RhdGUuY3VycmVudFN1YnNjcmlwdGlvbnMpKTtcbiAgICB9XG4gICAgaWYgKGFwaS51dGlsLnJlc2V0QXBpU3RhdGUubWF0Y2goYWN0aW9uKSkge1xuICAgICAgcHJldmlvdXNTdWJzY3JpcHRpb25zID0gaW50ZXJuYWxTdGF0ZS5jdXJyZW50U3Vic2NyaXB0aW9ucyA9IHt9O1xuICAgICAgdXBkYXRlU3luY1RpbWVyID0gbnVsbDtcbiAgICAgIHJldHVybiBbdHJ1ZSwgZmFsc2VdO1xuICAgIH1cbiAgICBpZiAoYXBpLmludGVybmFsQWN0aW9ucy5pbnRlcm5hbF9nZXRSVEtRU3Vic2NyaXB0aW9ucy5tYXRjaChhY3Rpb24pKSB7XG4gICAgICByZXR1cm4gW2ZhbHNlLCBzdWJzY3JpcHRpb25TZWxlY3RvcnNdO1xuICAgIH1cbiAgICBjb25zdCBkaWRNdXRhdGUgPSBhY3R1YWxseU11dGF0ZVN1YnNjcmlwdGlvbnMoaW50ZXJuYWxTdGF0ZS5jdXJyZW50U3Vic2NyaXB0aW9ucywgYWN0aW9uKTtcbiAgICBsZXQgYWN0aW9uU2hvdWxkQ29udGludWUgPSB0cnVlO1xuICAgIGlmIChkaWRNdXRhdGUpIHtcbiAgICAgIGlmICghdXBkYXRlU3luY1RpbWVyKSB7XG4gICAgICAgIHVwZGF0ZVN5bmNUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IG5ld1N1YnNjcmlwdGlvbnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGludGVybmFsU3RhdGUuY3VycmVudFN1YnNjcmlwdGlvbnMpKTtcbiAgICAgICAgICBjb25zdCBbLCBwYXRjaGVzXSA9IHByb2R1Y2VXaXRoUGF0Y2hlczIocHJldmlvdXNTdWJzY3JpcHRpb25zLCAoKSA9PiBuZXdTdWJzY3JpcHRpb25zKTtcbiAgICAgICAgICBtd0FwaS5uZXh0KGFwaS5pbnRlcm5hbEFjdGlvbnMuc3Vic2NyaXB0aW9uc1VwZGF0ZWQocGF0Y2hlcykpO1xuICAgICAgICAgIHByZXZpb3VzU3Vic2NyaXB0aW9ucyA9IG5ld1N1YnNjcmlwdGlvbnM7XG4gICAgICAgICAgdXBkYXRlU3luY1RpbWVyID0gbnVsbDtcbiAgICAgICAgfSwgNTAwKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzU3Vic2NyaXB0aW9uU2xpY2VBY3Rpb24gPSB0eXBlb2YgYWN0aW9uLnR5cGUgPT0gXCJzdHJpbmdcIiAmJiAhIWFjdGlvbi50eXBlLnN0YXJ0c1dpdGgoc3Vic2NyaXB0aW9uc1ByZWZpeCk7XG4gICAgICBjb25zdCBpc0FkZGl0aW9uYWxTdWJzY3JpcHRpb25BY3Rpb24gPSBxdWVyeVRodW5rLnJlamVjdGVkLm1hdGNoKGFjdGlvbikgJiYgYWN0aW9uLm1ldGEuY29uZGl0aW9uICYmICEhYWN0aW9uLm1ldGEuYXJnLnN1YnNjcmliZTtcbiAgICAgIGFjdGlvblNob3VsZENvbnRpbnVlID0gIWlzU3Vic2NyaXB0aW9uU2xpY2VBY3Rpb24gJiYgIWlzQWRkaXRpb25hbFN1YnNjcmlwdGlvbkFjdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIFthY3Rpb25TaG91bGRDb250aW51ZSwgZmFsc2VdO1xuICB9O1xufTtcblxuLy8gc3JjL3F1ZXJ5L2NvcmUvYnVpbGRNaWRkbGV3YXJlL2luZGV4LnRzXG5mdW5jdGlvbiBidWlsZE1pZGRsZXdhcmUoaW5wdXQpIHtcbiAgY29uc3Qge1xuICAgIHJlZHVjZXJQYXRoLFxuICAgIHF1ZXJ5VGh1bmssXG4gICAgYXBpLFxuICAgIGNvbnRleHRcbiAgfSA9IGlucHV0O1xuICBjb25zdCB7XG4gICAgYXBpVWlkXG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCBhY3Rpb25zID0ge1xuICAgIGludmFsaWRhdGVUYWdzOiBjcmVhdGVBY3Rpb24oYCR7cmVkdWNlclBhdGh9L2ludmFsaWRhdGVUYWdzYClcbiAgfTtcbiAgY29uc3QgaXNUaGlzQXBpU2xpY2VBY3Rpb24gPSAoYWN0aW9uKSA9PiBhY3Rpb24udHlwZS5zdGFydHNXaXRoKGAke3JlZHVjZXJQYXRofS9gKTtcbiAgY29uc3QgaGFuZGxlckJ1aWxkZXJzID0gW2J1aWxkRGV2Q2hlY2tIYW5kbGVyLCBidWlsZENhY2hlQ29sbGVjdGlvbkhhbmRsZXIsIGJ1aWxkSW52YWxpZGF0aW9uQnlUYWdzSGFuZGxlciwgYnVpbGRQb2xsaW5nSGFuZGxlciwgYnVpbGRDYWNoZUxpZmVjeWNsZUhhbmRsZXIsIGJ1aWxkUXVlcnlMaWZlY3ljbGVIYW5kbGVyXTtcbiAgY29uc3QgbWlkZGxld2FyZSA9IChtd0FwaSkgPT4ge1xuICAgIGxldCBpbml0aWFsaXplZDIgPSBmYWxzZTtcbiAgICBsZXQgaW50ZXJuYWxTdGF0ZSA9IHtcbiAgICAgIGN1cnJlbnRTdWJzY3JpcHRpb25zOiB7fVxuICAgIH07XG4gICAgY29uc3QgYnVpbGRlckFyZ3MgPSB7XG4gICAgICAuLi5pbnB1dCxcbiAgICAgIGludGVybmFsU3RhdGUsXG4gICAgICByZWZldGNoUXVlcnksXG4gICAgICBpc1RoaXNBcGlTbGljZUFjdGlvblxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlcnMgPSBoYW5kbGVyQnVpbGRlcnMubWFwKChidWlsZCkgPT4gYnVpbGQoYnVpbGRlckFyZ3MpKTtcbiAgICBjb25zdCBiYXRjaGVkQWN0aW9uc0hhbmRsZXIgPSBidWlsZEJhdGNoZWRBY3Rpb25zSGFuZGxlcihidWlsZGVyQXJncyk7XG4gICAgY29uc3Qgd2luZG93RXZlbnRzSGFuZGxlciA9IGJ1aWxkV2luZG93RXZlbnRIYW5kbGVyKGJ1aWxkZXJBcmdzKTtcbiAgICByZXR1cm4gKG5leHQpID0+IHtcbiAgICAgIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgICAgIGlmICghaXNBY3Rpb24oYWN0aW9uKSkge1xuICAgICAgICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbml0aWFsaXplZDIpIHtcbiAgICAgICAgICBpbml0aWFsaXplZDIgPSB0cnVlO1xuICAgICAgICAgIG13QXBpLmRpc3BhdGNoKGFwaS5pbnRlcm5hbEFjdGlvbnMubWlkZGxld2FyZVJlZ2lzdGVyZWQoYXBpVWlkKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbXdBcGlXaXRoTmV4dCA9IHtcbiAgICAgICAgICAuLi5td0FwaSxcbiAgICAgICAgICBuZXh0XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN0YXRlQmVmb3JlID0gbXdBcGkuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3QgW2FjdGlvblNob3VsZENvbnRpbnVlLCBpbnRlcm5hbFByb2JlUmVzdWx0XSA9IGJhdGNoZWRBY3Rpb25zSGFuZGxlcihhY3Rpb24sIG13QXBpV2l0aE5leHQsIHN0YXRlQmVmb3JlKTtcbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgaWYgKGFjdGlvblNob3VsZENvbnRpbnVlKSB7XG4gICAgICAgICAgcmVzID0gbmV4dChhY3Rpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcyA9IGludGVybmFsUHJvYmVSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEhbXdBcGkuZ2V0U3RhdGUoKVtyZWR1Y2VyUGF0aF0pIHtcbiAgICAgICAgICB3aW5kb3dFdmVudHNIYW5kbGVyKGFjdGlvbiwgbXdBcGlXaXRoTmV4dCwgc3RhdGVCZWZvcmUpO1xuICAgICAgICAgIGlmIChpc1RoaXNBcGlTbGljZUFjdGlvbihhY3Rpb24pIHx8IGNvbnRleHQuaGFzUmVoeWRyYXRpb25JbmZvKGFjdGlvbikpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGhhbmRsZXIgb2YgaGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgaGFuZGxlcihhY3Rpb24sIG13QXBpV2l0aE5leHQsIHN0YXRlQmVmb3JlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH07XG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBtaWRkbGV3YXJlLFxuICAgIGFjdGlvbnNcbiAgfTtcbiAgZnVuY3Rpb24gcmVmZXRjaFF1ZXJ5KHF1ZXJ5U3ViU3RhdGUsIHF1ZXJ5Q2FjaGVLZXksIG92ZXJyaWRlID0ge30pIHtcbiAgICByZXR1cm4gcXVlcnlUaHVuayh7XG4gICAgICB0eXBlOiBcInF1ZXJ5XCIsXG4gICAgICBlbmRwb2ludE5hbWU6IHF1ZXJ5U3ViU3RhdGUuZW5kcG9pbnROYW1lLFxuICAgICAgb3JpZ2luYWxBcmdzOiBxdWVyeVN1YlN0YXRlLm9yaWdpbmFsQXJncyxcbiAgICAgIHN1YnNjcmliZTogZmFsc2UsXG4gICAgICBmb3JjZVJlZmV0Y2g6IHRydWUsXG4gICAgICBxdWVyeUNhY2hlS2V5LFxuICAgICAgLi4ub3ZlcnJpZGVcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBzcmMvcXVlcnkvdHNIZWxwZXJzLnRzXG5mdW5jdGlvbiBhc3NlcnRDYXN0KHYpIHtcbn1cbmZ1bmN0aW9uIHNhZmVBc3NpZ24odGFyZ2V0LCAuLi5hcmdzKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHRhcmdldCwgLi4uYXJncyk7XG59XG5cbi8vIHNyYy9xdWVyeS9jb3JlL21vZHVsZS50c1xuaW1wb3J0IHsgZW5hYmxlUGF0Y2hlcyB9IGZyb20gXCJpbW1lclwiO1xudmFyIGNvcmVNb2R1bGVOYW1lID0gLyogQF9fUFVSRV9fICovIFN5bWJvbCgpO1xudmFyIGNvcmVNb2R1bGUgPSAoe1xuICBjcmVhdGVTZWxlY3RvcjogY3JlYXRlU2VsZWN0b3IyID0gY3JlYXRlU2VsZWN0b3Jcbn0gPSB7fSkgPT4gKHtcbiAgbmFtZTogY29yZU1vZHVsZU5hbWUsXG4gIGluaXQoYXBpLCB7XG4gICAgYmFzZVF1ZXJ5LFxuICAgIHRhZ1R5cGVzLFxuICAgIHJlZHVjZXJQYXRoLFxuICAgIHNlcmlhbGl6ZVF1ZXJ5QXJncyxcbiAgICBrZWVwVW51c2VkRGF0YUZvcixcbiAgICByZWZldGNoT25Nb3VudE9yQXJnQ2hhbmdlLFxuICAgIHJlZmV0Y2hPbkZvY3VzLFxuICAgIHJlZmV0Y2hPblJlY29ubmVjdCxcbiAgICBpbnZhbGlkYXRpb25CZWhhdmlvclxuICB9LCBjb250ZXh0KSB7XG4gICAgZW5hYmxlUGF0Y2hlcygpO1xuICAgIGFzc2VydENhc3Qoc2VyaWFsaXplUXVlcnlBcmdzKTtcbiAgICBjb25zdCBhc3NlcnRUYWdUeXBlID0gKHRhZykgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgaWYgKCF0YWdUeXBlcy5pbmNsdWRlcyh0YWcudHlwZSkpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBUYWcgdHlwZSAnJHt0YWcudHlwZX0nIHdhcyB1c2VkLCBidXQgbm90IHNwZWNpZmllZCBpbiBcXGB0YWdUeXBlc1xcYCFgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRhZztcbiAgICB9O1xuICAgIE9iamVjdC5hc3NpZ24oYXBpLCB7XG4gICAgICByZWR1Y2VyUGF0aCxcbiAgICAgIGVuZHBvaW50czoge30sXG4gICAgICBpbnRlcm5hbEFjdGlvbnM6IHtcbiAgICAgICAgb25PbmxpbmUsXG4gICAgICAgIG9uT2ZmbGluZSxcbiAgICAgICAgb25Gb2N1cyxcbiAgICAgICAgb25Gb2N1c0xvc3RcbiAgICAgIH0sXG4gICAgICB1dGlsOiB7fVxuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIHF1ZXJ5VGh1bmssXG4gICAgICBtdXRhdGlvblRodW5rLFxuICAgICAgcGF0Y2hRdWVyeURhdGEsXG4gICAgICB1cGRhdGVRdWVyeURhdGEsXG4gICAgICB1cHNlcnRRdWVyeURhdGEsXG4gICAgICBwcmVmZXRjaCxcbiAgICAgIGJ1aWxkTWF0Y2hUaHVua0FjdGlvbnNcbiAgICB9ID0gYnVpbGRUaHVua3Moe1xuICAgICAgYmFzZVF1ZXJ5LFxuICAgICAgcmVkdWNlclBhdGgsXG4gICAgICBjb250ZXh0LFxuICAgICAgYXBpLFxuICAgICAgc2VyaWFsaXplUXVlcnlBcmdzLFxuICAgICAgYXNzZXJ0VGFnVHlwZVxuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlZHVjZXIsXG4gICAgICBhY3Rpb25zOiBzbGljZUFjdGlvbnNcbiAgICB9ID0gYnVpbGRTbGljZSh7XG4gICAgICBjb250ZXh0LFxuICAgICAgcXVlcnlUaHVuayxcbiAgICAgIG11dGF0aW9uVGh1bmssXG4gICAgICByZWR1Y2VyUGF0aCxcbiAgICAgIGFzc2VydFRhZ1R5cGUsXG4gICAgICBjb25maWc6IHtcbiAgICAgICAgcmVmZXRjaE9uRm9jdXMsXG4gICAgICAgIHJlZmV0Y2hPblJlY29ubmVjdCxcbiAgICAgICAgcmVmZXRjaE9uTW91bnRPckFyZ0NoYW5nZSxcbiAgICAgICAga2VlcFVudXNlZERhdGFGb3IsXG4gICAgICAgIHJlZHVjZXJQYXRoLFxuICAgICAgICBpbnZhbGlkYXRpb25CZWhhdmlvclxuICAgICAgfVxuICAgIH0pO1xuICAgIHNhZmVBc3NpZ24oYXBpLnV0aWwsIHtcbiAgICAgIHBhdGNoUXVlcnlEYXRhLFxuICAgICAgdXBkYXRlUXVlcnlEYXRhLFxuICAgICAgdXBzZXJ0UXVlcnlEYXRhLFxuICAgICAgcHJlZmV0Y2gsXG4gICAgICByZXNldEFwaVN0YXRlOiBzbGljZUFjdGlvbnMucmVzZXRBcGlTdGF0ZVxuICAgIH0pO1xuICAgIHNhZmVBc3NpZ24oYXBpLmludGVybmFsQWN0aW9ucywgc2xpY2VBY3Rpb25zKTtcbiAgICBjb25zdCB7XG4gICAgICBtaWRkbGV3YXJlLFxuICAgICAgYWN0aW9uczogbWlkZGxld2FyZUFjdGlvbnNcbiAgICB9ID0gYnVpbGRNaWRkbGV3YXJlKHtcbiAgICAgIHJlZHVjZXJQYXRoLFxuICAgICAgY29udGV4dCxcbiAgICAgIHF1ZXJ5VGh1bmssXG4gICAgICBtdXRhdGlvblRodW5rLFxuICAgICAgYXBpLFxuICAgICAgYXNzZXJ0VGFnVHlwZVxuICAgIH0pO1xuICAgIHNhZmVBc3NpZ24oYXBpLnV0aWwsIG1pZGRsZXdhcmVBY3Rpb25zKTtcbiAgICBzYWZlQXNzaWduKGFwaSwge1xuICAgICAgcmVkdWNlcixcbiAgICAgIG1pZGRsZXdhcmVcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBidWlsZFF1ZXJ5U2VsZWN0b3IsXG4gICAgICBidWlsZE11dGF0aW9uU2VsZWN0b3IsXG4gICAgICBzZWxlY3RJbnZhbGlkYXRlZEJ5LFxuICAgICAgc2VsZWN0Q2FjaGVkQXJnc0ZvclF1ZXJ5XG4gICAgfSA9IGJ1aWxkU2VsZWN0b3JzKHtcbiAgICAgIHNlcmlhbGl6ZVF1ZXJ5QXJncyxcbiAgICAgIHJlZHVjZXJQYXRoLFxuICAgICAgY3JlYXRlU2VsZWN0b3I6IGNyZWF0ZVNlbGVjdG9yMlxuICAgIH0pO1xuICAgIHNhZmVBc3NpZ24oYXBpLnV0aWwsIHtcbiAgICAgIHNlbGVjdEludmFsaWRhdGVkQnksXG4gICAgICBzZWxlY3RDYWNoZWRBcmdzRm9yUXVlcnlcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBidWlsZEluaXRpYXRlUXVlcnksXG4gICAgICBidWlsZEluaXRpYXRlTXV0YXRpb24sXG4gICAgICBnZXRSdW5uaW5nTXV0YXRpb25UaHVuayxcbiAgICAgIGdldFJ1bm5pbmdNdXRhdGlvbnNUaHVuayxcbiAgICAgIGdldFJ1bm5pbmdRdWVyaWVzVGh1bmssXG4gICAgICBnZXRSdW5uaW5nUXVlcnlUaHVua1xuICAgIH0gPSBidWlsZEluaXRpYXRlKHtcbiAgICAgIHF1ZXJ5VGh1bmssXG4gICAgICBtdXRhdGlvblRodW5rLFxuICAgICAgYXBpLFxuICAgICAgc2VyaWFsaXplUXVlcnlBcmdzLFxuICAgICAgY29udGV4dFxuICAgIH0pO1xuICAgIHNhZmVBc3NpZ24oYXBpLnV0aWwsIHtcbiAgICAgIGdldFJ1bm5pbmdNdXRhdGlvblRodW5rLFxuICAgICAgZ2V0UnVubmluZ011dGF0aW9uc1RodW5rLFxuICAgICAgZ2V0UnVubmluZ1F1ZXJ5VGh1bmssXG4gICAgICBnZXRSdW5uaW5nUXVlcmllc1RodW5rXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IGNvcmVNb2R1bGVOYW1lLFxuICAgICAgaW5qZWN0RW5kcG9pbnQoZW5kcG9pbnROYW1lLCBkZWZpbml0aW9uKSB7XG4gICAgICAgIGNvbnN0IGFueUFwaSA9IGFwaTtcbiAgICAgICAgYW55QXBpLmVuZHBvaW50c1tlbmRwb2ludE5hbWVdID8/PSB7fTtcbiAgICAgICAgaWYgKGlzUXVlcnlEZWZpbml0aW9uKGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgc2FmZUFzc2lnbihhbnlBcGkuZW5kcG9pbnRzW2VuZHBvaW50TmFtZV0sIHtcbiAgICAgICAgICAgIG5hbWU6IGVuZHBvaW50TmFtZSxcbiAgICAgICAgICAgIHNlbGVjdDogYnVpbGRRdWVyeVNlbGVjdG9yKGVuZHBvaW50TmFtZSwgZGVmaW5pdGlvbiksXG4gICAgICAgICAgICBpbml0aWF0ZTogYnVpbGRJbml0aWF0ZVF1ZXJ5KGVuZHBvaW50TmFtZSwgZGVmaW5pdGlvbilcbiAgICAgICAgICB9LCBidWlsZE1hdGNoVGh1bmtBY3Rpb25zKHF1ZXJ5VGh1bmssIGVuZHBvaW50TmFtZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTXV0YXRpb25EZWZpbml0aW9uKGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgc2FmZUFzc2lnbihhbnlBcGkuZW5kcG9pbnRzW2VuZHBvaW50TmFtZV0sIHtcbiAgICAgICAgICAgIG5hbWU6IGVuZHBvaW50TmFtZSxcbiAgICAgICAgICAgIHNlbGVjdDogYnVpbGRNdXRhdGlvblNlbGVjdG9yKCksXG4gICAgICAgICAgICBpbml0aWF0ZTogYnVpbGRJbml0aWF0ZU11dGF0aW9uKGVuZHBvaW50TmFtZSlcbiAgICAgICAgICB9LCBidWlsZE1hdGNoVGh1bmtBY3Rpb25zKG11dGF0aW9uVGh1bmssIGVuZHBvaW50TmFtZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIHNyYy9xdWVyeS9jb3JlL2luZGV4LnRzXG52YXIgY3JlYXRlQXBpID0gLyogQF9fUFVSRV9fICovIGJ1aWxkQ3JlYXRlQXBpKGNvcmVNb2R1bGUoKSk7XG5leHBvcnQge1xuICBRdWVyeVN0YXR1cyxcbiAgYnVpbGRDcmVhdGVBcGksXG4gIGNvcHlXaXRoU3RydWN0dXJhbFNoYXJpbmcsXG4gIGNvcmVNb2R1bGUsXG4gIGNvcmVNb2R1bGVOYW1lLFxuICBjcmVhdGVBcGksXG4gIGRlZmF1bHRTZXJpYWxpemVRdWVyeUFyZ3MsXG4gIGZha2VCYXNlUXVlcnksXG4gIGZldGNoQmFzZVF1ZXJ5LFxuICByZXRyeSxcbiAgc2V0dXBMaXN0ZW5lcnMsXG4gIHNraXBUb2tlblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJ0ay1xdWVyeS5tb2Rlcm4ubWpzLm1hcCJdLCJuYW1lcyI6WyJRdWVyeVN0YXR1cyIsIlF1ZXJ5U3RhdHVzMiIsImdldFJlcXVlc3RTdGF0dXNGbGFncyIsInN0YXR1cyIsImlzVW5pbml0aWFsaXplZCIsImlzTG9hZGluZyIsImlzU3VjY2VzcyIsImlzRXJyb3IiLCJpc0Fic29sdXRlVXJsIiwidXJsIiwiUmVnRXhwIiwidGVzdCIsIndpdGhvdXRUcmFpbGluZ1NsYXNoIiwicmVwbGFjZSIsIndpdGhvdXRMZWFkaW5nU2xhc2giLCJqb2luVXJscyIsImJhc2UiLCJkZWxpbWl0ZXIiLCJlbmRzV2l0aCIsInN0YXJ0c1dpdGgiLCJmbGF0dGVuIiwiYXJyIiwiY29uY2F0IiwiaXNPbmxpbmUiLCJuYXZpZ2F0b3IiLCJvbkxpbmUiLCJpc0RvY3VtZW50VmlzaWJsZSIsImRvY3VtZW50IiwidmlzaWJpbGl0eVN0YXRlIiwiY3JlYXRlQWN0aW9uIiwiY3JlYXRlU2xpY2UiLCJjcmVhdGVTZWxlY3RvciIsImNyZWF0ZUFzeW5jVGh1bmsiLCJjb21iaW5lUmVkdWNlcnMiLCJjcmVhdGVOZXh0U3RhdGUiLCJpc0FueU9mIiwiaXNBbGxPZiIsImlzQWN0aW9uIiwiaXNQZW5kaW5nIiwiaXNSZWplY3RlZCIsImlzRnVsZmlsbGVkIiwiaXNSZWplY3RlZFdpdGhWYWx1ZSIsImlzQXN5bmNUaHVua0FjdGlvbiIsInByZXBhcmVBdXRvQmF0Y2hlZCIsIlNIT1VMRF9BVVRPQkFUQ0giLCJpc1BsYWluT2JqZWN0IiwibmFub2lkIiwiaXNQbGFpbk9iamVjdDIiLCJjb3B5V2l0aFN0cnVjdHVyYWxTaGFyaW5nIiwib2xkT2JqIiwibmV3T2JqIiwiQXJyYXkiLCJpc0FycmF5IiwibmV3S2V5cyIsIk9iamVjdCIsImtleXMiLCJvbGRLZXlzIiwiaXNTYW1lT2JqZWN0IiwibGVuZ3RoIiwibWVyZ2VPYmoiLCJrZXkiLCJkZWZhdWx0RmV0Y2hGbiIsImFyZ3MiLCJmZXRjaCIsImRlZmF1bHRWYWxpZGF0ZVN0YXR1cyIsInJlc3BvbnNlIiwiZGVmYXVsdElzSnNvbkNvbnRlbnRUeXBlIiwiaGVhZGVycyIsImdldCIsInN0cmlwVW5kZWZpbmVkIiwib2JqIiwiY29weSIsImsiLCJ2IiwiZW50cmllcyIsImZldGNoQmFzZVF1ZXJ5IiwiYmFzZVVybCIsInByZXBhcmVIZWFkZXJzIiwieCIsImZldGNoRm4iLCJwYXJhbXNTZXJpYWxpemVyIiwiaXNKc29uQ29udGVudFR5cGUiLCJqc29uQ29udGVudFR5cGUiLCJqc29uUmVwbGFjZXIiLCJ0aW1lb3V0IiwiZGVmYXVsdFRpbWVvdXQiLCJyZXNwb25zZUhhbmRsZXIiLCJnbG9iYWxSZXNwb25zZUhhbmRsZXIiLCJ2YWxpZGF0ZVN0YXR1cyIsImdsb2JhbFZhbGlkYXRlU3RhdHVzIiwiYmFzZUZldGNoT3B0aW9ucyIsImNvbnNvbGUiLCJ3YXJuIiwiYXJnIiwiYXBpIiwic2lnbmFsIiwiZ2V0U3RhdGUiLCJleHRyYSIsImVuZHBvaW50IiwiZm9yY2VkIiwidHlwZSIsIm1ldGEiLCJIZWFkZXJzIiwicGFyYW1zIiwicmVzdCIsImNvbmZpZyIsImlzSnNvbmlmaWFibGUiLCJib2R5IiwidG9KU09OIiwiaGFzIiwic2V0IiwiSlNPTiIsInN0cmluZ2lmeSIsImRpdmlkZXIiLCJpbmRleE9mIiwicXVlcnkiLCJVUkxTZWFyY2hQYXJhbXMiLCJyZXF1ZXN0IiwiUmVxdWVzdCIsInJlcXVlc3RDbG9uZSIsInRpbWVkT3V0IiwidGltZW91dElkIiwic2V0VGltZW91dCIsImFib3J0IiwiZSIsImVycm9yIiwiU3RyaW5nIiwiY2xlYXJUaW1lb3V0IiwicmVzcG9uc2VDbG9uZSIsImNsb25lIiwicmVzdWx0RGF0YSIsInJlc3BvbnNlVGV4dCIsImhhbmRsZVJlc3BvbnNlRXJyb3IiLCJQcm9taXNlIiwiYWxsIiwiaGFuZGxlUmVzcG9uc2UiLCJ0aGVuIiwiciIsInRleHQiLCJvcmlnaW5hbFN0YXR1cyIsImRhdGEiLCJwYXJzZSIsIkhhbmRsZWRFcnJvciIsImNvbnN0cnVjdG9yIiwidmFsdWUiLCJkZWZhdWx0QmFja29mZiIsImF0dGVtcHQiLCJtYXhSZXRyaWVzIiwiYXR0ZW1wdHMiLCJNYXRoIiwibWluIiwicmFuZG9tIiwicmVzb2x2ZSIsInJlcyIsImZhaWwiLCJhc3NpZ24iLCJ0aHJvd0ltbWVkaWF0ZWx5IiwiRU1QVFlfT1BUSU9OUyIsInJldHJ5V2l0aEJhY2tvZmYiLCJiYXNlUXVlcnkiLCJkZWZhdWx0T3B0aW9ucyIsImV4dHJhT3B0aW9ucyIsInBvc3NpYmxlTWF4UmV0cmllcyIsImZpbHRlciIsInNsaWNlIiwiZGVmYXVsdFJldHJ5Q29uZGl0aW9uIiwiXyIsIl9fIiwib3B0aW9ucyIsImJhY2tvZmYiLCJyZXRyeUNvbmRpdGlvbiIsInJldHJ5MiIsInJlc3VsdCIsImJhc2VRdWVyeUFwaSIsInJldHJ5Iiwib25Gb2N1cyIsIm9uRm9jdXNMb3N0Iiwib25PbmxpbmUiLCJvbk9mZmxpbmUiLCJpbml0aWFsaXplZCIsInNldHVwTGlzdGVuZXJzIiwiZGlzcGF0Y2giLCJjdXN0b21IYW5kbGVyIiwiZGVmYXVsdEhhbmRsZXIiLCJoYW5kbGVGb2N1cyIsImhhbmRsZUZvY3VzTG9zdCIsImhhbmRsZU9ubGluZSIsImhhbmRsZU9mZmxpbmUiLCJoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsInVuc3Vic2NyaWJlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImlzUXVlcnlEZWZpbml0aW9uIiwiaXNNdXRhdGlvbkRlZmluaXRpb24iLCJjYWxjdWxhdGVQcm92aWRlZEJ5IiwiZGVzY3JpcHRpb24iLCJxdWVyeUFyZyIsImFzc2VydFRhZ1R5cGVzIiwiaXNGdW5jdGlvbiIsIm1hcCIsImV4cGFuZFRhZ0Rlc2NyaXB0aW9uIiwidCIsImZvcm1hdFByb2RFcnJvck1lc3NhZ2UiLCJfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSIsImlzTm90TnVsbGlzaCIsImNvdW50T2JqZWN0S2V5cyIsImNvdW50IiwiX2tleSIsImFzU2FmZVByb21pc2UiLCJwcm9taXNlIiwiZmFsbGJhY2siLCJjYXRjaCIsImZvcmNlUXVlcnlGblN5bWJvbCIsIlN5bWJvbCIsImlzVXBzZXJ0UXVlcnkiLCJidWlsZEluaXRpYXRlIiwic2VyaWFsaXplUXVlcnlBcmdzIiwicXVlcnlUaHVuayIsIm11dGF0aW9uVGh1bmsiLCJjb250ZXh0IiwicnVubmluZ1F1ZXJpZXMiLCJNYXAiLCJydW5uaW5nTXV0YXRpb25zIiwidW5zdWJzY3JpYmVRdWVyeVJlc3VsdCIsInJlbW92ZU11dGF0aW9uUmVzdWx0IiwidXBkYXRlU3Vic2NyaXB0aW9uT3B0aW9ucyIsImludGVybmFsQWN0aW9ucyIsImJ1aWxkSW5pdGlhdGVRdWVyeSIsImJ1aWxkSW5pdGlhdGVNdXRhdGlvbiIsImdldFJ1bm5pbmdRdWVyeVRodW5rIiwiZ2V0UnVubmluZ011dGF0aW9uVGh1bmsiLCJnZXRSdW5uaW5nUXVlcmllc1RodW5rIiwiZ2V0UnVubmluZ011dGF0aW9uc1RodW5rIiwiZW5kcG9pbnROYW1lIiwicXVlcnlBcmdzIiwiZW5kcG9pbnREZWZpbml0aW9uIiwiZW5kcG9pbnREZWZpbml0aW9ucyIsInF1ZXJ5Q2FjaGVLZXkiLCJfZW5kcG9pbnROYW1lIiwiZml4ZWRDYWNoZUtleU9yUmVxdWVzdElkIiwidmFsdWVzIiwibWlkZGxld2FyZVdhcm5pbmciLCJwcm9jZXNzIiwidHJpZ2dlcmVkIiwicmV0dXJuZWRWYWx1ZSIsImludGVybmFsX2dldFJUS1FTdWJzY3JpcHRpb25zIiwiRXJyb3IiLCJyZWR1Y2VyUGF0aCIsInF1ZXJ5QWN0aW9uIiwic3Vic2NyaWJlIiwiZm9yY2VSZWZldGNoIiwic3Vic2NyaXB0aW9uT3B0aW9ucyIsImZvcmNlUXVlcnlGbiIsInRodW5rIiwib3JpZ2luYWxBcmdzIiwic2VsZWN0b3IiLCJlbmRwb2ludHMiLCJzZWxlY3QiLCJ0aHVua1Jlc3VsdCIsInN0YXRlQWZ0ZXIiLCJyZXF1ZXN0SWQiLCJza2lwcGVkU3luY2hyb25vdXNseSIsInJ1bm5pbmdRdWVyeSIsInNlbGVjdEZyb21TdGF0ZSIsInN0YXRlUHJvbWlzZSIsInVud3JhcCIsInJlZmV0Y2giLCJydW5uaW5nIiwiZGVsZXRlIiwidHJhY2siLCJmaXhlZENhY2hlS2V5IiwicmV0dXJuVmFsdWVQcm9taXNlIiwicmVzZXQiLCJyZXQiLCJpc0RyYWZ0YWJsZSIsInByb2R1Y2VXaXRoUGF0Y2hlcyIsImRlZmF1bHRUcmFuc2Zvcm1SZXNwb25zZSIsImJhc2VRdWVyeVJldHVyblZhbHVlIiwiYnVpbGRUaHVua3MiLCJhc3NlcnRUYWdUeXBlIiwicGF0Y2hRdWVyeURhdGEiLCJwYXRjaGVzIiwidXBkYXRlUHJvdmlkZWQiLCJxdWVyeVJlc3VsdFBhdGNoZWQiLCJuZXdWYWx1ZSIsInByb3ZpZGVkVGFncyIsInByb3ZpZGVzVGFncyIsInVwZGF0ZVByb3ZpZGVkQnkiLCJ1cGRhdGVRdWVyeURhdGEiLCJ1cGRhdGVSZWNpcGUiLCJjdXJyZW50U3RhdGUiLCJpbnZlcnNlUGF0Y2hlcyIsInVuZG8iLCJ1dGlsIiwicHVzaCIsIm9wIiwicGF0aCIsInVwc2VydFF1ZXJ5RGF0YSIsImluaXRpYXRlIiwiZXhlY3V0ZUVuZHBvaW50IiwicmVqZWN0V2l0aFZhbHVlIiwiZnVsZmlsbFdpdGhWYWx1ZSIsInRyYW5zZm9ybVJlc3BvbnNlIiwiaXNGb3JjZWRRdWVyeSIsInF1ZXJ5Rm4iLCJhcmcyIiwid2hhdCIsImVyciIsImZ1bGZpbGxlZFRpbWVTdGFtcCIsIkRhdGUiLCJub3ciLCJiYXNlUXVlcnlNZXRhIiwiY2F0Y2hlZEVycm9yIiwidHJhbnNmb3JtRXJyb3JSZXNwb25zZSIsInN0YXRlIiwicmVxdWVzdFN0YXRlIiwicXVlcmllcyIsImJhc2VGZXRjaE9uTW91bnRPckFyZ0NoYW5nZSIsInJlZmV0Y2hPbk1vdW50T3JBcmdDaGFuZ2UiLCJmdWxmaWxsZWRWYWwiLCJyZWZldGNoVmFsIiwiTnVtYmVyIiwiZ2V0UGVuZGluZ01ldGEiLCJzdGFydGVkVGltZVN0YW1wIiwiY29uZGl0aW9uIiwicXVlcnlUaHVua0FyZ3MiLCJjdXJyZW50QXJnIiwicHJldmlvdXNBcmciLCJlbmRwb2ludFN0YXRlIiwiZGlzcGF0Y2hDb25kaXRpb25SZWplY3Rpb24iLCJoYXNUaGVGb3JjZSIsImhhc01heEFnZSIsInByZWZldGNoIiwiZm9yY2UiLCJtYXhBZ2UiLCJpZk9sZGVyVGhhbiIsImZvcmNlMiIsImxhdGVzdFN0YXRlVmFsdWUiLCJsYXN0RnVsZmlsbGVkVHMiLCJzaG91bGRSZXRyaWdnZXIiLCJtYXRjaGVzRW5kcG9pbnQiLCJhY3Rpb24iLCJidWlsZE1hdGNoVGh1bmtBY3Rpb25zIiwibWF0Y2hQZW5kaW5nIiwibWF0Y2hGdWxmaWxsZWQiLCJtYXRjaFJlamVjdGVkIiwiY2FsY3VsYXRlUHJvdmlkZWRCeVRodW5rIiwicGF5bG9hZCIsImlzRHJhZnQiLCJhcHBseVBhdGNoZXMiLCJvcmlnaW5hbCIsInVwZGF0ZVF1ZXJ5U3Vic3RhdGVJZkV4aXN0cyIsInVwZGF0ZSIsInN1YnN0YXRlIiwiZ2V0TXV0YXRpb25DYWNoZUtleSIsImlkIiwidXBkYXRlTXV0YXRpb25TdWJzdGF0ZUlmRXhpc3RzIiwiaW5pdGlhbFN0YXRlIiwiYnVpbGRTbGljZSIsImRlZmluaXRpb25zIiwiYXBpVWlkIiwiZXh0cmFjdFJlaHlkcmF0aW9uSW5mbyIsImhhc1JlaHlkcmF0aW9uSW5mbyIsInJlc2V0QXBpU3RhdGUiLCJxdWVyeVNsaWNlIiwibmFtZSIsInJlZHVjZXJzIiwicmVtb3ZlUXVlcnlSZXN1bHQiLCJyZWR1Y2VyIiwiZHJhZnQiLCJwcmVwYXJlIiwiZXh0cmFSZWR1Y2VycyIsImJ1aWxkZXIiLCJhZGRDYXNlIiwicGVuZGluZyIsInVwc2VydGluZyIsImZ1bGZpbGxlZCIsIm1lcmdlIiwibmV3RGF0YSIsImRyYWZ0U3Vic3RhdGVEYXRhIiwic3RydWN0dXJhbFNoYXJpbmciLCJyZWplY3RlZCIsImFkZE1hdGNoZXIiLCJlbnRyeSIsIm11dGF0aW9uU2xpY2UiLCJjYWNoZUtleSIsIm11dGF0aW9ucyIsImludmFsaWRhdGlvblNsaWNlIiwidGFnVHlwZVN1YnNjcmlwdGlvbnMiLCJpZFN1YnNjcmlwdGlvbnMiLCJmb3VuZEF0Iiwic3BsaWNlIiwic3Vic2NyaWJlZFF1ZXJpZXMiLCJhbHJlYWR5U3Vic2NyaWJlZCIsImluY2x1ZGVzIiwiYWN0aW9ucyIsInByb3ZpZGVkIiwiaW5jb21pbmdUYWdzIiwiY2FjaGVLZXlzIiwiY2FzZVJlZHVjZXJzIiwic3Vic2NyaXB0aW9uU2xpY2UiLCJkIiwiYSIsImludGVybmFsU3Vic2NyaXB0aW9uc1NsaWNlIiwic3Vic2NyaXB0aW9uc1VwZGF0ZWQiLCJjb25maWdTbGljZSIsIm9ubGluZSIsImZvY3VzZWQiLCJtaWRkbGV3YXJlUmVnaXN0ZXJlZCIsImNvbWJpbmVkUmVkdWNlciIsInN1YnNjcmlwdGlvbnMiLCJtYXRjaCIsInNraXBUb2tlbiIsImZvciIsImluaXRpYWxTdWJTdGF0ZSIsImRlZmF1bHRRdWVyeVN1YlN0YXRlIiwiZGVmYXVsdE11dGF0aW9uU3ViU3RhdGUiLCJidWlsZFNlbGVjdG9ycyIsImNyZWF0ZVNlbGVjdG9yMiIsInNlbGVjdFNraXBwZWRRdWVyeSIsInNlbGVjdFNraXBwZWRNdXRhdGlvbiIsImJ1aWxkUXVlcnlTZWxlY3RvciIsImJ1aWxkTXV0YXRpb25TZWxlY3RvciIsInNlbGVjdEludmFsaWRhdGVkQnkiLCJzZWxlY3RDYWNoZWRBcmdzRm9yUXVlcnkiLCJ3aXRoUmVxdWVzdEZsYWdzIiwic2VsZWN0SW50ZXJuYWxTdGF0ZSIsInJvb3RTdGF0ZSIsInNlcmlhbGl6ZWRBcmdzIiwic2VsZWN0UXVlcnlTdWJzdGF0ZSIsImZpbmFsU2VsZWN0UXVlcnlTdWJTdGF0ZSIsIm11dGF0aW9uSWQiLCJzZWxlY3RNdXRhdGlvblN1YnN0YXRlIiwiZmluYWxTZWxlY3RNdXRhdGlvblN1YnN0YXRlIiwidGFncyIsImFwaVN0YXRlIiwidG9JbnZhbGlkYXRlIiwiU2V0IiwidGFnIiwiaW52YWxpZGF0ZVN1YnNjcmlwdGlvbnMiLCJpbnZhbGlkYXRlIiwiYWRkIiwiZnJvbSIsInF1ZXJ5U3ViU3RhdGUiLCJxdWVyeU5hbWUiLCJjYWNoZSIsIldlYWtNYXAiLCJkZWZhdWx0U2VyaWFsaXplUXVlcnlBcmdzIiwic2VyaWFsaXplZCIsImNhY2hlZCIsInN0cmluZ2lmaWVkIiwic29ydCIsInJlZHVjZSIsImFjYyIsImtleTIiLCJ3ZWFrTWFwTWVtb2l6ZSIsImJ1aWxkQ3JlYXRlQXBpIiwibW9kdWxlcyIsImJhc2VDcmVhdGVBcGkiLCJvcHRpb25zV2l0aERlZmF1bHRzIiwia2VlcFVudXNlZERhdGFGb3IiLCJyZWZldGNoT25Gb2N1cyIsInJlZmV0Y2hPblJlY29ubmVjdCIsImludmFsaWRhdGlvbkJlaGF2aW9yIiwicXVlcnlBcmdzQXBpIiwiZmluYWxTZXJpYWxpemVRdWVyeUFyZ3MiLCJlbmRwb2ludFNRQSIsInF1ZXJ5QXJnc0FwaTIiLCJpbml0aWFsUmVzdWx0IiwidGFnVHlwZXMiLCJiYXRjaCIsImZuIiwiaW5qZWN0RW5kcG9pbnRzIiwiZW5oYW5jZUVuZHBvaW50cyIsImFkZFRhZ1R5cGVzIiwiZVQiLCJwYXJ0aWFsRGVmaW5pdGlvbiIsImluaXRpYWxpemVkTW9kdWxlcyIsIm0iLCJpbml0IiwiaW5qZWN0IiwiZXZhbHVhdGVkRW5kcG9pbnRzIiwibXV0YXRpb24iLCJkZWZpbml0aW9uIiwib3ZlcnJpZGVFeGlzdGluZyIsImluamVjdEVuZHBvaW50IiwiX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UyIiwiZmFrZUJhc2VRdWVyeSIsImlzT2JqZWN0RW1wdHkiLCJUSElSVFlfVFdPX0JJVF9NQVhfVElNRVJfU0VDT05EUyIsImJ1aWxkQ2FjaGVDb2xsZWN0aW9uSGFuZGxlciIsImludGVybmFsU3RhdGUiLCJhbnlTdWJzY3JpcHRpb25zUmVtYWluaW5nRm9yS2V5IiwiY3VycmVudFN1YnNjcmlwdGlvbnMiLCJjdXJyZW50UmVtb3ZhbFRpbWVvdXRzIiwiaGFuZGxlciIsIm13QXBpIiwiaW50ZXJuYWxTdGF0ZTIiLCJoYW5kbGVVbnN1YnNjcmliZSIsInF1ZXJ5U3RhdGUiLCJhcGkyIiwiSW5maW5pdHkiLCJmaW5hbEtlZXBVbnVzZWREYXRhRm9yIiwibWF4IiwiY3VycmVudFRpbWVvdXQiLCJidWlsZEludmFsaWRhdGlvbkJ5VGFnc0hhbmRsZXIiLCJyZWZldGNoUXVlcnkiLCJpc1RodW5rQWN0aW9uV2l0aFRhZ3MiLCJpc1F1ZXJ5RW5kIiwicGVuZGluZ1RhZ0ludmFsaWRhdGlvbnMiLCJpbnZhbGlkYXRlVGFncyIsImhhc1BlbmRpbmdSZXF1ZXN0cyIsIm5ld1RhZ3MiLCJ2YWx1ZXNBcnJheSIsInN1YnNjcmlwdGlvblN1YlN0YXRlIiwiYnVpbGRQb2xsaW5nSGFuZGxlciIsImN1cnJlbnRQb2xscyIsInVwZGF0ZVBvbGxpbmdJbnRlcnZhbCIsInN0YXJ0TmV4dFBvbGwiLCJjbGVhclBvbGxzIiwibG93ZXN0UG9sbGluZ0ludGVydmFsIiwic2tpcFBvbGxpbmdJZlVuZm9jdXNlZCIsImZpbmRMb3dlc3RQb2xsaW5nSW50ZXJ2YWwiLCJpc0Zpbml0ZSIsImN1cnJlbnRQb2xsIiwibmV4dFBvbGxUaW1lc3RhbXAiLCJwb2xsaW5nSW50ZXJ2YWwiLCJjbGVhbnVwUG9sbEZvcktleSIsImV4aXN0aW5nUG9sbCIsInN1YnNjcmliZXJzIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJidWlsZFdpbmRvd0V2ZW50SGFuZGxlciIsInJlZmV0Y2hWYWxpZFF1ZXJpZXMiLCJzaG91bGRSZWZldGNoIiwic29tZSIsInN1YiIsImV2ZXJ5IiwibmV2ZXJSZXNvbHZlZEVycm9yIiwiYnVpbGRDYWNoZUxpZmVjeWNsZUhhbmRsZXIiLCJpc1F1ZXJ5VGh1bmsiLCJpc011dGF0aW9uVGh1bmsiLCJpc0Z1bGZpbGxlZFRodW5rIiwibGlmZWN5Y2xlTWFwIiwic3RhdGVCZWZvcmUiLCJnZXRDYWNoZUtleSIsIm9sZFN0YXRlIiwiaGFuZGxlTmV3S2V5IiwibGlmZWN5Y2xlIiwidmFsdWVSZXNvbHZlZCIsImNhY2hlRW50cnlSZW1vdmVkIiwiY2FjaGVLZXkyIiwib25DYWNoZUVudHJ5QWRkZWQiLCJjYWNoZURhdGFMb2FkZWQiLCJyYWNlIiwiZXh0cmEyIiwibGlmZWN5Y2xlQXBpIiwiZ2V0Q2FjaGVFbnRyeSIsInVwZGF0ZUNhY2hlZERhdGEiLCJydW5uaW5nSGFuZGxlciIsImJ1aWxkUXVlcnlMaWZlY3ljbGVIYW5kbGVyIiwiaXNQZW5kaW5nVGh1bmsiLCJpc1JlamVjdGVkVGh1bmsiLCJpc0Z1bGxmaWxsZWRUaHVuayIsIm9uUXVlcnlTdGFydGVkIiwicXVlcnlGdWxmaWxsZWQiLCJyZWplY3QiLCJyZWplY3RlZFdpdGhWYWx1ZSIsImlzVW5oYW5kbGVkRXJyb3IiLCJidWlsZERldkNoZWNrSGFuZGxlciIsInByb2R1Y2VXaXRoUGF0Y2hlczIiLCJidWlsZEJhdGNoZWRBY3Rpb25zSGFuZGxlciIsInN1YnNjcmlwdGlvbnNQcmVmaXgiLCJwcmV2aW91c1N1YnNjcmlwdGlvbnMiLCJ1cGRhdGVTeW5jVGltZXIiLCJhY3R1YWxseU11dGF0ZVN1YnNjcmlwdGlvbnMiLCJtdXRhYmxlU3RhdGUiLCJtdXRhdGVkIiwiZ2V0U3Vic2NyaXB0aW9ucyIsImdldFN1YnNjcmlwdGlvbkNvdW50Iiwic3Vic2NyaXB0aW9uc0ZvclF1ZXJ5QXJnIiwiaXNSZXF1ZXN0U3Vic2NyaWJlZCIsInN1YnNjcmlwdGlvblNlbGVjdG9ycyIsImRpZE11dGF0ZSIsImFjdGlvblNob3VsZENvbnRpbnVlIiwibmV3U3Vic2NyaXB0aW9ucyIsIm5leHQiLCJpc1N1YnNjcmlwdGlvblNsaWNlQWN0aW9uIiwiaXNBZGRpdGlvbmFsU3Vic2NyaXB0aW9uQWN0aW9uIiwiYnVpbGRNaWRkbGV3YXJlIiwiaW5wdXQiLCJpc1RoaXNBcGlTbGljZUFjdGlvbiIsImhhbmRsZXJCdWlsZGVycyIsIm1pZGRsZXdhcmUiLCJpbml0aWFsaXplZDIiLCJidWlsZGVyQXJncyIsImhhbmRsZXJzIiwiYnVpbGQiLCJiYXRjaGVkQWN0aW9uc0hhbmRsZXIiLCJ3aW5kb3dFdmVudHNIYW5kbGVyIiwibXdBcGlXaXRoTmV4dCIsImludGVybmFsUHJvYmVSZXN1bHQiLCJvdmVycmlkZSIsImFzc2VydENhc3QiLCJzYWZlQXNzaWduIiwidGFyZ2V0IiwiZW5hYmxlUGF0Y2hlcyIsImNvcmVNb2R1bGVOYW1lIiwiY29yZU1vZHVsZSIsInNsaWNlQWN0aW9ucyIsIm1pZGRsZXdhcmVBY3Rpb25zIiwiYW55QXBpIiwiY3JlYXRlQXBpIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/dist/query/rtk-query.modern.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ReducerType: () => (/* binding */ ReducerType),\n/* harmony export */   SHOULD_AUTOBATCH: () => (/* binding */ SHOULD_AUTOBATCH),\n/* harmony export */   TaskAbortError: () => (/* binding */ TaskAbortError),\n/* harmony export */   Tuple: () => (/* binding */ Tuple),\n/* harmony export */   __DO_NOT_USE__ActionTypes: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.__DO_NOT_USE__ActionTypes),\n/* harmony export */   addListener: () => (/* binding */ addListener),\n/* harmony export */   applyMiddleware: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware),\n/* harmony export */   asyncThunkCreator: () => (/* binding */ asyncThunkCreator),\n/* harmony export */   autoBatchEnhancer: () => (/* binding */ autoBatchEnhancer),\n/* harmony export */   bindActionCreators: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.bindActionCreators),\n/* harmony export */   buildCreateSlice: () => (/* binding */ buildCreateSlice),\n/* harmony export */   clearAllListeners: () => (/* binding */ clearAllListeners),\n/* harmony export */   combineReducers: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers),\n/* harmony export */   combineSlices: () => (/* binding */ combineSlices),\n/* harmony export */   compose: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.compose),\n/* harmony export */   configureStore: () => (/* binding */ configureStore),\n/* harmony export */   createAction: () => (/* binding */ createAction),\n/* harmony export */   createActionCreatorInvariantMiddleware: () => (/* binding */ createActionCreatorInvariantMiddleware),\n/* harmony export */   createAsyncThunk: () => (/* binding */ createAsyncThunk),\n/* harmony export */   createDraftSafeSelector: () => (/* binding */ createDraftSafeSelector),\n/* harmony export */   createDraftSafeSelectorCreator: () => (/* binding */ createDraftSafeSelectorCreator),\n/* harmony export */   createDynamicMiddleware: () => (/* binding */ createDynamicMiddleware),\n/* harmony export */   createEntityAdapter: () => (/* binding */ createEntityAdapter),\n/* harmony export */   createImmutableStateInvariantMiddleware: () => (/* binding */ createImmutableStateInvariantMiddleware),\n/* harmony export */   createListenerMiddleware: () => (/* binding */ createListenerMiddleware),\n/* harmony export */   createNextState: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.produce),\n/* harmony export */   createReducer: () => (/* binding */ createReducer),\n/* harmony export */   createSelector: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.createSelector),\n/* harmony export */   createSelectorCreator: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.createSelectorCreator),\n/* harmony export */   createSerializableStateInvariantMiddleware: () => (/* binding */ createSerializableStateInvariantMiddleware),\n/* harmony export */   createSlice: () => (/* binding */ createSlice),\n/* harmony export */   createStore: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.createStore),\n/* harmony export */   current: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.current),\n/* harmony export */   findNonSerializableValue: () => (/* binding */ findNonSerializableValue),\n/* harmony export */   formatProdErrorMessage: () => (/* binding */ formatProdErrorMessage),\n/* harmony export */   freeze: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.freeze),\n/* harmony export */   isAction: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.isAction),\n/* harmony export */   isActionCreator: () => (/* binding */ isActionCreator),\n/* harmony export */   isAllOf: () => (/* binding */ isAllOf),\n/* harmony export */   isAnyOf: () => (/* binding */ isAnyOf),\n/* harmony export */   isAsyncThunkAction: () => (/* binding */ isAsyncThunkAction),\n/* harmony export */   isDraft: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.isDraft),\n/* harmony export */   isFluxStandardAction: () => (/* binding */ isFSA),\n/* harmony export */   isFulfilled: () => (/* binding */ isFulfilled),\n/* harmony export */   isImmutableDefault: () => (/* binding */ isImmutableDefault),\n/* harmony export */   isPending: () => (/* binding */ isPending),\n/* harmony export */   isPlain: () => (/* binding */ isPlain),\n/* harmony export */   isPlainObject: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject),\n/* harmony export */   isRejected: () => (/* binding */ isRejected),\n/* harmony export */   isRejectedWithValue: () => (/* binding */ isRejectedWithValue),\n/* harmony export */   legacy_createStore: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.legacy_createStore),\n/* harmony export */   lruMemoize: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.lruMemoize),\n/* harmony export */   miniSerializeError: () => (/* binding */ miniSerializeError),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   original: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.original),\n/* harmony export */   prepareAutoBatched: () => (/* binding */ prepareAutoBatched),\n/* harmony export */   removeListener: () => (/* binding */ removeListener),\n/* harmony export */   unwrapResult: () => (/* binding */ unwrapResult),\n/* harmony export */   weakMapMemoize: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.weakMapMemoize)\n/* harmony export */ });\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/dist/redux.mjs\");\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/immer.mjs\");\n/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! reselect */ \"(ssr)/./node_modules/reselect/dist/reselect.mjs\");\n/* harmony import */ var redux_thunk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! redux-thunk */ \"(ssr)/./node_modules/redux-thunk/dist/redux-thunk.mjs\");\n// src/index.ts\n\n\n\n// src/createDraftSafeSelector.ts\n\n\nvar createDraftSafeSelectorCreator = (...args)=>{\n    const createSelector2 = (0,reselect__WEBPACK_IMPORTED_MODULE_1__.createSelectorCreator)(...args);\n    const createDraftSafeSelector2 = Object.assign((...args2)=>{\n        const selector = createSelector2(...args2);\n        const wrappedSelector = (value, ...rest)=>selector((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(value) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.current)(value) : value, ...rest);\n        Object.assign(wrappedSelector, selector);\n        return wrappedSelector;\n    }, {\n        withTypes: ()=>createDraftSafeSelector2\n    });\n    return createDraftSafeSelector2;\n};\nvar createDraftSafeSelector = createDraftSafeSelectorCreator(reselect__WEBPACK_IMPORTED_MODULE_1__.weakMapMemoize);\n// src/configureStore.ts\n\n// src/devtoolsExtension.ts\n\nvar composeWithDevTools =  false ? 0 : function() {\n    if (arguments.length === 0) return void 0;\n    if (typeof arguments[0] === \"object\") return redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n    return redux__WEBPACK_IMPORTED_MODULE_0__.compose.apply(null, arguments);\n};\nvar devToolsEnhancer =  false ? 0 : function() {\n    return function(noop3) {\n        return noop3;\n    };\n};\n// src/getDefaultMiddleware.ts\n\n// src/createAction.ts\n\n// src/tsHelpers.ts\nvar hasMatchFunction = (v)=>{\n    return v && typeof v.match === \"function\";\n};\n// src/createAction.ts\nfunction createAction(type, prepareAction) {\n    function actionCreator(...args) {\n        if (prepareAction) {\n            let prepared = prepareAction(...args);\n            if (!prepared) {\n                throw new Error( false ? 0 : \"prepareAction did not return an object\");\n            }\n            return {\n                type,\n                payload: prepared.payload,\n                ...\"meta\" in prepared && {\n                    meta: prepared.meta\n                },\n                ...\"error\" in prepared && {\n                    error: prepared.error\n                }\n            };\n        }\n        return {\n            type,\n            payload: args[0]\n        };\n    }\n    actionCreator.toString = ()=>`${type}`;\n    actionCreator.type = type;\n    actionCreator.match = (action)=>(0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action) && action.type === type;\n    return actionCreator;\n}\nfunction isActionCreator(action) {\n    return typeof action === \"function\" && \"type\" in action && // hasMatchFunction only wants Matchers but I don't see the point in rewriting it\n    hasMatchFunction(action);\n}\nfunction isFSA(action) {\n    return (0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action) && Object.keys(action).every(isValidKey);\n}\nfunction isValidKey(key) {\n    return [\n        \"type\",\n        \"payload\",\n        \"error\",\n        \"meta\"\n    ].indexOf(key) > -1;\n}\n// src/actionCreatorInvariantMiddleware.ts\nfunction getMessage(type) {\n    const splitType = type ? `${type}`.split(\"/\") : [];\n    const actionName = splitType[splitType.length - 1] || \"actionCreator\";\n    return `Detected an action creator with type \"${type || \"unknown\"}\" being dispatched. \nMake sure you're calling the action creator before dispatching, i.e. \\`dispatch(${actionName}())\\` instead of \\`dispatch(${actionName})\\`. This is necessary even if the action has no payload.`;\n}\nfunction createActionCreatorInvariantMiddleware(options = {}) {\n    if (false) {}\n    const { isActionCreator: isActionCreator2 = isActionCreator } = options;\n    return ()=>(next)=>(action)=>{\n                if (isActionCreator2(action)) {\n                    console.warn(getMessage(action.type));\n                }\n                return next(action);\n            };\n}\n// src/utils.ts\n\nfunction getTimeMeasureUtils(maxDelay, fnName) {\n    let elapsed = 0;\n    return {\n        measureTime (fn) {\n            const started = Date.now();\n            try {\n                return fn();\n            } finally{\n                const finished = Date.now();\n                elapsed += finished - started;\n            }\n        },\n        warnIfExceeded () {\n            if (elapsed > maxDelay) {\n                console.warn(`${fnName} took ${elapsed}ms, which is more than the warning threshold of ${maxDelay}ms. \nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\nIt is disabled in production builds, so you don't need to worry about that.`);\n            }\n        }\n    };\n}\nfunction find(iterable, comparator) {\n    for (const entry of iterable){\n        if (comparator(entry)) {\n            return entry;\n        }\n    }\n    return void 0;\n}\nvar Tuple = class _Tuple extends Array {\n    constructor(...items){\n        super(...items);\n        Object.setPrototypeOf(this, _Tuple.prototype);\n    }\n    static get [Symbol.species]() {\n        return _Tuple;\n    }\n    concat(...arr) {\n        return super.concat.apply(this, arr);\n    }\n    prepend(...arr) {\n        if (arr.length === 1 && Array.isArray(arr[0])) {\n            return new _Tuple(...arr[0].concat(this));\n        }\n        return new _Tuple(...arr.concat(this));\n    }\n};\nfunction freezeDraftable(val) {\n    return (0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(val) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(val, ()=>{}) : val;\n}\nfunction emplace(map, key, handler) {\n    if (map.has(key)) {\n        let value = map.get(key);\n        if (handler.update) {\n            value = handler.update(value, key, map);\n            map.set(key, value);\n        }\n        return value;\n    }\n    if (!handler.insert) throw new Error( false ? 0 : \"No insert provided for key not already in map\");\n    const inserted = handler.insert(key, map);\n    map.set(key, inserted);\n    return inserted;\n}\n// src/immutableStateInvariantMiddleware.ts\nfunction isImmutableDefault(value) {\n    return typeof value !== \"object\" || value == null || Object.isFrozen(value);\n}\nfunction trackForMutations(isImmutable, ignorePaths, obj) {\n    const trackedProperties = trackProperties(isImmutable, ignorePaths, obj);\n    return {\n        detectMutations () {\n            return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);\n        }\n    };\n}\nfunction trackProperties(isImmutable, ignorePaths = [], obj, path = \"\", checkedObjects = /* @__PURE__ */ new Set()) {\n    const tracked = {\n        value: obj\n    };\n    if (!isImmutable(obj) && !checkedObjects.has(obj)) {\n        checkedObjects.add(obj);\n        tracked.children = {};\n        for(const key in obj){\n            const childPath = path ? path + \".\" + key : key;\n            if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {\n                continue;\n            }\n            tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);\n        }\n    }\n    return tracked;\n}\nfunction detectMutations(isImmutable, ignoredPaths = [], trackedProperty, obj, sameParentRef = false, path = \"\") {\n    const prevObj = trackedProperty ? trackedProperty.value : void 0;\n    const sameRef = prevObj === obj;\n    if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\n        return {\n            wasMutated: true,\n            path\n        };\n    }\n    if (isImmutable(prevObj) || isImmutable(obj)) {\n        return {\n            wasMutated: false\n        };\n    }\n    const keysToDetect = {};\n    for(let key in trackedProperty.children){\n        keysToDetect[key] = true;\n    }\n    for(let key in obj){\n        keysToDetect[key] = true;\n    }\n    const hasIgnoredPaths = ignoredPaths.length > 0;\n    for(let key in keysToDetect){\n        const nestedPath = path ? path + \".\" + key : key;\n        if (hasIgnoredPaths) {\n            const hasMatches = ignoredPaths.some((ignored)=>{\n                if (ignored instanceof RegExp) {\n                    return ignored.test(nestedPath);\n                }\n                return nestedPath === ignored;\n            });\n            if (hasMatches) {\n                continue;\n            }\n        }\n        const result = detectMutations(isImmutable, ignoredPaths, trackedProperty.children[key], obj[key], sameRef, nestedPath);\n        if (result.wasMutated) {\n            return result;\n        }\n    }\n    return {\n        wasMutated: false\n    };\n}\nfunction createImmutableStateInvariantMiddleware(options = {}) {\n    if (false) {} else {\n        let stringify2 = function(obj, serializer, indent, decycler) {\n            return JSON.stringify(obj, getSerialize2(serializer, decycler), indent);\n        }, getSerialize2 = function(serializer, decycler) {\n            let stack = [], keys = [];\n            if (!decycler) decycler = function(_, value) {\n                if (stack[0] === value) return \"[Circular ~]\";\n                return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\";\n            };\n            return function(key, value) {\n                if (stack.length > 0) {\n                    var thisPos = stack.indexOf(this);\n                    ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\n                    ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\n                    if (~stack.indexOf(value)) value = decycler.call(this, key, value);\n                } else stack.push(value);\n                return serializer == null ? value : serializer.call(this, key, value);\n            };\n        };\n        var stringify = stringify2, getSerialize = getSerialize2;\n        let { isImmutable = isImmutableDefault, ignoredPaths, warnAfter = 32 } = options;\n        const track = trackForMutations.bind(null, isImmutable, ignoredPaths);\n        return ({ getState })=>{\n            let state = getState();\n            let tracker = track(state);\n            let result;\n            return (next)=>(action)=>{\n                    const measureUtils = getTimeMeasureUtils(warnAfter, \"ImmutableStateInvariantMiddleware\");\n                    measureUtils.measureTime(()=>{\n                        state = getState();\n                        result = tracker.detectMutations();\n                        tracker = track(state);\n                        if (result.wasMutated) {\n                            throw new Error( false ? 0 : `A state mutation was detected between dispatches, in the path '${result.path || \"\"}'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);\n                        }\n                    });\n                    const dispatchedAction = next(action);\n                    measureUtils.measureTime(()=>{\n                        state = getState();\n                        result = tracker.detectMutations();\n                        tracker = track(state);\n                        if (result.wasMutated) {\n                            throw new Error( false ? 0 : `A state mutation was detected inside a dispatch, in the path: ${result.path || \"\"}. Take a look at the reducer(s) handling the action ${stringify2(action)}. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);\n                        }\n                    });\n                    measureUtils.warnIfExceeded();\n                    return dispatchedAction;\n                };\n        };\n    }\n}\n// src/serializableStateInvariantMiddleware.ts\n\nfunction isPlain(val) {\n    const type = typeof val;\n    return val == null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(val) || (0,redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(val);\n}\nfunction findNonSerializableValue(value, path = \"\", isSerializable = isPlain, getEntries, ignoredPaths = [], cache) {\n    let foundNestedSerializable;\n    if (!isSerializable(value)) {\n        return {\n            keyPath: path || \"<root>\",\n            value\n        };\n    }\n    if (typeof value !== \"object\" || value === null) {\n        return false;\n    }\n    if (cache?.has(value)) return false;\n    const entries = getEntries != null ? getEntries(value) : Object.entries(value);\n    const hasIgnoredPaths = ignoredPaths.length > 0;\n    for (const [key, nestedValue] of entries){\n        const nestedPath = path ? path + \".\" + key : key;\n        if (hasIgnoredPaths) {\n            const hasMatches = ignoredPaths.some((ignored)=>{\n                if (ignored instanceof RegExp) {\n                    return ignored.test(nestedPath);\n                }\n                return nestedPath === ignored;\n            });\n            if (hasMatches) {\n                continue;\n            }\n        }\n        if (!isSerializable(nestedValue)) {\n            return {\n                keyPath: nestedPath,\n                value: nestedValue\n            };\n        }\n        if (typeof nestedValue === \"object\") {\n            foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths, cache);\n            if (foundNestedSerializable) {\n                return foundNestedSerializable;\n            }\n        }\n    }\n    if (cache && isNestedFrozen(value)) cache.add(value);\n    return false;\n}\nfunction isNestedFrozen(value) {\n    if (!Object.isFrozen(value)) return false;\n    for (const nestedValue of Object.values(value)){\n        if (typeof nestedValue !== \"object\" || nestedValue === null) continue;\n        if (!isNestedFrozen(nestedValue)) return false;\n    }\n    return true;\n}\nfunction createSerializableStateInvariantMiddleware(options = {}) {\n    if (false) {} else {\n        const { isSerializable = isPlain, getEntries, ignoredActions = [], ignoredActionPaths = [\n            \"meta.arg\",\n            \"meta.baseQueryMeta\"\n        ], ignoredPaths = [], warnAfter = 32, ignoreState = false, ignoreActions = false, disableCache = false } = options;\n        const cache = !disableCache && WeakSet ? /* @__PURE__ */ new WeakSet() : void 0;\n        return (storeAPI)=>(next)=>(action)=>{\n                    if (!(0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action)) {\n                        return next(action);\n                    }\n                    const result = next(action);\n                    const measureUtils = getTimeMeasureUtils(warnAfter, \"SerializableStateInvariantMiddleware\");\n                    if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {\n                        measureUtils.measureTime(()=>{\n                            const foundActionNonSerializableValue = findNonSerializableValue(action, \"\", isSerializable, getEntries, ignoredActionPaths, cache);\n                            if (foundActionNonSerializableValue) {\n                                const { keyPath, value } = foundActionNonSerializableValue;\n                                console.error(`A non-serializable value was detected in an action, in the path: \\`${keyPath}\\`. Value:`, value, \"\\nTake a look at the logic that dispatched this action: \", action, \"\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)\", \"\\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)\");\n                            }\n                        });\n                    }\n                    if (!ignoreState) {\n                        measureUtils.measureTime(()=>{\n                            const state = storeAPI.getState();\n                            const foundStateNonSerializableValue = findNonSerializableValue(state, \"\", isSerializable, getEntries, ignoredPaths, cache);\n                            if (foundStateNonSerializableValue) {\n                                const { keyPath, value } = foundStateNonSerializableValue;\n                                console.error(`A non-serializable value was detected in the state, in the path: \\`${keyPath}\\`. Value:`, value, `\nTake a look at the reducer(s) handling this action type: ${action.type}.\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`);\n                            }\n                        });\n                        measureUtils.warnIfExceeded();\n                    }\n                    return result;\n                };\n    }\n}\n// src/getDefaultMiddleware.ts\nfunction isBoolean(x) {\n    return typeof x === \"boolean\";\n}\nvar buildGetDefaultMiddleware = ()=>function getDefaultMiddleware(options) {\n        const { thunk = true, immutableCheck = true, serializableCheck = true, actionCreatorCheck = true } = options ?? {};\n        let middlewareArray = new Tuple();\n        if (thunk) {\n            if (isBoolean(thunk)) {\n                middlewareArray.push(redux_thunk__WEBPACK_IMPORTED_MODULE_3__.thunk);\n            } else {\n                middlewareArray.push((0,redux_thunk__WEBPACK_IMPORTED_MODULE_3__.withExtraArgument)(thunk.extraArgument));\n            }\n        }\n        if (true) {\n            if (immutableCheck) {\n                let immutableOptions = {};\n                if (!isBoolean(immutableCheck)) {\n                    immutableOptions = immutableCheck;\n                }\n                middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));\n            }\n            if (serializableCheck) {\n                let serializableOptions = {};\n                if (!isBoolean(serializableCheck)) {\n                    serializableOptions = serializableCheck;\n                }\n                middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));\n            }\n            if (actionCreatorCheck) {\n                let actionCreatorOptions = {};\n                if (!isBoolean(actionCreatorCheck)) {\n                    actionCreatorOptions = actionCreatorCheck;\n                }\n                middlewareArray.unshift(createActionCreatorInvariantMiddleware(actionCreatorOptions));\n            }\n        }\n        return middlewareArray;\n    };\n// src/autoBatchEnhancer.ts\nvar SHOULD_AUTOBATCH = \"RTK_autoBatch\";\nvar prepareAutoBatched = ()=>(payload)=>({\n            payload,\n            meta: {\n                [SHOULD_AUTOBATCH]: true\n            }\n        });\nvar createQueueWithTimer = (timeout)=>{\n    return (notify)=>{\n        setTimeout(notify, timeout);\n    };\n};\nvar rAF =  false ? 0 : createQueueWithTimer(10);\nvar autoBatchEnhancer = (options = {\n    type: \"raf\"\n})=>(next)=>(...args)=>{\n            const store = next(...args);\n            let notifying = true;\n            let shouldNotifyAtEndOfTick = false;\n            let notificationQueued = false;\n            const listeners = /* @__PURE__ */ new Set();\n            const queueCallback = options.type === \"tick\" ? queueMicrotask : options.type === \"raf\" ? rAF : options.type === \"callback\" ? options.queueNotification : createQueueWithTimer(options.timeout);\n            const notifyListeners = ()=>{\n                notificationQueued = false;\n                if (shouldNotifyAtEndOfTick) {\n                    shouldNotifyAtEndOfTick = false;\n                    listeners.forEach((l)=>l());\n                }\n            };\n            return Object.assign({}, store, {\n                // Override the base `store.subscribe` method to keep original listeners\n                // from running if we're delaying notifications\n                subscribe (listener2) {\n                    const wrappedListener = ()=>notifying && listener2();\n                    const unsubscribe = store.subscribe(wrappedListener);\n                    listeners.add(listener2);\n                    return ()=>{\n                        unsubscribe();\n                        listeners.delete(listener2);\n                    };\n                },\n                // Override the base `store.dispatch` method so that we can check actions\n                // for the `shouldAutoBatch` flag and determine if batching is active\n                dispatch (action) {\n                    try {\n                        notifying = !action?.meta?.[SHOULD_AUTOBATCH];\n                        shouldNotifyAtEndOfTick = !notifying;\n                        if (shouldNotifyAtEndOfTick) {\n                            if (!notificationQueued) {\n                                notificationQueued = true;\n                                queueCallback(notifyListeners);\n                            }\n                        }\n                        return store.dispatch(action);\n                    } finally{\n                        notifying = true;\n                    }\n                }\n            });\n        };\n// src/getDefaultEnhancers.ts\nvar buildGetDefaultEnhancers = (middlewareEnhancer)=>function getDefaultEnhancers(options) {\n        const { autoBatch = true } = options ?? {};\n        let enhancerArray = new Tuple(middlewareEnhancer);\n        if (autoBatch) {\n            enhancerArray.push(autoBatchEnhancer(typeof autoBatch === \"object\" ? autoBatch : void 0));\n        }\n        return enhancerArray;\n    };\n// src/configureStore.ts\nvar IS_PRODUCTION = \"development\" === \"production\";\nfunction configureStore(options) {\n    const getDefaultMiddleware = buildGetDefaultMiddleware();\n    const { reducer = void 0, middleware, devTools = true, preloadedState = void 0, enhancers = void 0 } = options || {};\n    let rootReducer;\n    if (typeof reducer === \"function\") {\n        rootReducer = reducer;\n    } else if ((0,redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(reducer)) {\n        rootReducer = (0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)(reducer);\n    } else {\n        throw new Error( false ? 0 : \"`reducer` is a required argument, and must be a function or an object of functions that can be passed to combineReducers\");\n    }\n    if (!IS_PRODUCTION && middleware && typeof middleware !== \"function\") {\n        throw new Error( false ? 0 : \"`middleware` field must be a callback\");\n    }\n    let finalMiddleware;\n    if (typeof middleware === \"function\") {\n        finalMiddleware = middleware(getDefaultMiddleware);\n        if (!IS_PRODUCTION && !Array.isArray(finalMiddleware)) {\n            throw new Error( false ? 0 : \"when using a middleware builder function, an array of middleware must be returned\");\n        }\n    } else {\n        finalMiddleware = getDefaultMiddleware();\n    }\n    if (!IS_PRODUCTION && finalMiddleware.some((item)=>typeof item !== \"function\")) {\n        throw new Error( false ? 0 : \"each middleware provided to configureStore must be a function\");\n    }\n    let finalCompose = redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n    if (devTools) {\n        finalCompose = composeWithDevTools({\n            // Enable capture of stack traces for dispatched Redux actions\n            trace: !IS_PRODUCTION,\n            ...typeof devTools === \"object\" && devTools\n        });\n    }\n    const middlewareEnhancer = (0,redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware)(...finalMiddleware);\n    const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);\n    if (!IS_PRODUCTION && enhancers && typeof enhancers !== \"function\") {\n        throw new Error( false ? 0 : \"`enhancers` field must be a callback\");\n    }\n    let storeEnhancers = typeof enhancers === \"function\" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();\n    if (!IS_PRODUCTION && !Array.isArray(storeEnhancers)) {\n        throw new Error( false ? 0 : \"`enhancers` callback must return an array\");\n    }\n    if (!IS_PRODUCTION && storeEnhancers.some((item)=>typeof item !== \"function\")) {\n        throw new Error( false ? 0 : \"each enhancer provided to configureStore must be a function\");\n    }\n    if (!IS_PRODUCTION && finalMiddleware.length && !storeEnhancers.includes(middlewareEnhancer)) {\n        console.error(\"middlewares were provided, but middleware enhancer was not included in final enhancers - make sure to call `getDefaultEnhancers`\");\n    }\n    const composedEnhancer = finalCompose(...storeEnhancers);\n    return (0,redux__WEBPACK_IMPORTED_MODULE_0__.createStore)(rootReducer, preloadedState, composedEnhancer);\n}\n// src/createReducer.ts\n\n// src/mapBuilders.ts\nfunction executeReducerBuilderCallback(builderCallback) {\n    const actionsMap = {};\n    const actionMatchers = [];\n    let defaultCaseReducer;\n    const builder = {\n        addCase (typeOrActionCreator, reducer) {\n            if (true) {\n                if (actionMatchers.length > 0) {\n                    throw new Error( false ? 0 : \"`builder.addCase` should only be called before calling `builder.addMatcher`\");\n                }\n                if (defaultCaseReducer) {\n                    throw new Error( false ? 0 : \"`builder.addCase` should only be called before calling `builder.addDefaultCase`\");\n                }\n            }\n            const type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n            if (!type) {\n                throw new Error( false ? 0 : \"`builder.addCase` cannot be called with an empty action type\");\n            }\n            if (type in actionsMap) {\n                throw new Error( false ? 0 : `\\`builder.addCase\\` cannot be called with two reducers for the same action type '${type}'`);\n            }\n            actionsMap[type] = reducer;\n            return builder;\n        },\n        addMatcher (matcher, reducer) {\n            if (true) {\n                if (defaultCaseReducer) {\n                    throw new Error( false ? 0 : \"`builder.addMatcher` should only be called before calling `builder.addDefaultCase`\");\n                }\n            }\n            actionMatchers.push({\n                matcher,\n                reducer\n            });\n            return builder;\n        },\n        addDefaultCase (reducer) {\n            if (true) {\n                if (defaultCaseReducer) {\n                    throw new Error( false ? 0 : \"`builder.addDefaultCase` can only be called once\");\n                }\n            }\n            defaultCaseReducer = reducer;\n            return builder;\n        }\n    };\n    builderCallback(builder);\n    return [\n        actionsMap,\n        actionMatchers,\n        defaultCaseReducer\n    ];\n}\n// src/createReducer.ts\nfunction isStateFunction(x) {\n    return typeof x === \"function\";\n}\nfunction createReducer(initialState, mapOrBuilderCallback) {\n    if (true) {\n        if (typeof mapOrBuilderCallback === \"object\") {\n            throw new Error( false ? 0 : \"The object notation for `createReducer` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer\");\n        }\n    }\n    let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);\n    let getInitialState;\n    if (isStateFunction(initialState)) {\n        getInitialState = ()=>freezeDraftable(initialState());\n    } else {\n        const frozenInitialState = freezeDraftable(initialState);\n        getInitialState = ()=>frozenInitialState;\n    }\n    function reducer(state = getInitialState(), action) {\n        let caseReducers = [\n            actionsMap[action.type],\n            ...finalActionMatchers.filter(({ matcher })=>matcher(action)).map(({ reducer: reducer2 })=>reducer2)\n        ];\n        if (caseReducers.filter((cr)=>!!cr).length === 0) {\n            caseReducers = [\n                finalDefaultCaseReducer\n            ];\n        }\n        return caseReducers.reduce((previousState, caseReducer)=>{\n            if (caseReducer) {\n                if ((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(previousState)) {\n                    const draft = previousState;\n                    const result = caseReducer(draft, action);\n                    if (result === void 0) {\n                        return previousState;\n                    }\n                    return result;\n                } else if (!(0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(previousState)) {\n                    const result = caseReducer(previousState, action);\n                    if (result === void 0) {\n                        if (previousState === null) {\n                            return previousState;\n                        }\n                        throw new Error( false ? 0 : \"A case reducer on a non-draftable value must not return undefined\");\n                    }\n                    return result;\n                } else {\n                    return (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(previousState, (draft)=>{\n                        return caseReducer(draft, action);\n                    });\n                }\n            }\n            return previousState;\n        }, state);\n    }\n    reducer.getInitialState = getInitialState;\n    return reducer;\n}\n// src/nanoid.ts\nvar urlAlphabet = \"ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW\";\nvar nanoid = (size = 21)=>{\n    let id = \"\";\n    let i = size;\n    while(i--){\n        id += urlAlphabet[Math.random() * 64 | 0];\n    }\n    return id;\n};\n// src/matchers.ts\nvar matches = (matcher, action)=>{\n    if (hasMatchFunction(matcher)) {\n        return matcher.match(action);\n    } else {\n        return matcher(action);\n    }\n};\nfunction isAnyOf(...matchers) {\n    return (action)=>{\n        return matchers.some((matcher)=>matches(matcher, action));\n    };\n}\nfunction isAllOf(...matchers) {\n    return (action)=>{\n        return matchers.every((matcher)=>matches(matcher, action));\n    };\n}\nfunction hasExpectedRequestMetadata(action, validStatus) {\n    if (!action || !action.meta) return false;\n    const hasValidRequestId = typeof action.meta.requestId === \"string\";\n    const hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;\n    return hasValidRequestId && hasValidRequestStatus;\n}\nfunction isAsyncThunkArray(a) {\n    return typeof a[0] === \"function\" && \"pending\" in a[0] && \"fulfilled\" in a[0] && \"rejected\" in a[0];\n}\nfunction isPending(...asyncThunks) {\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"pending\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isPending()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const matchers = asyncThunks.map((asyncThunk)=>asyncThunk.pending);\n        const combinedMatcher = isAnyOf(...matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isRejected(...asyncThunks) {\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"rejected\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isRejected()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const matchers = asyncThunks.map((asyncThunk)=>asyncThunk.rejected);\n        const combinedMatcher = isAnyOf(...matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isRejectedWithValue(...asyncThunks) {\n    const hasFlag = (action)=>{\n        return action && action.meta && action.meta.rejectedWithValue;\n    };\n    if (asyncThunks.length === 0) {\n        return (action)=>{\n            const combinedMatcher = isAllOf(isRejected(...asyncThunks), hasFlag);\n            return combinedMatcher(action);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isRejectedWithValue()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const combinedMatcher = isAllOf(isRejected(...asyncThunks), hasFlag);\n        return combinedMatcher(action);\n    };\n}\nfunction isFulfilled(...asyncThunks) {\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"fulfilled\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isFulfilled()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const matchers = asyncThunks.map((asyncThunk)=>asyncThunk.fulfilled);\n        const combinedMatcher = isAnyOf(...matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isAsyncThunkAction(...asyncThunks) {\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"pending\",\n                \"fulfilled\",\n                \"rejected\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isAsyncThunkAction()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const matchers = [];\n        for (const asyncThunk of asyncThunks){\n            matchers.push(asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled);\n        }\n        const combinedMatcher = isAnyOf(...matchers);\n        return combinedMatcher(action);\n    };\n}\n// src/createAsyncThunk.ts\nvar commonProperties = [\n    \"name\",\n    \"message\",\n    \"stack\",\n    \"code\"\n];\nvar RejectWithValue = class {\n    constructor(payload, meta){\n        this.payload = payload;\n        this.meta = meta;\n    }\n};\nvar FulfillWithMeta = class {\n    constructor(payload, meta){\n        this.payload = payload;\n        this.meta = meta;\n    }\n};\nvar miniSerializeError = (value)=>{\n    if (typeof value === \"object\" && value !== null) {\n        const simpleError = {};\n        for (const property of commonProperties){\n            if (typeof value[property] === \"string\") {\n                simpleError[property] = value[property];\n            }\n        }\n        return simpleError;\n    }\n    return {\n        message: String(value)\n    };\n};\nvar createAsyncThunk = /* @__PURE__ */ (()=>{\n    function createAsyncThunk2(typePrefix, payloadCreator, options) {\n        const fulfilled = createAction(typePrefix + \"/fulfilled\", (payload, requestId, arg, meta)=>({\n                payload,\n                meta: {\n                    ...meta || {},\n                    arg,\n                    requestId,\n                    requestStatus: \"fulfilled\"\n                }\n            }));\n        const pending = createAction(typePrefix + \"/pending\", (requestId, arg, meta)=>({\n                payload: void 0,\n                meta: {\n                    ...meta || {},\n                    arg,\n                    requestId,\n                    requestStatus: \"pending\"\n                }\n            }));\n        const rejected = createAction(typePrefix + \"/rejected\", (error, requestId, arg, payload, meta)=>({\n                payload,\n                error: (options && options.serializeError || miniSerializeError)(error || \"Rejected\"),\n                meta: {\n                    ...meta || {},\n                    arg,\n                    requestId,\n                    rejectedWithValue: !!payload,\n                    requestStatus: \"rejected\",\n                    aborted: error?.name === \"AbortError\",\n                    condition: error?.name === \"ConditionError\"\n                }\n            }));\n        function actionCreator(arg) {\n            return (dispatch, getState, extra)=>{\n                const requestId = options?.idGenerator ? options.idGenerator(arg) : nanoid();\n                const abortController = new AbortController();\n                let abortHandler;\n                let abortReason;\n                function abort(reason) {\n                    abortReason = reason;\n                    abortController.abort();\n                }\n                const promise = async function() {\n                    let finalAction;\n                    try {\n                        let conditionResult = options?.condition?.(arg, {\n                            getState,\n                            extra\n                        });\n                        if (isThenable(conditionResult)) {\n                            conditionResult = await conditionResult;\n                        }\n                        if (conditionResult === false || abortController.signal.aborted) {\n                            throw {\n                                name: \"ConditionError\",\n                                message: \"Aborted due to condition callback returning false.\"\n                            };\n                        }\n                        const abortedPromise = new Promise((_, reject)=>{\n                            abortHandler = ()=>{\n                                reject({\n                                    name: \"AbortError\",\n                                    message: abortReason || \"Aborted\"\n                                });\n                            };\n                            abortController.signal.addEventListener(\"abort\", abortHandler);\n                        });\n                        dispatch(pending(requestId, arg, options?.getPendingMeta?.({\n                            requestId,\n                            arg\n                        }, {\n                            getState,\n                            extra\n                        })));\n                        finalAction = await Promise.race([\n                            abortedPromise,\n                            Promise.resolve(payloadCreator(arg, {\n                                dispatch,\n                                getState,\n                                extra,\n                                requestId,\n                                signal: abortController.signal,\n                                abort,\n                                rejectWithValue: (value, meta)=>{\n                                    return new RejectWithValue(value, meta);\n                                },\n                                fulfillWithValue: (value, meta)=>{\n                                    return new FulfillWithMeta(value, meta);\n                                }\n                            })).then((result)=>{\n                                if (result instanceof RejectWithValue) {\n                                    throw result;\n                                }\n                                if (result instanceof FulfillWithMeta) {\n                                    return fulfilled(result.payload, requestId, arg, result.meta);\n                                }\n                                return fulfilled(result, requestId, arg);\n                            })\n                        ]);\n                    } catch (err) {\n                        finalAction = err instanceof RejectWithValue ? rejected(null, requestId, arg, err.payload, err.meta) : rejected(err, requestId, arg);\n                    } finally{\n                        if (abortHandler) {\n                            abortController.signal.removeEventListener(\"abort\", abortHandler);\n                        }\n                    }\n                    const skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;\n                    if (!skipDispatch) {\n                        dispatch(finalAction);\n                    }\n                    return finalAction;\n                }();\n                return Object.assign(promise, {\n                    abort,\n                    requestId,\n                    arg,\n                    unwrap () {\n                        return promise.then(unwrapResult);\n                    }\n                });\n            };\n        }\n        return Object.assign(actionCreator, {\n            pending,\n            rejected,\n            fulfilled,\n            settled: isAnyOf(rejected, fulfilled),\n            typePrefix\n        });\n    }\n    createAsyncThunk2.withTypes = ()=>createAsyncThunk2;\n    return createAsyncThunk2;\n})();\nfunction unwrapResult(action) {\n    if (action.meta && action.meta.rejectedWithValue) {\n        throw action.payload;\n    }\n    if (action.error) {\n        throw action.error;\n    }\n    return action.payload;\n}\nfunction isThenable(value) {\n    return value !== null && typeof value === \"object\" && typeof value.then === \"function\";\n}\n// src/createSlice.ts\nvar asyncThunkSymbol = Symbol.for(\"rtk-slice-createasyncthunk\");\nvar asyncThunkCreator = {\n    [asyncThunkSymbol]: createAsyncThunk\n};\nvar ReducerType = /* @__PURE__ */ ((ReducerType2)=>{\n    ReducerType2[\"reducer\"] = \"reducer\";\n    ReducerType2[\"reducerWithPrepare\"] = \"reducerWithPrepare\";\n    ReducerType2[\"asyncThunk\"] = \"asyncThunk\";\n    return ReducerType2;\n})(ReducerType || {});\nfunction getType(slice, actionKey) {\n    return `${slice}/${actionKey}`;\n}\nfunction buildCreateSlice({ creators } = {}) {\n    const cAT = creators?.asyncThunk?.[asyncThunkSymbol];\n    return function createSlice2(options) {\n        const { name, reducerPath = name } = options;\n        if (!name) {\n            throw new Error( false ? 0 : \"`name` is a required option for createSlice\");\n        }\n        if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n            if (options.initialState === void 0) {\n                console.error(\"You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`\");\n            }\n        }\n        const reducers = (typeof options.reducers === \"function\" ? options.reducers(buildReducerCreators()) : options.reducers) || {};\n        const reducerNames = Object.keys(reducers);\n        const context = {\n            sliceCaseReducersByName: {},\n            sliceCaseReducersByType: {},\n            actionCreators: {},\n            sliceMatchers: []\n        };\n        const contextMethods = {\n            addCase (typeOrActionCreator, reducer2) {\n                const type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n                if (!type) {\n                    throw new Error( false ? 0 : \"`context.addCase` cannot be called with an empty action type\");\n                }\n                if (type in context.sliceCaseReducersByType) {\n                    throw new Error( false ? 0 : \"`context.addCase` cannot be called with two reducers for the same action type: \" + type);\n                }\n                context.sliceCaseReducersByType[type] = reducer2;\n                return contextMethods;\n            },\n            addMatcher (matcher, reducer2) {\n                context.sliceMatchers.push({\n                    matcher,\n                    reducer: reducer2\n                });\n                return contextMethods;\n            },\n            exposeAction (name2, actionCreator) {\n                context.actionCreators[name2] = actionCreator;\n                return contextMethods;\n            },\n            exposeCaseReducer (name2, reducer2) {\n                context.sliceCaseReducersByName[name2] = reducer2;\n                return contextMethods;\n            }\n        };\n        reducerNames.forEach((reducerName)=>{\n            const reducerDefinition = reducers[reducerName];\n            const reducerDetails = {\n                reducerName,\n                type: getType(name, reducerName),\n                createNotation: typeof options.reducers === \"function\"\n            };\n            if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {\n                handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);\n            } else {\n                handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);\n            }\n        });\n        function buildReducer() {\n            if (true) {\n                if (typeof options.extraReducers === \"object\") {\n                    throw new Error( false ? 0 : \"The object notation for `createSlice.extraReducers` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice\");\n                }\n            }\n            const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options.extraReducers === \"function\" ? executeReducerBuilderCallback(options.extraReducers) : [\n                options.extraReducers\n            ];\n            const finalCaseReducers = {\n                ...extraReducers,\n                ...context.sliceCaseReducersByType\n            };\n            return createReducer(options.initialState, (builder)=>{\n                for(let key in finalCaseReducers){\n                    builder.addCase(key, finalCaseReducers[key]);\n                }\n                for (let sM of context.sliceMatchers){\n                    builder.addMatcher(sM.matcher, sM.reducer);\n                }\n                for (let m of actionMatchers){\n                    builder.addMatcher(m.matcher, m.reducer);\n                }\n                if (defaultCaseReducer) {\n                    builder.addDefaultCase(defaultCaseReducer);\n                }\n            });\n        }\n        const selectSelf = (state)=>state;\n        const injectedSelectorCache = /* @__PURE__ */ new Map();\n        let _reducer;\n        function reducer(state, action) {\n            if (!_reducer) _reducer = buildReducer();\n            return _reducer(state, action);\n        }\n        function getInitialState() {\n            if (!_reducer) _reducer = buildReducer();\n            return _reducer.getInitialState();\n        }\n        function makeSelectorProps(reducerPath2, injected = false) {\n            function selectSlice(state) {\n                let sliceState = state[reducerPath2];\n                if (typeof sliceState === \"undefined\") {\n                    if (injected) {\n                        sliceState = getInitialState();\n                    } else if (true) {\n                        throw new Error( false ? 0 : \"selectSlice returned undefined for an uninjected slice reducer\");\n                    }\n                }\n                return sliceState;\n            }\n            function getSelectors(selectState = selectSelf) {\n                const selectorCache = emplace(injectedSelectorCache, injected, {\n                    insert: ()=>/* @__PURE__ */ new WeakMap()\n                });\n                return emplace(selectorCache, selectState, {\n                    insert: ()=>{\n                        const map = {};\n                        for (const [name2, selector] of Object.entries(options.selectors ?? {})){\n                            map[name2] = wrapSelector(selector, selectState, getInitialState, injected);\n                        }\n                        return map;\n                    }\n                });\n            }\n            return {\n                reducerPath: reducerPath2,\n                getSelectors,\n                get selectors () {\n                    return getSelectors(selectSlice);\n                },\n                selectSlice\n            };\n        }\n        const slice = {\n            name,\n            reducer,\n            actions: context.actionCreators,\n            caseReducers: context.sliceCaseReducersByName,\n            getInitialState,\n            ...makeSelectorProps(reducerPath),\n            injectInto (injectable, { reducerPath: pathOpt, ...config } = {}) {\n                const newReducerPath = pathOpt ?? reducerPath;\n                injectable.inject({\n                    reducerPath: newReducerPath,\n                    reducer\n                }, config);\n                return {\n                    ...slice,\n                    ...makeSelectorProps(newReducerPath, true)\n                };\n            }\n        };\n        return slice;\n    };\n}\nfunction wrapSelector(selector, selectState, getInitialState, injected) {\n    function wrapper(rootState, ...args) {\n        let sliceState = selectState(rootState);\n        if (typeof sliceState === \"undefined\") {\n            if (injected) {\n                sliceState = getInitialState();\n            } else if (true) {\n                throw new Error( false ? 0 : \"selectState returned undefined for an uninjected slice reducer\");\n            }\n        }\n        return selector(sliceState, ...args);\n    }\n    wrapper.unwrapped = selector;\n    return wrapper;\n}\nvar createSlice = buildCreateSlice();\nfunction buildReducerCreators() {\n    function asyncThunk(payloadCreator, config) {\n        return {\n            _reducerDefinitionType: \"asyncThunk\" /* asyncThunk */ ,\n            payloadCreator,\n            ...config\n        };\n    }\n    asyncThunk.withTypes = ()=>asyncThunk;\n    return {\n        reducer (caseReducer) {\n            return Object.assign({\n                // hack so the wrapping function has the same name as the original\n                // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original\n                [caseReducer.name] (...args) {\n                    return caseReducer(...args);\n                }\n            }[caseReducer.name], {\n                _reducerDefinitionType: \"reducer\" /* reducer */ \n            });\n        },\n        preparedReducer (prepare, reducer) {\n            return {\n                _reducerDefinitionType: \"reducerWithPrepare\" /* reducerWithPrepare */ ,\n                prepare,\n                reducer\n            };\n        },\n        asyncThunk\n    };\n}\nfunction handleNormalReducerDefinition({ type, reducerName, createNotation }, maybeReducerWithPrepare, context) {\n    let caseReducer;\n    let prepareCallback;\n    if (\"reducer\" in maybeReducerWithPrepare) {\n        if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {\n            throw new Error( false ? 0 : \"Please use the `create.preparedReducer` notation for prepared action creators with the `create` notation.\");\n        }\n        caseReducer = maybeReducerWithPrepare.reducer;\n        prepareCallback = maybeReducerWithPrepare.prepare;\n    } else {\n        caseReducer = maybeReducerWithPrepare;\n    }\n    context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));\n}\nfunction isAsyncThunkSliceReducerDefinition(reducerDefinition) {\n    return reducerDefinition._reducerDefinitionType === \"asyncThunk\" /* asyncThunk */ ;\n}\nfunction isCaseReducerWithPrepareDefinition(reducerDefinition) {\n    return reducerDefinition._reducerDefinitionType === \"reducerWithPrepare\" /* reducerWithPrepare */ ;\n}\nfunction handleThunkCaseReducerDefinition({ type, reducerName }, reducerDefinition, context, cAT) {\n    if (!cAT) {\n        throw new Error( false ? 0 : \"Cannot use `create.asyncThunk` in the built-in `createSlice`. Use `buildCreateSlice({ creators: { asyncThunk: asyncThunkCreator } })` to create a customised version of `createSlice`.\");\n    }\n    const { payloadCreator, fulfilled, pending, rejected, settled, options } = reducerDefinition;\n    const thunk = cAT(type, payloadCreator, options);\n    context.exposeAction(reducerName, thunk);\n    if (fulfilled) {\n        context.addCase(thunk.fulfilled, fulfilled);\n    }\n    if (pending) {\n        context.addCase(thunk.pending, pending);\n    }\n    if (rejected) {\n        context.addCase(thunk.rejected, rejected);\n    }\n    if (settled) {\n        context.addMatcher(thunk.settled, settled);\n    }\n    context.exposeCaseReducer(reducerName, {\n        fulfilled: fulfilled || noop,\n        pending: pending || noop,\n        rejected: rejected || noop,\n        settled: settled || noop\n    });\n}\nfunction noop() {}\n// src/entities/entity_state.ts\nfunction getInitialEntityState() {\n    return {\n        ids: [],\n        entities: {}\n    };\n}\nfunction createInitialStateFactory() {\n    function getInitialState(additionalState = {}) {\n        return Object.assign(getInitialEntityState(), additionalState);\n    }\n    return {\n        getInitialState\n    };\n}\n// src/entities/state_selectors.ts\nfunction createSelectorsFactory() {\n    function getSelectors(selectState, options = {}) {\n        const { createSelector: createSelector2 = createDraftSafeSelector } = options;\n        const selectIds = (state)=>state.ids;\n        const selectEntities = (state)=>state.entities;\n        const selectAll = createSelector2(selectIds, selectEntities, (ids, entities)=>ids.map((id)=>entities[id]));\n        const selectId = (_, id)=>id;\n        const selectById = (entities, id)=>entities[id];\n        const selectTotal = createSelector2(selectIds, (ids)=>ids.length);\n        if (!selectState) {\n            return {\n                selectIds,\n                selectEntities,\n                selectAll,\n                selectTotal,\n                selectById: createSelector2(selectEntities, selectId, selectById)\n            };\n        }\n        const selectGlobalizedEntities = createSelector2(selectState, selectEntities);\n        return {\n            selectIds: createSelector2(selectState, selectIds),\n            selectEntities: selectGlobalizedEntities,\n            selectAll: createSelector2(selectState, selectAll),\n            selectTotal: createSelector2(selectState, selectTotal),\n            selectById: createSelector2(selectGlobalizedEntities, selectId, selectById)\n        };\n    }\n    return {\n        getSelectors\n    };\n}\n// src/entities/state_adapter.ts\n\nvar isDraftTyped = immer__WEBPACK_IMPORTED_MODULE_2__.isDraft;\nfunction createSingleArgumentStateOperator(mutator) {\n    const operator = createStateOperator((_, state)=>mutator(state));\n    return function operation(state) {\n        return operator(state, void 0);\n    };\n}\nfunction createStateOperator(mutator) {\n    return function operation(state, arg) {\n        function isPayloadActionArgument(arg2) {\n            return isFSA(arg2);\n        }\n        const runMutator = (draft)=>{\n            if (isPayloadActionArgument(arg)) {\n                mutator(arg.payload, draft);\n            } else {\n                mutator(arg, draft);\n            }\n        };\n        if (isDraftTyped(state)) {\n            runMutator(state);\n            return state;\n        }\n        return (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(state, runMutator);\n    };\n}\n// src/entities/utils.ts\nfunction selectIdValue(entity, selectId) {\n    const key = selectId(entity);\n    if ( true && key === void 0) {\n        console.warn(\"The entity passed to the `selectId` implementation returned undefined.\", \"You should probably provide your own `selectId` implementation.\", \"The entity that was passed:\", entity, \"The `selectId` implementation:\", selectId.toString());\n    }\n    return key;\n}\nfunction ensureEntitiesArray(entities) {\n    if (!Array.isArray(entities)) {\n        entities = Object.values(entities);\n    }\n    return entities;\n}\nfunction splitAddedUpdatedEntities(newEntities, selectId, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    const added = [];\n    const updated = [];\n    for (const entity of newEntities){\n        const id = selectIdValue(entity, selectId);\n        if (id in state.entities) {\n            updated.push({\n                id,\n                changes: entity\n            });\n        } else {\n            added.push(entity);\n        }\n    }\n    return [\n        added,\n        updated\n    ];\n}\n// src/entities/unsorted_state_adapter.ts\nfunction createUnsortedStateAdapter(selectId) {\n    function addOneMutably(entity, state) {\n        const key = selectIdValue(entity, selectId);\n        if (key in state.entities) {\n            return;\n        }\n        state.ids.push(key);\n        state.entities[key] = entity;\n    }\n    function addManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        for (const entity of newEntities){\n            addOneMutably(entity, state);\n        }\n    }\n    function setOneMutably(entity, state) {\n        const key = selectIdValue(entity, selectId);\n        if (!(key in state.entities)) {\n            state.ids.push(key);\n        }\n        state.entities[key] = entity;\n    }\n    function setManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        for (const entity of newEntities){\n            setOneMutably(entity, state);\n        }\n    }\n    function setAllMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        state.ids = [];\n        state.entities = {};\n        addManyMutably(newEntities, state);\n    }\n    function removeOneMutably(key, state) {\n        return removeManyMutably([\n            key\n        ], state);\n    }\n    function removeManyMutably(keys, state) {\n        let didMutate = false;\n        keys.forEach((key)=>{\n            if (key in state.entities) {\n                delete state.entities[key];\n                didMutate = true;\n            }\n        });\n        if (didMutate) {\n            state.ids = state.ids.filter((id)=>id in state.entities);\n        }\n    }\n    function removeAllMutably(state) {\n        Object.assign(state, {\n            ids: [],\n            entities: {}\n        });\n    }\n    function takeNewKey(keys, update, state) {\n        const original3 = state.entities[update.id];\n        if (original3 === void 0) {\n            return false;\n        }\n        const updated = Object.assign({}, original3, update.changes);\n        const newKey = selectIdValue(updated, selectId);\n        const hasNewKey = newKey !== update.id;\n        if (hasNewKey) {\n            keys[update.id] = newKey;\n            delete state.entities[update.id];\n        }\n        state.entities[newKey] = updated;\n        return hasNewKey;\n    }\n    function updateOneMutably(update, state) {\n        return updateManyMutably([\n            update\n        ], state);\n    }\n    function updateManyMutably(updates, state) {\n        const newKeys = {};\n        const updatesPerEntity = {};\n        updates.forEach((update)=>{\n            if (update.id in state.entities) {\n                updatesPerEntity[update.id] = {\n                    id: update.id,\n                    // Spreads ignore falsy values, so this works even if there isn't\n                    // an existing update already at this key\n                    changes: {\n                        ...updatesPerEntity[update.id] ? updatesPerEntity[update.id].changes : null,\n                        ...update.changes\n                    }\n                };\n            }\n        });\n        updates = Object.values(updatesPerEntity);\n        const didMutateEntities = updates.length > 0;\n        if (didMutateEntities) {\n            const didMutateIds = updates.filter((update)=>takeNewKey(newKeys, update, state)).length > 0;\n            if (didMutateIds) {\n                state.ids = Object.values(state.entities).map((e)=>selectIdValue(e, selectId));\n            }\n        }\n    }\n    function upsertOneMutably(entity, state) {\n        return upsertManyMutably([\n            entity\n        ], state);\n    }\n    function upsertManyMutably(newEntities, state) {\n        const [added, updated] = splitAddedUpdatedEntities(newEntities, selectId, state);\n        updateManyMutably(updated, state);\n        addManyMutably(added, state);\n    }\n    return {\n        removeAll: createSingleArgumentStateOperator(removeAllMutably),\n        addOne: createStateOperator(addOneMutably),\n        addMany: createStateOperator(addManyMutably),\n        setOne: createStateOperator(setOneMutably),\n        setMany: createStateOperator(setManyMutably),\n        setAll: createStateOperator(setAllMutably),\n        updateOne: createStateOperator(updateOneMutably),\n        updateMany: createStateOperator(updateManyMutably),\n        upsertOne: createStateOperator(upsertOneMutably),\n        upsertMany: createStateOperator(upsertManyMutably),\n        removeOne: createStateOperator(removeOneMutably),\n        removeMany: createStateOperator(removeManyMutably)\n    };\n}\n// src/entities/sorted_state_adapter.ts\nfunction createSortedStateAdapter(selectId, sort) {\n    const { removeOne, removeMany, removeAll } = createUnsortedStateAdapter(selectId);\n    function addOneMutably(entity, state) {\n        return addManyMutably([\n            entity\n        ], state);\n    }\n    function addManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        const models = newEntities.filter((model)=>!(selectIdValue(model, selectId) in state.entities));\n        if (models.length !== 0) {\n            merge(models, state);\n        }\n    }\n    function setOneMutably(entity, state) {\n        return setManyMutably([\n            entity\n        ], state);\n    }\n    function setManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        if (newEntities.length !== 0) {\n            merge(newEntities, state);\n        }\n    }\n    function setAllMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        state.entities = {};\n        state.ids = [];\n        addManyMutably(newEntities, state);\n    }\n    function updateOneMutably(update, state) {\n        return updateManyMutably([\n            update\n        ], state);\n    }\n    function updateManyMutably(updates, state) {\n        let appliedUpdates = false;\n        for (let update of updates){\n            const entity = state.entities[update.id];\n            if (!entity) {\n                continue;\n            }\n            appliedUpdates = true;\n            Object.assign(entity, update.changes);\n            const newId = selectId(entity);\n            if (update.id !== newId) {\n                delete state.entities[update.id];\n                state.entities[newId] = entity;\n            }\n        }\n        if (appliedUpdates) {\n            resortEntities(state);\n        }\n    }\n    function upsertOneMutably(entity, state) {\n        return upsertManyMutably([\n            entity\n        ], state);\n    }\n    function upsertManyMutably(newEntities, state) {\n        const [added, updated] = splitAddedUpdatedEntities(newEntities, selectId, state);\n        updateManyMutably(updated, state);\n        addManyMutably(added, state);\n    }\n    function areArraysEqual(a, b) {\n        if (a.length !== b.length) {\n            return false;\n        }\n        for(let i = 0; i < a.length && i < b.length; i++){\n            if (a[i] === b[i]) {\n                continue;\n            }\n            return false;\n        }\n        return true;\n    }\n    function merge(models, state) {\n        models.forEach((model)=>{\n            state.entities[selectId(model)] = model;\n        });\n        resortEntities(state);\n    }\n    function resortEntities(state) {\n        const allEntities = Object.values(state.entities);\n        allEntities.sort(sort);\n        const newSortedIds = allEntities.map(selectId);\n        const { ids } = state;\n        if (!areArraysEqual(ids, newSortedIds)) {\n            state.ids = newSortedIds;\n        }\n    }\n    return {\n        removeOne,\n        removeMany,\n        removeAll,\n        addOne: createStateOperator(addOneMutably),\n        updateOne: createStateOperator(updateOneMutably),\n        upsertOne: createStateOperator(upsertOneMutably),\n        setOne: createStateOperator(setOneMutably),\n        setMany: createStateOperator(setManyMutably),\n        setAll: createStateOperator(setAllMutably),\n        addMany: createStateOperator(addManyMutably),\n        updateMany: createStateOperator(updateManyMutably),\n        upsertMany: createStateOperator(upsertManyMutably)\n    };\n}\n// src/entities/create_adapter.ts\nfunction createEntityAdapter(options = {}) {\n    const { selectId, sortComparer } = {\n        sortComparer: false,\n        selectId: (instance)=>instance.id,\n        ...options\n    };\n    const stateFactory = createInitialStateFactory();\n    const selectorsFactory = createSelectorsFactory();\n    const stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);\n    return {\n        selectId,\n        sortComparer,\n        ...stateFactory,\n        ...selectorsFactory,\n        ...stateAdapter\n    };\n}\n// src/listenerMiddleware/index.ts\n\n// src/listenerMiddleware/exceptions.ts\nvar task = \"task\";\nvar listener = \"listener\";\nvar completed = \"completed\";\nvar cancelled = \"cancelled\";\nvar taskCancelled = `task-${cancelled}`;\nvar taskCompleted = `task-${completed}`;\nvar listenerCancelled = `${listener}-${cancelled}`;\nvar listenerCompleted = `${listener}-${completed}`;\nvar TaskAbortError = class {\n    constructor(code){\n        this.name = \"TaskAbortError\";\n        this.code = code;\n        this.message = `${task} ${cancelled} (reason: ${code})`;\n    }\n};\n// src/listenerMiddleware/utils.ts\nvar assertFunction = (func, expected)=>{\n    if (typeof func !== \"function\") {\n        throw new Error( false ? 0 : `${expected} is not a function`);\n    }\n};\nvar noop2 = ()=>{};\nvar catchRejection = (promise, onError = noop2)=>{\n    promise.catch(onError);\n    return promise;\n};\nvar addAbortSignalListener = (abortSignal, callback)=>{\n    abortSignal.addEventListener(\"abort\", callback, {\n        once: true\n    });\n    return ()=>abortSignal.removeEventListener(\"abort\", callback);\n};\nvar abortControllerWithReason = (abortController, reason)=>{\n    const signal = abortController.signal;\n    if (signal.aborted) {\n        return;\n    }\n    if (!(\"reason\" in signal)) {\n        Object.defineProperty(signal, \"reason\", {\n            enumerable: true,\n            value: reason,\n            configurable: true,\n            writable: true\n        });\n    }\n    ;\n    abortController.abort(reason);\n};\n// src/listenerMiddleware/task.ts\nvar validateActive = (signal)=>{\n    if (signal.aborted) {\n        const { reason } = signal;\n        throw new TaskAbortError(reason);\n    }\n};\nfunction raceWithSignal(signal, promise) {\n    let cleanup = noop2;\n    return new Promise((resolve, reject)=>{\n        const notifyRejection = ()=>reject(new TaskAbortError(signal.reason));\n        if (signal.aborted) {\n            notifyRejection();\n            return;\n        }\n        cleanup = addAbortSignalListener(signal, notifyRejection);\n        promise.finally(()=>cleanup()).then(resolve, reject);\n    }).finally(()=>{\n        cleanup = noop2;\n    });\n}\nvar runTask = async (task2, cleanUp)=>{\n    try {\n        await Promise.resolve();\n        const value = await task2();\n        return {\n            status: \"ok\",\n            value\n        };\n    } catch (error) {\n        return {\n            status: error instanceof TaskAbortError ? \"cancelled\" : \"rejected\",\n            error\n        };\n    } finally{\n        cleanUp?.();\n    }\n};\nvar createPause = (signal)=>{\n    return (promise)=>{\n        return catchRejection(raceWithSignal(signal, promise).then((output)=>{\n            validateActive(signal);\n            return output;\n        }));\n    };\n};\nvar createDelay = (signal)=>{\n    const pause = createPause(signal);\n    return (timeoutMs)=>{\n        return pause(new Promise((resolve)=>setTimeout(resolve, timeoutMs)));\n    };\n};\n// src/listenerMiddleware/index.ts\nvar { assign } = Object;\nvar INTERNAL_NIL_TOKEN = {};\nvar alm = \"listenerMiddleware\";\nvar createFork = (parentAbortSignal, parentBlockingPromises)=>{\n    const linkControllers = (controller)=>addAbortSignalListener(parentAbortSignal, ()=>abortControllerWithReason(controller, parentAbortSignal.reason));\n    return (taskExecutor, opts)=>{\n        assertFunction(taskExecutor, \"taskExecutor\");\n        const childAbortController = new AbortController();\n        linkControllers(childAbortController);\n        const result = runTask(async ()=>{\n            validateActive(parentAbortSignal);\n            validateActive(childAbortController.signal);\n            const result2 = await taskExecutor({\n                pause: createPause(childAbortController.signal),\n                delay: createDelay(childAbortController.signal),\n                signal: childAbortController.signal\n            });\n            validateActive(childAbortController.signal);\n            return result2;\n        }, ()=>abortControllerWithReason(childAbortController, taskCompleted));\n        if (opts?.autoJoin) {\n            parentBlockingPromises.push(result.catch(noop2));\n        }\n        return {\n            result: createPause(parentAbortSignal)(result),\n            cancel () {\n                abortControllerWithReason(childAbortController, taskCancelled);\n            }\n        };\n    };\n};\nvar createTakePattern = (startListening, signal)=>{\n    const take = async (predicate, timeout)=>{\n        validateActive(signal);\n        let unsubscribe = ()=>{};\n        const tuplePromise = new Promise((resolve, reject)=>{\n            let stopListening = startListening({\n                predicate,\n                effect: (action, listenerApi)=>{\n                    listenerApi.unsubscribe();\n                    resolve([\n                        action,\n                        listenerApi.getState(),\n                        listenerApi.getOriginalState()\n                    ]);\n                }\n            });\n            unsubscribe = ()=>{\n                stopListening();\n                reject();\n            };\n        });\n        const promises = [\n            tuplePromise\n        ];\n        if (timeout != null) {\n            promises.push(new Promise((resolve)=>setTimeout(resolve, timeout, null)));\n        }\n        try {\n            const output = await raceWithSignal(signal, Promise.race(promises));\n            validateActive(signal);\n            return output;\n        } finally{\n            unsubscribe();\n        }\n    };\n    return (predicate, timeout)=>catchRejection(take(predicate, timeout));\n};\nvar getListenerEntryPropsFrom = (options)=>{\n    let { type, actionCreator, matcher, predicate, effect } = options;\n    if (type) {\n        predicate = createAction(type).match;\n    } else if (actionCreator) {\n        type = actionCreator.type;\n        predicate = actionCreator.match;\n    } else if (matcher) {\n        predicate = matcher;\n    } else if (predicate) {} else {\n        throw new Error( false ? 0 : \"Creating or removing a listener requires one of the known fields for matching an action\");\n    }\n    assertFunction(effect, \"options.listener\");\n    return {\n        predicate,\n        type,\n        effect\n    };\n};\nvar createListenerEntry = Object.assign((options)=>{\n    const { type, predicate, effect } = getListenerEntryPropsFrom(options);\n    const id = nanoid();\n    const entry = {\n        id,\n        effect,\n        type,\n        predicate,\n        pending: /* @__PURE__ */ new Set(),\n        unsubscribe: ()=>{\n            throw new Error( false ? 0 : \"Unsubscribe not initialized\");\n        }\n    };\n    return entry;\n}, {\n    withTypes: ()=>createListenerEntry\n});\nvar cancelActiveListeners = (entry)=>{\n    entry.pending.forEach((controller)=>{\n        abortControllerWithReason(controller, listenerCancelled);\n    });\n};\nvar createClearListenerMiddleware = (listenerMap)=>{\n    return ()=>{\n        listenerMap.forEach(cancelActiveListeners);\n        listenerMap.clear();\n    };\n};\nvar safelyNotifyError = (errorHandler, errorToNotify, errorInfo)=>{\n    try {\n        errorHandler(errorToNotify, errorInfo);\n    } catch (errorHandlerError) {\n        setTimeout(()=>{\n            throw errorHandlerError;\n        }, 0);\n    }\n};\nvar addListener = Object.assign(createAction(`${alm}/add`), {\n    withTypes: ()=>addListener\n});\nvar clearAllListeners = createAction(`${alm}/removeAll`);\nvar removeListener = Object.assign(createAction(`${alm}/remove`), {\n    withTypes: ()=>removeListener\n});\nvar defaultErrorHandler = (...args)=>{\n    console.error(`${alm}/error`, ...args);\n};\nvar createListenerMiddleware = (middlewareOptions = {})=>{\n    const listenerMap = /* @__PURE__ */ new Map();\n    const { extra, onError = defaultErrorHandler } = middlewareOptions;\n    assertFunction(onError, \"onError\");\n    const insertEntry = (entry)=>{\n        entry.unsubscribe = ()=>listenerMap.delete(entry.id);\n        listenerMap.set(entry.id, entry);\n        return (cancelOptions)=>{\n            entry.unsubscribe();\n            if (cancelOptions?.cancelActive) {\n                cancelActiveListeners(entry);\n            }\n        };\n    };\n    const startListening = (options)=>{\n        let entry = find(Array.from(listenerMap.values()), (existingEntry)=>existingEntry.effect === options.effect);\n        if (!entry) {\n            entry = createListenerEntry(options);\n        }\n        return insertEntry(entry);\n    };\n    Object.assign(startListening, {\n        withTypes: ()=>startListening\n    });\n    const stopListening = (options)=>{\n        const { type, effect, predicate } = getListenerEntryPropsFrom(options);\n        const entry = find(Array.from(listenerMap.values()), (entry2)=>{\n            const matchPredicateOrType = typeof type === \"string\" ? entry2.type === type : entry2.predicate === predicate;\n            return matchPredicateOrType && entry2.effect === effect;\n        });\n        if (entry) {\n            entry.unsubscribe();\n            if (options.cancelActive) {\n                cancelActiveListeners(entry);\n            }\n        }\n        return !!entry;\n    };\n    Object.assign(stopListening, {\n        withTypes: ()=>stopListening\n    });\n    const notifyListener = async (entry, action, api, getOriginalState)=>{\n        const internalTaskController = new AbortController();\n        const take = createTakePattern(startListening, internalTaskController.signal);\n        const autoJoinPromises = [];\n        try {\n            entry.pending.add(internalTaskController);\n            await Promise.resolve(entry.effect(action, // Use assign() rather than ... to avoid extra helper functions added to bundle\n            assign({}, api, {\n                getOriginalState,\n                condition: (predicate, timeout)=>take(predicate, timeout).then(Boolean),\n                take,\n                delay: createDelay(internalTaskController.signal),\n                pause: createPause(internalTaskController.signal),\n                extra,\n                signal: internalTaskController.signal,\n                fork: createFork(internalTaskController.signal, autoJoinPromises),\n                unsubscribe: entry.unsubscribe,\n                subscribe: ()=>{\n                    listenerMap.set(entry.id, entry);\n                },\n                cancelActiveListeners: ()=>{\n                    entry.pending.forEach((controller, _, set)=>{\n                        if (controller !== internalTaskController) {\n                            abortControllerWithReason(controller, listenerCancelled);\n                            set.delete(controller);\n                        }\n                    });\n                },\n                cancel: ()=>{\n                    abortControllerWithReason(internalTaskController, listenerCancelled);\n                    entry.pending.delete(internalTaskController);\n                },\n                throwIfCancelled: ()=>{\n                    validateActive(internalTaskController.signal);\n                }\n            })));\n        } catch (listenerError) {\n            if (!(listenerError instanceof TaskAbortError)) {\n                safelyNotifyError(onError, listenerError, {\n                    raisedBy: \"effect\"\n                });\n            }\n        } finally{\n            await Promise.all(autoJoinPromises);\n            abortControllerWithReason(internalTaskController, listenerCompleted);\n            entry.pending.delete(internalTaskController);\n        }\n    };\n    const clearListenerMiddleware = createClearListenerMiddleware(listenerMap);\n    const middleware = (api)=>(next)=>(action)=>{\n                if (!(0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action)) {\n                    return next(action);\n                }\n                if (addListener.match(action)) {\n                    return startListening(action.payload);\n                }\n                if (clearAllListeners.match(action)) {\n                    clearListenerMiddleware();\n                    return;\n                }\n                if (removeListener.match(action)) {\n                    return stopListening(action.payload);\n                }\n                let originalState = api.getState();\n                const getOriginalState = ()=>{\n                    if (originalState === INTERNAL_NIL_TOKEN) {\n                        throw new Error( false ? 0 : `${alm}: getOriginalState can only be called synchronously`);\n                    }\n                    return originalState;\n                };\n                let result;\n                try {\n                    result = next(action);\n                    if (listenerMap.size > 0) {\n                        const currentState = api.getState();\n                        const listenerEntries = Array.from(listenerMap.values());\n                        for (const entry of listenerEntries){\n                            let runListener = false;\n                            try {\n                                runListener = entry.predicate(action, currentState, originalState);\n                            } catch (predicateError) {\n                                runListener = false;\n                                safelyNotifyError(onError, predicateError, {\n                                    raisedBy: \"predicate\"\n                                });\n                            }\n                            if (!runListener) {\n                                continue;\n                            }\n                            notifyListener(entry, action, api, getOriginalState);\n                        }\n                    }\n                } finally{\n                    originalState = INTERNAL_NIL_TOKEN;\n                }\n                return result;\n            };\n    return {\n        middleware,\n        startListening,\n        stopListening,\n        clearListeners: clearListenerMiddleware\n    };\n};\n// src/dynamicMiddleware/index.ts\n\nvar createMiddlewareEntry = (middleware)=>({\n        id: nanoid(),\n        middleware,\n        applied: /* @__PURE__ */ new Map()\n    });\nvar matchInstance = (instanceId)=>(action)=>action?.meta?.instanceId === instanceId;\nvar createDynamicMiddleware = ()=>{\n    const instanceId = nanoid();\n    const middlewareMap = /* @__PURE__ */ new Map();\n    const withMiddleware = Object.assign(createAction(\"dynamicMiddleware/add\", (...middlewares)=>({\n            payload: middlewares,\n            meta: {\n                instanceId\n            }\n        })), {\n        withTypes: ()=>withMiddleware\n    });\n    const addMiddleware = Object.assign(function addMiddleware2(...middlewares) {\n        middlewares.forEach((middleware2)=>{\n            let entry = find(Array.from(middlewareMap.values()), (entry2)=>entry2.middleware === middleware2);\n            if (!entry) {\n                entry = createMiddlewareEntry(middleware2);\n            }\n            middlewareMap.set(entry.id, entry);\n        });\n    }, {\n        withTypes: ()=>addMiddleware\n    });\n    const getFinalMiddleware = (api)=>{\n        const appliedMiddleware = Array.from(middlewareMap.values()).map((entry)=>emplace(entry.applied, api, {\n                insert: ()=>entry.middleware(api)\n            }));\n        return (0,redux__WEBPACK_IMPORTED_MODULE_0__.compose)(...appliedMiddleware);\n    };\n    const isWithMiddleware = isAllOf(withMiddleware, matchInstance(instanceId));\n    const middleware = (api)=>(next)=>(action)=>{\n                if (isWithMiddleware(action)) {\n                    addMiddleware(...action.payload);\n                    return api.dispatch;\n                }\n                return getFinalMiddleware(api)(next)(action);\n            };\n    return {\n        middleware,\n        addMiddleware,\n        withMiddleware,\n        instanceId\n    };\n};\n// src/combineSlices.ts\n\nvar isSliceLike = (maybeSliceLike)=>\"reducerPath\" in maybeSliceLike && typeof maybeSliceLike.reducerPath === \"string\";\nvar getReducers = (slices)=>slices.flatMap((sliceOrMap)=>isSliceLike(sliceOrMap) ? [\n            [\n                sliceOrMap.reducerPath,\n                sliceOrMap.reducer\n            ]\n        ] : Object.entries(sliceOrMap));\nvar ORIGINAL_STATE = Symbol.for(\"rtk-state-proxy-original\");\nvar isStateProxy = (value)=>!!value && !!value[ORIGINAL_STATE];\nvar stateProxyMap = /* @__PURE__ */ new WeakMap();\nvar createStateProxy = (state, reducerMap)=>emplace(stateProxyMap, state, {\n        insert: ()=>new Proxy(state, {\n                get: (target, prop, receiver)=>{\n                    if (prop === ORIGINAL_STATE) return target;\n                    const result = Reflect.get(target, prop, receiver);\n                    if (typeof result === \"undefined\") {\n                        const reducer = reducerMap[prop.toString()];\n                        if (reducer) {\n                            const reducerResult = reducer(void 0, {\n                                type: nanoid()\n                            });\n                            if (typeof reducerResult === \"undefined\") {\n                                throw new Error( false ? 0 : `The slice reducer for key \"${prop.toString()}\" returned undefined when called for selector(). If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);\n                            }\n                            return reducerResult;\n                        }\n                    }\n                    return result;\n                }\n            })\n    });\nvar original = (state)=>{\n    if (!isStateProxy(state)) {\n        throw new Error( false ? 0 : \"original must be used on state Proxy\");\n    }\n    return state[ORIGINAL_STATE];\n};\nfunction combineSlices(...slices) {\n    const reducerMap = Object.fromEntries(getReducers(slices));\n    const getReducer = ()=>(0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)(reducerMap);\n    let reducer = getReducer();\n    function combinedReducer(state, action) {\n        return reducer(state, action);\n    }\n    combinedReducer.withLazyLoadedSlices = ()=>combinedReducer;\n    const inject = (slice, config = {})=>{\n        const { reducerPath, reducer: reducerToInject } = slice;\n        const currentReducer = reducerMap[reducerPath];\n        if (!config.overrideExisting && currentReducer && currentReducer !== reducerToInject) {\n            if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n                console.error(`called \\`inject\\` to override already-existing reducer ${reducerPath} without specifying \\`overrideExisting: true\\``);\n            }\n            return combinedReducer;\n        }\n        reducerMap[reducerPath] = reducerToInject;\n        reducer = getReducer();\n        return combinedReducer;\n    };\n    const selector = Object.assign(function makeSelector(selectorFn, selectState) {\n        return function selector2(state, ...args) {\n            return selectorFn(createStateProxy(selectState ? selectState(state, ...args) : state, reducerMap), ...args);\n        };\n    }, {\n        original\n    });\n    return Object.assign(combinedReducer, {\n        inject,\n        selector\n    });\n}\n// src/formatProdErrorMessage.ts\nfunction formatProdErrorMessage(code) {\n    return `Minified Redux Toolkit error #${code}; visit https://redux-toolkit.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;\n}\n //# sourceMappingURL=redux-toolkit.modern.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L3JlZHV4LXRvb2xraXQubW9kZXJuLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxlQUFlO0FBQ087QUFDbUY7QUFDaUM7QUFFMUksaUNBQWlDO0FBQ1E7QUFDd0I7QUFDakUsSUFBSWMsaUNBQWlDLENBQUMsR0FBR0M7SUFDdkMsTUFBTUMsa0JBQWtCUCwrREFBcUJBLElBQUlNO0lBQ2pELE1BQU1FLDJCQUEyQkMsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR0M7UUFDakQsTUFBTUMsV0FBV0wsbUJBQW1CSTtRQUNwQyxNQUFNRSxrQkFBa0IsQ0FBQ0MsT0FBTyxHQUFHQyxPQUFTSCxTQUFTZiw4Q0FBT0EsQ0FBQ2lCLFNBQVN0Qiw4Q0FBT0EsQ0FBQ3NCLFNBQVNBLFVBQVVDO1FBQ2pHTixPQUFPQyxNQUFNLENBQUNHLGlCQUFpQkQ7UUFDL0IsT0FBT0M7SUFDVCxHQUFHO1FBQ0RHLFdBQVcsSUFBTVI7SUFDbkI7SUFDQSxPQUFPQTtBQUNUO0FBQ0EsSUFBSVMsMEJBQTBCWiwrQkFBK0JGLG9EQUFjQTtBQUUzRSx3QkFBd0I7QUFDb0c7QUFFNUgsMkJBQTJCO0FBQ0s7QUFDaEMsSUFBSXNCLHNCQUFzQixNQUE0RSxHQUFHQyxDQUEyQyxHQUFHO0lBQ3JKLElBQUlFLFVBQVVDLE1BQU0sS0FBSyxHQUN2QixPQUFPLEtBQUs7SUFDZCxJQUFJLE9BQU9ELFNBQVMsQ0FBQyxFQUFFLEtBQUssVUFDMUIsT0FBT1IsMENBQU9BO0lBQ2hCLE9BQU9BLDBDQUFPQSxDQUFDVSxLQUFLLENBQUMsTUFBTUY7QUFDN0I7QUFDQSxJQUFJRyxtQkFBbUIsTUFBb0UsR0FBR0wsQ0FBbUMsR0FBRztJQUNsSSxPQUFPLFNBQVNPLEtBQUs7UUFDbkIsT0FBT0E7SUFDVDtBQUNGO0FBRUEsOEJBQThC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ZixpQkFBaUJiLFVBQVUsQ0FBQ3BSLFlBQVk7UUFDOUMsSUFBSSxDQUFDNEMsT0FBT3NQLGdCQUFnQixJQUFJRCxrQkFBa0JBLG1CQUFtQkQsaUJBQWlCO1lBQ3BGLElBQUksT0FBT3JtQixZQUFZLGVBQWVBLGtCQUF5QixlQUFlO2dCQUM1RXNCLFFBQVFsQixLQUFLLENBQUMsQ0FBQyx1REFBdUQsRUFBRWlVLFlBQVksOENBQThDLENBQUM7WUFDckk7WUFDQSxPQUFPOFI7UUFDVDtRQUNBVixVQUFVLENBQUNwUixZQUFZLEdBQUdnUztRQUMxQnJhLFVBQVVrYTtRQUNWLE9BQU9DO0lBQ1Q7SUFDQSxNQUFNdG9CLFdBQVdILE9BQU9DLE1BQU0sQ0FBQyxTQUFTNm9CLGFBQWFDLFVBQVUsRUFBRWpRLFdBQVc7UUFDMUUsT0FBTyxTQUFTa1EsVUFBVWxmLEtBQUssRUFBRSxHQUFHakssSUFBSTtZQUN0QyxPQUFPa3BCLFdBQVdqQixpQkFBaUJoUCxjQUFjQSxZQUFZaFAsVUFBVWpLLFFBQVFpSyxPQUFPaWUsZ0JBQWdCbG9CO1FBQ3hHO0lBQ0YsR0FBRztRQUNEWDtJQUNGO0lBQ0EsT0FBT2MsT0FBT0MsTUFBTSxDQUFDd29CLGlCQUFpQjtRQUNwQ2hQO1FBQ0F0WjtJQUNGO0FBQ0Y7QUFFQSxnQ0FBZ0M7QUFDaEMsU0FBU29DLHVCQUF1QjhkLElBQUk7SUFDbEMsT0FBTyxDQUFDLDhCQUE4QixFQUFFQSxLQUFLLGlEQUFpRCxFQUFFQSxLQUFLLCtFQUErRSxDQUFDO0FBQ3ZMO0FBb0RFLENBQ0YsaURBQWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYW5jaG9ycy5pbl9hc3NpZ25tZW50Ly4vbm9kZV9tb2R1bGVzL0ByZWR1eGpzL3Rvb2xraXQvZGlzdC9yZWR1eC10b29sa2l0Lm1vZGVybi5tanM/YWQzZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJyZWR1eFwiO1xuaW1wb3J0IHsgcHJvZHVjZSwgY3VycmVudCBhcyBjdXJyZW50MiwgZnJlZXplLCBvcmlnaW5hbCBhcyBvcmlnaW5hbDIsIGlzRHJhZnQgYXMgaXNEcmFmdDQgfSBmcm9tIFwiaW1tZXJcIjtcbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yLCBjcmVhdGVTZWxlY3RvckNyZWF0b3IgYXMgY3JlYXRlU2VsZWN0b3JDcmVhdG9yMiwgbHJ1TWVtb2l6ZSwgd2Vha01hcE1lbW9pemUgYXMgd2Vha01hcE1lbW9pemUyIH0gZnJvbSBcInJlc2VsZWN0XCI7XG5cbi8vIHNyYy9jcmVhdGVEcmFmdFNhZmVTZWxlY3Rvci50c1xuaW1wb3J0IHsgY3VycmVudCwgaXNEcmFmdCB9IGZyb20gXCJpbW1lclwiO1xuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3JDcmVhdG9yLCB3ZWFrTWFwTWVtb2l6ZSB9IGZyb20gXCJyZXNlbGVjdFwiO1xudmFyIGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yQ3JlYXRvciA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnN0IGNyZWF0ZVNlbGVjdG9yMiA9IGNyZWF0ZVNlbGVjdG9yQ3JlYXRvciguLi5hcmdzKTtcbiAgY29uc3QgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IyID0gT2JqZWN0LmFzc2lnbigoLi4uYXJnczIpID0+IHtcbiAgICBjb25zdCBzZWxlY3RvciA9IGNyZWF0ZVNlbGVjdG9yMiguLi5hcmdzMik7XG4gICAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gKHZhbHVlLCAuLi5yZXN0KSA9PiBzZWxlY3Rvcihpc0RyYWZ0KHZhbHVlKSA/IGN1cnJlbnQodmFsdWUpIDogdmFsdWUsIC4uLnJlc3QpO1xuICAgIE9iamVjdC5hc3NpZ24od3JhcHBlZFNlbGVjdG9yLCBzZWxlY3Rvcik7XG4gICAgcmV0dXJuIHdyYXBwZWRTZWxlY3RvcjtcbiAgfSwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IyXG4gIH0pO1xuICByZXR1cm4gY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IyO1xufTtcbnZhciBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvciA9IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yQ3JlYXRvcih3ZWFrTWFwTWVtb2l6ZSk7XG5cbi8vIHNyYy9jb25maWd1cmVTdG9yZS50c1xuaW1wb3J0IHsgYXBwbHlNaWRkbGV3YXJlLCBjcmVhdGVTdG9yZSwgY29tcG9zZSBhcyBjb21wb3NlMiwgY29tYmluZVJlZHVjZXJzLCBpc1BsYWluT2JqZWN0IGFzIGlzUGxhaW5PYmplY3QyIH0gZnJvbSBcInJlZHV4XCI7XG5cbi8vIHNyYy9kZXZ0b29sc0V4dGVuc2lvbi50c1xuaW1wb3J0IHsgY29tcG9zZSB9IGZyb20gXCJyZWR1eFwiO1xudmFyIGNvbXBvc2VXaXRoRGV2VG9vbHMgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18gPyB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fIDogZnVuY3Rpb24oKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiB2b2lkIDA7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSBcIm9iamVjdFwiKVxuICAgIHJldHVybiBjb21wb3NlO1xuICByZXR1cm4gY29tcG9zZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcbnZhciBkZXZUb29sc0VuaGFuY2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXyA/IHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fIDogZnVuY3Rpb24oKSB7XG4gIHJldHVybiBmdW5jdGlvbihub29wMykge1xuICAgIHJldHVybiBub29wMztcbiAgfTtcbn07XG5cbi8vIHNyYy9nZXREZWZhdWx0TWlkZGxld2FyZS50c1xuaW1wb3J0IHsgdGh1bmsgYXMgdGh1bmtNaWRkbGV3YXJlLCB3aXRoRXh0cmFBcmd1bWVudCB9IGZyb20gXCJyZWR1eC10aHVua1wiO1xuXG4vLyBzcmMvY3JlYXRlQWN0aW9uLnRzXG5pbXBvcnQgeyBpc0FjdGlvbiB9IGZyb20gXCJyZWR1eFwiO1xuXG4vLyBzcmMvdHNIZWxwZXJzLnRzXG52YXIgaGFzTWF0Y2hGdW5jdGlvbiA9ICh2KSA9PiB7XG4gIHJldHVybiB2ICYmIHR5cGVvZiB2Lm1hdGNoID09PSBcImZ1bmN0aW9uXCI7XG59O1xuXG4vLyBzcmMvY3JlYXRlQWN0aW9uLnRzXG5mdW5jdGlvbiBjcmVhdGVBY3Rpb24odHlwZSwgcHJlcGFyZUFjdGlvbikge1xuICBmdW5jdGlvbiBhY3Rpb25DcmVhdG9yKC4uLmFyZ3MpIHtcbiAgICBpZiAocHJlcGFyZUFjdGlvbikge1xuICAgICAgbGV0IHByZXBhcmVkID0gcHJlcGFyZUFjdGlvbiguLi5hcmdzKTtcbiAgICAgIGlmICghcHJlcGFyZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMCkgOiBcInByZXBhcmVBY3Rpb24gZGlkIG5vdCByZXR1cm4gYW4gb2JqZWN0XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcGF5bG9hZDogcHJlcGFyZWQucGF5bG9hZCxcbiAgICAgICAgLi4uXCJtZXRhXCIgaW4gcHJlcGFyZWQgJiYge1xuICAgICAgICAgIG1ldGE6IHByZXBhcmVkLm1ldGFcbiAgICAgICAgfSxcbiAgICAgICAgLi4uXCJlcnJvclwiIGluIHByZXBhcmVkICYmIHtcbiAgICAgICAgICBlcnJvcjogcHJlcGFyZWQuZXJyb3JcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGUsXG4gICAgICBwYXlsb2FkOiBhcmdzWzBdXG4gICAgfTtcbiAgfVxuICBhY3Rpb25DcmVhdG9yLnRvU3RyaW5nID0gKCkgPT4gYCR7dHlwZX1gO1xuICBhY3Rpb25DcmVhdG9yLnR5cGUgPSB0eXBlO1xuICBhY3Rpb25DcmVhdG9yLm1hdGNoID0gKGFjdGlvbikgPT4gaXNBY3Rpb24oYWN0aW9uKSAmJiBhY3Rpb24udHlwZSA9PT0gdHlwZTtcbiAgcmV0dXJuIGFjdGlvbkNyZWF0b3I7XG59XG5mdW5jdGlvbiBpc0FjdGlvbkNyZWF0b3IoYWN0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgYWN0aW9uID09PSBcImZ1bmN0aW9uXCIgJiYgXCJ0eXBlXCIgaW4gYWN0aW9uICYmIC8vIGhhc01hdGNoRnVuY3Rpb24gb25seSB3YW50cyBNYXRjaGVycyBidXQgSSBkb24ndCBzZWUgdGhlIHBvaW50IGluIHJld3JpdGluZyBpdFxuICBoYXNNYXRjaEZ1bmN0aW9uKGFjdGlvbik7XG59XG5mdW5jdGlvbiBpc0ZTQShhY3Rpb24pIHtcbiAgcmV0dXJuIGlzQWN0aW9uKGFjdGlvbikgJiYgT2JqZWN0LmtleXMoYWN0aW9uKS5ldmVyeShpc1ZhbGlkS2V5KTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRLZXkoa2V5KSB7XG4gIHJldHVybiBbXCJ0eXBlXCIsIFwicGF5bG9hZFwiLCBcImVycm9yXCIsIFwibWV0YVwiXS5pbmRleE9mKGtleSkgPiAtMTtcbn1cblxuLy8gc3JjL2FjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBnZXRNZXNzYWdlKHR5cGUpIHtcbiAgY29uc3Qgc3BsaXRUeXBlID0gdHlwZSA/IGAke3R5cGV9YC5zcGxpdChcIi9cIikgOiBbXTtcbiAgY29uc3QgYWN0aW9uTmFtZSA9IHNwbGl0VHlwZVtzcGxpdFR5cGUubGVuZ3RoIC0gMV0gfHwgXCJhY3Rpb25DcmVhdG9yXCI7XG4gIHJldHVybiBgRGV0ZWN0ZWQgYW4gYWN0aW9uIGNyZWF0b3Igd2l0aCB0eXBlIFwiJHt0eXBlIHx8IFwidW5rbm93blwifVwiIGJlaW5nIGRpc3BhdGNoZWQuIFxuTWFrZSBzdXJlIHlvdSdyZSBjYWxsaW5nIHRoZSBhY3Rpb24gY3JlYXRvciBiZWZvcmUgZGlzcGF0Y2hpbmcsIGkuZS4gXFxgZGlzcGF0Y2goJHthY3Rpb25OYW1lfSgpKVxcYCBpbnN0ZWFkIG9mIFxcYGRpc3BhdGNoKCR7YWN0aW9uTmFtZX0pXFxgLiBUaGlzIGlzIG5lY2Vzc2FyeSBldmVuIGlmIHRoZSBhY3Rpb24gaGFzIG5vIHBheWxvYWQuYDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlKG9wdGlvbnMgPSB7fSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcmV0dXJuICgpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiBuZXh0KGFjdGlvbik7XG4gIH1cbiAgY29uc3Qge1xuICAgIGlzQWN0aW9uQ3JlYXRvcjogaXNBY3Rpb25DcmVhdG9yMiA9IGlzQWN0aW9uQ3JlYXRvclxuICB9ID0gb3B0aW9ucztcbiAgcmV0dXJuICgpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiB7XG4gICAgaWYgKGlzQWN0aW9uQ3JlYXRvcjIoYWN0aW9uKSkge1xuICAgICAgY29uc29sZS53YXJuKGdldE1lc3NhZ2UoYWN0aW9uLnR5cGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgfTtcbn1cblxuLy8gc3JjL3V0aWxzLnRzXG5pbXBvcnQgeyBwcm9kdWNlIGFzIGNyZWF0ZU5leHRTdGF0ZSwgaXNEcmFmdGFibGUgfSBmcm9tIFwiaW1tZXJcIjtcbmZ1bmN0aW9uIGdldFRpbWVNZWFzdXJlVXRpbHMobWF4RGVsYXksIGZuTmFtZSkge1xuICBsZXQgZWxhcHNlZCA9IDA7XG4gIHJldHVybiB7XG4gICAgbWVhc3VyZVRpbWUoZm4pIHtcbiAgICAgIGNvbnN0IHN0YXJ0ZWQgPSBEYXRlLm5vdygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjb25zdCBmaW5pc2hlZCA9IERhdGUubm93KCk7XG4gICAgICAgIGVsYXBzZWQgKz0gZmluaXNoZWQgLSBzdGFydGVkO1xuICAgICAgfVxuICAgIH0sXG4gICAgd2FybklmRXhjZWVkZWQoKSB7XG4gICAgICBpZiAoZWxhcHNlZCA+IG1heERlbGF5KSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgJHtmbk5hbWV9IHRvb2sgJHtlbGFwc2VkfW1zLCB3aGljaCBpcyBtb3JlIHRoYW4gdGhlIHdhcm5pbmcgdGhyZXNob2xkIG9mICR7bWF4RGVsYXl9bXMuIFxuSWYgeW91ciBzdGF0ZSBvciBhY3Rpb25zIGFyZSB2ZXJ5IGxhcmdlLCB5b3UgbWF5IHdhbnQgdG8gZGlzYWJsZSB0aGUgbWlkZGxld2FyZSBhcyBpdCBtaWdodCBjYXVzZSB0b28gbXVjaCBvZiBhIHNsb3dkb3duIGluIGRldmVsb3BtZW50IG1vZGUuIFNlZSBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL2FwaS9nZXREZWZhdWx0TWlkZGxld2FyZSBmb3IgaW5zdHJ1Y3Rpb25zLlxuSXQgaXMgZGlzYWJsZWQgaW4gcHJvZHVjdGlvbiBidWlsZHMsIHNvIHlvdSBkb24ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoYXQuYCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZmluZChpdGVyYWJsZSwgY29tcGFyYXRvcikge1xuICBmb3IgKGNvbnN0IGVudHJ5IG9mIGl0ZXJhYmxlKSB7XG4gICAgaWYgKGNvbXBhcmF0b3IoZW50cnkpKSB7XG4gICAgICByZXR1cm4gZW50cnk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG52YXIgVHVwbGUgPSBjbGFzcyBfVHVwbGUgZXh0ZW5kcyBBcnJheSB7XG4gIGNvbnN0cnVjdG9yKC4uLml0ZW1zKSB7XG4gICAgc3VwZXIoLi4uaXRlbXMpO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBfVHVwbGUucHJvdG90eXBlKTtcbiAgfVxuICBzdGF0aWMgZ2V0IFtTeW1ib2wuc3BlY2llc10oKSB7XG4gICAgcmV0dXJuIF9UdXBsZTtcbiAgfVxuICBjb25jYXQoLi4uYXJyKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNvbmNhdC5hcHBseSh0aGlzLCBhcnIpO1xuICB9XG4gIHByZXBlbmQoLi4uYXJyKSB7XG4gICAgaWYgKGFyci5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShhcnJbMF0pKSB7XG4gICAgICByZXR1cm4gbmV3IF9UdXBsZSguLi5hcnJbMF0uY29uY2F0KHRoaXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfVHVwbGUoLi4uYXJyLmNvbmNhdCh0aGlzKSk7XG4gIH1cbn07XG5mdW5jdGlvbiBmcmVlemVEcmFmdGFibGUodmFsKSB7XG4gIHJldHVybiBpc0RyYWZ0YWJsZSh2YWwpID8gY3JlYXRlTmV4dFN0YXRlKHZhbCwgKCkgPT4ge1xuICB9KSA6IHZhbDtcbn1cbmZ1bmN0aW9uIGVtcGxhY2UobWFwLCBrZXksIGhhbmRsZXIpIHtcbiAgaWYgKG1hcC5oYXMoa2V5KSkge1xuICAgIGxldCB2YWx1ZSA9IG1hcC5nZXQoa2V5KTtcbiAgICBpZiAoaGFuZGxlci51cGRhdGUpIHtcbiAgICAgIHZhbHVlID0gaGFuZGxlci51cGRhdGUodmFsdWUsIGtleSwgbWFwKTtcbiAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoIWhhbmRsZXIuaW5zZXJ0KVxuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEwKSA6IFwiTm8gaW5zZXJ0IHByb3ZpZGVkIGZvciBrZXkgbm90IGFscmVhZHkgaW4gbWFwXCIpO1xuICBjb25zdCBpbnNlcnRlZCA9IGhhbmRsZXIuaW5zZXJ0KGtleSwgbWFwKTtcbiAgbWFwLnNldChrZXksIGluc2VydGVkKTtcbiAgcmV0dXJuIGluc2VydGVkO1xufVxuXG4vLyBzcmMvaW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBpc0ltbXV0YWJsZURlZmF1bHQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PSBudWxsIHx8IE9iamVjdC5pc0Zyb3plbih2YWx1ZSk7XG59XG5mdW5jdGlvbiB0cmFja0Zvck11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIG9iaikge1xuICBjb25zdCB0cmFja2VkUHJvcGVydGllcyA9IHRyYWNrUHJvcGVydGllcyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIG9iaik7XG4gIHJldHVybiB7XG4gICAgZGV0ZWN0TXV0YXRpb25zKCkge1xuICAgICAgcmV0dXJuIGRldGVjdE11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIHRyYWNrZWRQcm9wZXJ0aWVzLCBvYmopO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHRyYWNrUHJvcGVydGllcyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMgPSBbXSwgb2JqLCBwYXRoID0gXCJcIiwgY2hlY2tlZE9iamVjdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKSB7XG4gIGNvbnN0IHRyYWNrZWQgPSB7XG4gICAgdmFsdWU6IG9ialxuICB9O1xuICBpZiAoIWlzSW1tdXRhYmxlKG9iaikgJiYgIWNoZWNrZWRPYmplY3RzLmhhcyhvYmopKSB7XG4gICAgY2hlY2tlZE9iamVjdHMuYWRkKG9iaik7XG4gICAgdHJhY2tlZC5jaGlsZHJlbiA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgY29uc3QgY2hpbGRQYXRoID0gcGF0aCA/IHBhdGggKyBcIi5cIiArIGtleSA6IGtleTtcbiAgICAgIGlmIChpZ25vcmVQYXRocy5sZW5ndGggJiYgaWdub3JlUGF0aHMuaW5kZXhPZihjaGlsZFBhdGgpICE9PSAtMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRyYWNrZWQuY2hpbGRyZW5ba2V5XSA9IHRyYWNrUHJvcGVydGllcyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIG9ialtrZXldLCBjaGlsZFBhdGgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJhY2tlZDtcbn1cbmZ1bmN0aW9uIGRldGVjdE11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlZFBhdGhzID0gW10sIHRyYWNrZWRQcm9wZXJ0eSwgb2JqLCBzYW1lUGFyZW50UmVmID0gZmFsc2UsIHBhdGggPSBcIlwiKSB7XG4gIGNvbnN0IHByZXZPYmogPSB0cmFja2VkUHJvcGVydHkgPyB0cmFja2VkUHJvcGVydHkudmFsdWUgOiB2b2lkIDA7XG4gIGNvbnN0IHNhbWVSZWYgPSBwcmV2T2JqID09PSBvYmo7XG4gIGlmIChzYW1lUGFyZW50UmVmICYmICFzYW1lUmVmICYmICFOdW1iZXIuaXNOYU4ob2JqKSkge1xuICAgIHJldHVybiB7XG4gICAgICB3YXNNdXRhdGVkOiB0cnVlLFxuICAgICAgcGF0aFxuICAgIH07XG4gIH1cbiAgaWYgKGlzSW1tdXRhYmxlKHByZXZPYmopIHx8IGlzSW1tdXRhYmxlKG9iaikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2FzTXV0YXRlZDogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNvbnN0IGtleXNUb0RldGVjdCA9IHt9O1xuICBmb3IgKGxldCBrZXkgaW4gdHJhY2tlZFByb3BlcnR5LmNoaWxkcmVuKSB7XG4gICAga2V5c1RvRGV0ZWN0W2tleV0gPSB0cnVlO1xuICB9XG4gIGZvciAobGV0IGtleSBpbiBvYmopIHtcbiAgICBrZXlzVG9EZXRlY3Rba2V5XSA9IHRydWU7XG4gIH1cbiAgY29uc3QgaGFzSWdub3JlZFBhdGhzID0gaWdub3JlZFBhdGhzLmxlbmd0aCA+IDA7XG4gIGZvciAobGV0IGtleSBpbiBrZXlzVG9EZXRlY3QpIHtcbiAgICBjb25zdCBuZXN0ZWRQYXRoID0gcGF0aCA/IHBhdGggKyBcIi5cIiArIGtleSA6IGtleTtcbiAgICBpZiAoaGFzSWdub3JlZFBhdGhzKSB7XG4gICAgICBjb25zdCBoYXNNYXRjaGVzID0gaWdub3JlZFBhdGhzLnNvbWUoKGlnbm9yZWQpID0+IHtcbiAgICAgICAgaWYgKGlnbm9yZWQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICByZXR1cm4gaWdub3JlZC50ZXN0KG5lc3RlZFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXN0ZWRQYXRoID09PSBpZ25vcmVkO1xuICAgICAgfSk7XG4gICAgICBpZiAoaGFzTWF0Y2hlcykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gZGV0ZWN0TXV0YXRpb25zKGlzSW1tdXRhYmxlLCBpZ25vcmVkUGF0aHMsIHRyYWNrZWRQcm9wZXJ0eS5jaGlsZHJlbltrZXldLCBvYmpba2V5XSwgc2FtZVJlZiwgbmVzdGVkUGF0aCk7XG4gICAgaWYgKHJlc3VsdC53YXNNdXRhdGVkKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHdhc011dGF0ZWQ6IGZhbHNlXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUob3B0aW9ucyA9IHt9KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICByZXR1cm4gKCkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IG5leHQoYWN0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgc3RyaW5naWZ5MiA9IGZ1bmN0aW9uKG9iaiwgc2VyaWFsaXplciwgaW5kZW50LCBkZWN5Y2xlcikge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgZ2V0U2VyaWFsaXplMihzZXJpYWxpemVyLCBkZWN5Y2xlciksIGluZGVudCk7XG4gICAgfSwgZ2V0U2VyaWFsaXplMiA9IGZ1bmN0aW9uKHNlcmlhbGl6ZXIsIGRlY3ljbGVyKSB7XG4gICAgICBsZXQgc3RhY2sgPSBbXSwga2V5cyA9IFtdO1xuICAgICAgaWYgKCFkZWN5Y2xlcilcbiAgICAgICAgZGVjeWNsZXIgPSBmdW5jdGlvbihfLCB2YWx1ZSkge1xuICAgICAgICAgIGlmIChzdGFja1swXSA9PT0gdmFsdWUpXG4gICAgICAgICAgICByZXR1cm4gXCJbQ2lyY3VsYXIgfl1cIjtcbiAgICAgICAgICByZXR1cm4gXCJbQ2lyY3VsYXIgfi5cIiArIGtleXMuc2xpY2UoMCwgc3RhY2suaW5kZXhPZih2YWx1ZSkpLmpvaW4oXCIuXCIpICsgXCJdXCI7XG4gICAgICAgIH07XG4gICAgICByZXR1cm4gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciB0aGlzUG9zID0gc3RhY2suaW5kZXhPZih0aGlzKTtcbiAgICAgICAgICB+dGhpc1BvcyA/IHN0YWNrLnNwbGljZSh0aGlzUG9zICsgMSkgOiBzdGFjay5wdXNoKHRoaXMpO1xuICAgICAgICAgIH50aGlzUG9zID8ga2V5cy5zcGxpY2UodGhpc1BvcywgSW5maW5pdHksIGtleSkgOiBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICBpZiAofnN0YWNrLmluZGV4T2YodmFsdWUpKVxuICAgICAgICAgICAgdmFsdWUgPSBkZWN5Y2xlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZXIgPT0gbnVsbCA/IHZhbHVlIDogc2VyaWFsaXplci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBzdHJpbmdpZnkgPSBzdHJpbmdpZnkyLCBnZXRTZXJpYWxpemUgPSBnZXRTZXJpYWxpemUyO1xuICAgIGxldCB7XG4gICAgICBpc0ltbXV0YWJsZSA9IGlzSW1tdXRhYmxlRGVmYXVsdCxcbiAgICAgIGlnbm9yZWRQYXRocyxcbiAgICAgIHdhcm5BZnRlciA9IDMyXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgdHJhY2sgPSB0cmFja0Zvck11dGF0aW9ucy5iaW5kKG51bGwsIGlzSW1tdXRhYmxlLCBpZ25vcmVkUGF0aHMpO1xuICAgIHJldHVybiAoe1xuICAgICAgZ2V0U3RhdGVcbiAgICB9KSA9PiB7XG4gICAgICBsZXQgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgICAgbGV0IHRyYWNrZXIgPSB0cmFjayhzdGF0ZSk7XG4gICAgICBsZXQgcmVzdWx0O1xuICAgICAgcmV0dXJuIChuZXh0KSA9PiAoYWN0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IG1lYXN1cmVVdGlscyA9IGdldFRpbWVNZWFzdXJlVXRpbHMod2FybkFmdGVyLCBcIkltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZVwiKTtcbiAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcbiAgICAgICAgICBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgICAgICAgcmVzdWx0ID0gdHJhY2tlci5kZXRlY3RNdXRhdGlvbnMoKTtcbiAgICAgICAgICB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xuICAgICAgICAgIGlmIChyZXN1bHQud2FzTXV0YXRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTkpIDogYEEgc3RhdGUgbXV0YXRpb24gd2FzIGRldGVjdGVkIGJldHdlZW4gZGlzcGF0Y2hlcywgaW4gdGhlIHBhdGggJyR7cmVzdWx0LnBhdGggfHwgXCJcIn0nLiAgVGhpcyBtYXkgY2F1c2UgaW5jb3JyZWN0IGJlaGF2aW9yLiAoaHR0cHM6Ly9yZWR1eC5qcy5vcmcvc3R5bGUtZ3VpZGUvc3R5bGUtZ3VpZGUjZG8tbm90LW11dGF0ZS1zdGF0ZSlgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkaXNwYXRjaGVkQWN0aW9uID0gbmV4dChhY3Rpb24pO1xuICAgICAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoKCkgPT4ge1xuICAgICAgICAgIHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICAgICAgICByZXN1bHQgPSB0cmFja2VyLmRldGVjdE11dGF0aW9ucygpO1xuICAgICAgICAgIHRyYWNrZXIgPSB0cmFjayhzdGF0ZSk7XG4gICAgICAgICAgaWYgKHJlc3VsdC53YXNNdXRhdGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyMCkgOiBgQSBzdGF0ZSBtdXRhdGlvbiB3YXMgZGV0ZWN0ZWQgaW5zaWRlIGEgZGlzcGF0Y2gsIGluIHRoZSBwYXRoOiAke3Jlc3VsdC5wYXRoIHx8IFwiXCJ9LiBUYWtlIGEgbG9vayBhdCB0aGUgcmVkdWNlcihzKSBoYW5kbGluZyB0aGUgYWN0aW9uICR7c3RyaW5naWZ5MihhY3Rpb24pfS4gKGh0dHBzOi8vcmVkdXguanMub3JnL3N0eWxlLWd1aWRlL3N0eWxlLWd1aWRlI2RvLW5vdC1tdXRhdGUtc3RhdGUpYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWVhc3VyZVV0aWxzLndhcm5JZkV4Y2VlZGVkKCk7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaGVkQWN0aW9uO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG59XG5cbi8vIHNyYy9zZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUudHNcbmltcG9ydCB7IGlzQWN0aW9uIGFzIGlzQWN0aW9uMiwgaXNQbGFpbk9iamVjdCB9IGZyb20gXCJyZWR1eFwiO1xuZnVuY3Rpb24gaXNQbGFpbih2YWwpIHtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIHJldHVybiB2YWwgPT0gbnVsbCB8fCB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiIHx8IHR5cGUgPT09IFwibnVtYmVyXCIgfHwgQXJyYXkuaXNBcnJheSh2YWwpIHx8IGlzUGxhaW5PYmplY3QodmFsKTtcbn1cbmZ1bmN0aW9uIGZpbmROb25TZXJpYWxpemFibGVWYWx1ZSh2YWx1ZSwgcGF0aCA9IFwiXCIsIGlzU2VyaWFsaXphYmxlID0gaXNQbGFpbiwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzID0gW10sIGNhY2hlKSB7XG4gIGxldCBmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZTtcbiAgaWYgKCFpc1NlcmlhbGl6YWJsZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5UGF0aDogcGF0aCB8fCBcIjxyb290PlwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGNhY2hlPy5oYXModmFsdWUpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3QgZW50cmllcyA9IGdldEVudHJpZXMgIT0gbnVsbCA/IGdldEVudHJpZXModmFsdWUpIDogT2JqZWN0LmVudHJpZXModmFsdWUpO1xuICBjb25zdCBoYXNJZ25vcmVkUGF0aHMgPSBpZ25vcmVkUGF0aHMubGVuZ3RoID4gMDtcbiAgZm9yIChjb25zdCBba2V5LCBuZXN0ZWRWYWx1ZV0gb2YgZW50cmllcykge1xuICAgIGNvbnN0IG5lc3RlZFBhdGggPSBwYXRoID8gcGF0aCArIFwiLlwiICsga2V5IDoga2V5O1xuICAgIGlmIChoYXNJZ25vcmVkUGF0aHMpIHtcbiAgICAgIGNvbnN0IGhhc01hdGNoZXMgPSBpZ25vcmVkUGF0aHMuc29tZSgoaWdub3JlZCkgPT4ge1xuICAgICAgICBpZiAoaWdub3JlZCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgIHJldHVybiBpZ25vcmVkLnRlc3QobmVzdGVkUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5lc3RlZFBhdGggPT09IGlnbm9yZWQ7XG4gICAgICB9KTtcbiAgICAgIGlmIChoYXNNYXRjaGVzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzU2VyaWFsaXphYmxlKG5lc3RlZFZhbHVlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5UGF0aDogbmVzdGVkUGF0aCxcbiAgICAgICAgdmFsdWU6IG5lc3RlZFZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5lc3RlZFZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShuZXN0ZWRWYWx1ZSwgbmVzdGVkUGF0aCwgaXNTZXJpYWxpemFibGUsIGdldEVudHJpZXMsIGlnbm9yZWRQYXRocywgY2FjaGUpO1xuICAgICAgaWYgKGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlKSB7XG4gICAgICAgIHJldHVybiBmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGNhY2hlICYmIGlzTmVzdGVkRnJvemVuKHZhbHVlKSlcbiAgICBjYWNoZS5hZGQodmFsdWUpO1xuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc05lc3RlZEZyb3plbih2YWx1ZSkge1xuICBpZiAoIU9iamVjdC5pc0Zyb3plbih2YWx1ZSkpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGNvbnN0IG5lc3RlZFZhbHVlIG9mIE9iamVjdC52YWx1ZXModmFsdWUpKSB7XG4gICAgaWYgKHR5cGVvZiBuZXN0ZWRWYWx1ZSAhPT0gXCJvYmplY3RcIiB8fCBuZXN0ZWRWYWx1ZSA9PT0gbnVsbClcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmICghaXNOZXN0ZWRGcm96ZW4obmVzdGVkVmFsdWUpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKG9wdGlvbnMgPSB7fSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcmV0dXJuICgpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiBuZXh0KGFjdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNTZXJpYWxpemFibGUgPSBpc1BsYWluLFxuICAgICAgZ2V0RW50cmllcyxcbiAgICAgIGlnbm9yZWRBY3Rpb25zID0gW10sXG4gICAgICBpZ25vcmVkQWN0aW9uUGF0aHMgPSBbXCJtZXRhLmFyZ1wiLCBcIm1ldGEuYmFzZVF1ZXJ5TWV0YVwiXSxcbiAgICAgIGlnbm9yZWRQYXRocyA9IFtdLFxuICAgICAgd2FybkFmdGVyID0gMzIsXG4gICAgICBpZ25vcmVTdGF0ZSA9IGZhbHNlLFxuICAgICAgaWdub3JlQWN0aW9ucyA9IGZhbHNlLFxuICAgICAgZGlzYWJsZUNhY2hlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBjYWNoZSA9ICFkaXNhYmxlQ2FjaGUgJiYgV2Vha1NldCA/IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpIDogdm9pZCAwO1xuICAgIHJldHVybiAoc3RvcmVBUEkpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiB7XG4gICAgICBpZiAoIWlzQWN0aW9uMihhY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBuZXh0KGFjdGlvbik7XG4gICAgICBjb25zdCBtZWFzdXJlVXRpbHMgPSBnZXRUaW1lTWVhc3VyZVV0aWxzKHdhcm5BZnRlciwgXCJTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVcIik7XG4gICAgICBpZiAoIWlnbm9yZUFjdGlvbnMgJiYgIShpZ25vcmVkQWN0aW9ucy5sZW5ndGggJiYgaWdub3JlZEFjdGlvbnMuaW5kZXhPZihhY3Rpb24udHlwZSkgIT09IC0xKSkge1xuICAgICAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWUgPSBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUoYWN0aW9uLCBcIlwiLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZEFjdGlvblBhdGhzLCBjYWNoZSk7XG4gICAgICAgICAgaWYgKGZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0gPSBmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQSBub24tc2VyaWFsaXphYmxlIHZhbHVlIHdhcyBkZXRlY3RlZCBpbiBhbiBhY3Rpb24sIGluIHRoZSBwYXRoOiBcXGAke2tleVBhdGh9XFxgLiBWYWx1ZTpgLCB2YWx1ZSwgXCJcXG5UYWtlIGEgbG9vayBhdCB0aGUgbG9naWMgdGhhdCBkaXNwYXRjaGVkIHRoaXMgYWN0aW9uOiBcIiwgYWN0aW9uLCBcIlxcbihTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvZmFxL2FjdGlvbnMjd2h5LXNob3VsZC10eXBlLWJlLWEtc3RyaW5nLW9yLWF0LWxlYXN0LXNlcmlhbGl6YWJsZS13aHktc2hvdWxkLW15LWFjdGlvbi10eXBlcy1iZS1jb25zdGFudHMpXCIsIFwiXFxuKFRvIGFsbG93IG5vbi1zZXJpYWxpemFibGUgdmFsdWVzIHNlZTogaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy91c2FnZS91c2FnZS1ndWlkZSN3b3JraW5nLXdpdGgtbm9uLXNlcmlhbGl6YWJsZS1kYXRhKVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFpZ25vcmVTdGF0ZSkge1xuICAgICAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gc3RvcmVBUEkuZ2V0U3RhdGUoKTtcbiAgICAgICAgICBjb25zdCBmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWUgPSBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUoc3RhdGUsIFwiXCIsIGlzU2VyaWFsaXphYmxlLCBnZXRFbnRyaWVzLCBpZ25vcmVkUGF0aHMsIGNhY2hlKTtcbiAgICAgICAgICBpZiAoZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9ID0gZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQSBub24tc2VyaWFsaXphYmxlIHZhbHVlIHdhcyBkZXRlY3RlZCBpbiB0aGUgc3RhdGUsIGluIHRoZSBwYXRoOiBcXGAke2tleVBhdGh9XFxgLiBWYWx1ZTpgLCB2YWx1ZSwgYFxuVGFrZSBhIGxvb2sgYXQgdGhlIHJlZHVjZXIocykgaGFuZGxpbmcgdGhpcyBhY3Rpb24gdHlwZTogJHthY3Rpb24udHlwZX0uXG4oU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2ZhcS9vcmdhbml6aW5nLXN0YXRlI2Nhbi1pLXB1dC1mdW5jdGlvbnMtcHJvbWlzZXMtb3Itb3RoZXItbm9uLXNlcmlhbGl6YWJsZS1pdGVtcy1pbi1teS1zdG9yZS1zdGF0ZSlgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBtZWFzdXJlVXRpbHMud2FybklmRXhjZWVkZWQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfVxufVxuXG4vLyBzcmMvZ2V0RGVmYXVsdE1pZGRsZXdhcmUudHNcbmZ1bmN0aW9uIGlzQm9vbGVhbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gXCJib29sZWFuXCI7XG59XG52YXIgYnVpbGRHZXREZWZhdWx0TWlkZGxld2FyZSA9ICgpID0+IGZ1bmN0aW9uIGdldERlZmF1bHRNaWRkbGV3YXJlKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIHRodW5rID0gdHJ1ZSxcbiAgICBpbW11dGFibGVDaGVjayA9IHRydWUsXG4gICAgc2VyaWFsaXphYmxlQ2hlY2sgPSB0cnVlLFxuICAgIGFjdGlvbkNyZWF0b3JDaGVjayA9IHRydWVcbiAgfSA9IG9wdGlvbnMgPz8ge307XG4gIGxldCBtaWRkbGV3YXJlQXJyYXkgPSBuZXcgVHVwbGUoKTtcbiAgaWYgKHRodW5rKSB7XG4gICAgaWYgKGlzQm9vbGVhbih0aHVuaykpIHtcbiAgICAgIG1pZGRsZXdhcmVBcnJheS5wdXNoKHRodW5rTWlkZGxld2FyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pZGRsZXdhcmVBcnJheS5wdXNoKHdpdGhFeHRyYUFyZ3VtZW50KHRodW5rLmV4dHJhQXJndW1lbnQpKTtcbiAgICB9XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmIChpbW11dGFibGVDaGVjaykge1xuICAgICAgbGV0IGltbXV0YWJsZU9wdGlvbnMgPSB7fTtcbiAgICAgIGlmICghaXNCb29sZWFuKGltbXV0YWJsZUNoZWNrKSkge1xuICAgICAgICBpbW11dGFibGVPcHRpb25zID0gaW1tdXRhYmxlQ2hlY2s7XG4gICAgICB9XG4gICAgICBtaWRkbGV3YXJlQXJyYXkudW5zaGlmdChjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUoaW1tdXRhYmxlT3B0aW9ucykpO1xuICAgIH1cbiAgICBpZiAoc2VyaWFsaXphYmxlQ2hlY2spIHtcbiAgICAgIGxldCBzZXJpYWxpemFibGVPcHRpb25zID0ge307XG4gICAgICBpZiAoIWlzQm9vbGVhbihzZXJpYWxpemFibGVDaGVjaykpIHtcbiAgICAgICAgc2VyaWFsaXphYmxlT3B0aW9ucyA9IHNlcmlhbGl6YWJsZUNoZWNrO1xuICAgICAgfVxuICAgICAgbWlkZGxld2FyZUFycmF5LnB1c2goY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKHNlcmlhbGl6YWJsZU9wdGlvbnMpKTtcbiAgICB9XG4gICAgaWYgKGFjdGlvbkNyZWF0b3JDaGVjaykge1xuICAgICAgbGV0IGFjdGlvbkNyZWF0b3JPcHRpb25zID0ge307XG4gICAgICBpZiAoIWlzQm9vbGVhbihhY3Rpb25DcmVhdG9yQ2hlY2spKSB7XG4gICAgICAgIGFjdGlvbkNyZWF0b3JPcHRpb25zID0gYWN0aW9uQ3JlYXRvckNoZWNrO1xuICAgICAgfVxuICAgICAgbWlkZGxld2FyZUFycmF5LnVuc2hpZnQoY3JlYXRlQWN0aW9uQ3JlYXRvckludmFyaWFudE1pZGRsZXdhcmUoYWN0aW9uQ3JlYXRvck9wdGlvbnMpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1pZGRsZXdhcmVBcnJheTtcbn07XG5cbi8vIHNyYy9hdXRvQmF0Y2hFbmhhbmNlci50c1xudmFyIFNIT1VMRF9BVVRPQkFUQ0ggPSBcIlJUS19hdXRvQmF0Y2hcIjtcbnZhciBwcmVwYXJlQXV0b0JhdGNoZWQgPSAoKSA9PiAocGF5bG9hZCkgPT4gKHtcbiAgcGF5bG9hZCxcbiAgbWV0YToge1xuICAgIFtTSE9VTERfQVVUT0JBVENIXTogdHJ1ZVxuICB9XG59KTtcbnZhciBjcmVhdGVRdWV1ZVdpdGhUaW1lciA9ICh0aW1lb3V0KSA9PiB7XG4gIHJldHVybiAobm90aWZ5KSA9PiB7XG4gICAgc2V0VGltZW91dChub3RpZnksIHRpbWVvdXQpO1xuICB9O1xufTtcbnZhciByQUYgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogY3JlYXRlUXVldWVXaXRoVGltZXIoMTApO1xudmFyIGF1dG9CYXRjaEVuaGFuY2VyID0gKG9wdGlvbnMgPSB7XG4gIHR5cGU6IFwicmFmXCJcbn0pID0+IChuZXh0KSA9PiAoLi4uYXJncykgPT4ge1xuICBjb25zdCBzdG9yZSA9IG5leHQoLi4uYXJncyk7XG4gIGxldCBub3RpZnlpbmcgPSB0cnVlO1xuICBsZXQgc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2sgPSBmYWxzZTtcbiAgbGV0IG5vdGlmaWNhdGlvblF1ZXVlZCA9IGZhbHNlO1xuICBjb25zdCBsaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBxdWV1ZUNhbGxiYWNrID0gb3B0aW9ucy50eXBlID09PSBcInRpY2tcIiA/IHF1ZXVlTWljcm90YXNrIDogb3B0aW9ucy50eXBlID09PSBcInJhZlwiID8gckFGIDogb3B0aW9ucy50eXBlID09PSBcImNhbGxiYWNrXCIgPyBvcHRpb25zLnF1ZXVlTm90aWZpY2F0aW9uIDogY3JlYXRlUXVldWVXaXRoVGltZXIob3B0aW9ucy50aW1lb3V0KTtcbiAgY29uc3Qgbm90aWZ5TGlzdGVuZXJzID0gKCkgPT4ge1xuICAgIG5vdGlmaWNhdGlvblF1ZXVlZCA9IGZhbHNlO1xuICAgIGlmIChzaG91bGROb3RpZnlBdEVuZE9mVGljaykge1xuICAgICAgc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2sgPSBmYWxzZTtcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKChsKSA9PiBsKCkpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0b3JlLCB7XG4gICAgLy8gT3ZlcnJpZGUgdGhlIGJhc2UgYHN0b3JlLnN1YnNjcmliZWAgbWV0aG9kIHRvIGtlZXAgb3JpZ2luYWwgbGlzdGVuZXJzXG4gICAgLy8gZnJvbSBydW5uaW5nIGlmIHdlJ3JlIGRlbGF5aW5nIG5vdGlmaWNhdGlvbnNcbiAgICBzdWJzY3JpYmUobGlzdGVuZXIyKSB7XG4gICAgICBjb25zdCB3cmFwcGVkTGlzdGVuZXIgPSAoKSA9PiBub3RpZnlpbmcgJiYgbGlzdGVuZXIyKCk7XG4gICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN0b3JlLnN1YnNjcmliZSh3cmFwcGVkTGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXJzLmFkZChsaXN0ZW5lcjIpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcjIpO1xuICAgICAgfTtcbiAgICB9LFxuICAgIC8vIE92ZXJyaWRlIHRoZSBiYXNlIGBzdG9yZS5kaXNwYXRjaGAgbWV0aG9kIHNvIHRoYXQgd2UgY2FuIGNoZWNrIGFjdGlvbnNcbiAgICAvLyBmb3IgdGhlIGBzaG91bGRBdXRvQmF0Y2hgIGZsYWcgYW5kIGRldGVybWluZSBpZiBiYXRjaGluZyBpcyBhY3RpdmVcbiAgICBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5vdGlmeWluZyA9ICFhY3Rpb24/Lm1ldGE/LltTSE9VTERfQVVUT0JBVENIXTtcbiAgICAgICAgc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2sgPSAhbm90aWZ5aW5nO1xuICAgICAgICBpZiAoc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2spIHtcbiAgICAgICAgICBpZiAoIW5vdGlmaWNhdGlvblF1ZXVlZCkge1xuICAgICAgICAgICAgbm90aWZpY2F0aW9uUXVldWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHF1ZXVlQ2FsbGJhY2sobm90aWZ5TGlzdGVuZXJzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoKGFjdGlvbik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBub3RpZnlpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBzcmMvZ2V0RGVmYXVsdEVuaGFuY2Vycy50c1xudmFyIGJ1aWxkR2V0RGVmYXVsdEVuaGFuY2VycyA9IChtaWRkbGV3YXJlRW5oYW5jZXIpID0+IGZ1bmN0aW9uIGdldERlZmF1bHRFbmhhbmNlcnMob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgYXV0b0JhdGNoID0gdHJ1ZVxuICB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgbGV0IGVuaGFuY2VyQXJyYXkgPSBuZXcgVHVwbGUobWlkZGxld2FyZUVuaGFuY2VyKTtcbiAgaWYgKGF1dG9CYXRjaCkge1xuICAgIGVuaGFuY2VyQXJyYXkucHVzaChhdXRvQmF0Y2hFbmhhbmNlcih0eXBlb2YgYXV0b0JhdGNoID09PSBcIm9iamVjdFwiID8gYXV0b0JhdGNoIDogdm9pZCAwKSk7XG4gIH1cbiAgcmV0dXJuIGVuaGFuY2VyQXJyYXk7XG59O1xuXG4vLyBzcmMvY29uZmlndXJlU3RvcmUudHNcbnZhciBJU19QUk9EVUNUSU9OID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiO1xuZnVuY3Rpb24gY29uZmlndXJlU3RvcmUob3B0aW9ucykge1xuICBjb25zdCBnZXREZWZhdWx0TWlkZGxld2FyZSA9IGJ1aWxkR2V0RGVmYXVsdE1pZGRsZXdhcmUoKTtcbiAgY29uc3Qge1xuICAgIHJlZHVjZXIgPSB2b2lkIDAsXG4gICAgbWlkZGxld2FyZSxcbiAgICBkZXZUb29scyA9IHRydWUsXG4gICAgcHJlbG9hZGVkU3RhdGUgPSB2b2lkIDAsXG4gICAgZW5oYW5jZXJzID0gdm9pZCAwXG4gIH0gPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgcm9vdFJlZHVjZXI7XG4gIGlmICh0eXBlb2YgcmVkdWNlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcm9vdFJlZHVjZXIgPSByZWR1Y2VyO1xuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QyKHJlZHVjZXIpKSB7XG4gICAgcm9vdFJlZHVjZXIgPSBjb21iaW5lUmVkdWNlcnMocmVkdWNlcik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMSkgOiBcImByZWR1Y2VyYCBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LCBhbmQgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCBvZiBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIGNvbWJpbmVSZWR1Y2Vyc1wiKTtcbiAgfVxuICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgbWlkZGxld2FyZSAmJiB0eXBlb2YgbWlkZGxld2FyZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMikgOiBcImBtaWRkbGV3YXJlYCBmaWVsZCBtdXN0IGJlIGEgY2FsbGJhY2tcIik7XG4gIH1cbiAgbGV0IGZpbmFsTWlkZGxld2FyZTtcbiAgaWYgKHR5cGVvZiBtaWRkbGV3YXJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmaW5hbE1pZGRsZXdhcmUgPSBtaWRkbGV3YXJlKGdldERlZmF1bHRNaWRkbGV3YXJlKTtcbiAgICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgIUFycmF5LmlzQXJyYXkoZmluYWxNaWRkbGV3YXJlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMykgOiBcIndoZW4gdXNpbmcgYSBtaWRkbGV3YXJlIGJ1aWxkZXIgZnVuY3Rpb24sIGFuIGFycmF5IG9mIG1pZGRsZXdhcmUgbXVzdCBiZSByZXR1cm5lZFwiKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZmluYWxNaWRkbGV3YXJlID0gZ2V0RGVmYXVsdE1pZGRsZXdhcmUoKTtcbiAgfVxuICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgZmluYWxNaWRkbGV3YXJlLnNvbWUoKGl0ZW0pID0+IHR5cGVvZiBpdGVtICE9PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNCkgOiBcImVhY2ggbWlkZGxld2FyZSBwcm92aWRlZCB0byBjb25maWd1cmVTdG9yZSBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gIH1cbiAgbGV0IGZpbmFsQ29tcG9zZSA9IGNvbXBvc2UyO1xuICBpZiAoZGV2VG9vbHMpIHtcbiAgICBmaW5hbENvbXBvc2UgPSBjb21wb3NlV2l0aERldlRvb2xzKHtcbiAgICAgIC8vIEVuYWJsZSBjYXB0dXJlIG9mIHN0YWNrIHRyYWNlcyBmb3IgZGlzcGF0Y2hlZCBSZWR1eCBhY3Rpb25zXG4gICAgICB0cmFjZTogIUlTX1BST0RVQ1RJT04sXG4gICAgICAuLi50eXBlb2YgZGV2VG9vbHMgPT09IFwib2JqZWN0XCIgJiYgZGV2VG9vbHNcbiAgICB9KTtcbiAgfVxuICBjb25zdCBtaWRkbGV3YXJlRW5oYW5jZXIgPSBhcHBseU1pZGRsZXdhcmUoLi4uZmluYWxNaWRkbGV3YXJlKTtcbiAgY29uc3QgZ2V0RGVmYXVsdEVuaGFuY2VycyA9IGJ1aWxkR2V0RGVmYXVsdEVuaGFuY2VycyhtaWRkbGV3YXJlRW5oYW5jZXIpO1xuICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgZW5oYW5jZXJzICYmIHR5cGVvZiBlbmhhbmNlcnMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDUpIDogXCJgZW5oYW5jZXJzYCBmaWVsZCBtdXN0IGJlIGEgY2FsbGJhY2tcIik7XG4gIH1cbiAgbGV0IHN0b3JlRW5oYW5jZXJzID0gdHlwZW9mIGVuaGFuY2VycyA9PT0gXCJmdW5jdGlvblwiID8gZW5oYW5jZXJzKGdldERlZmF1bHRFbmhhbmNlcnMpIDogZ2V0RGVmYXVsdEVuaGFuY2VycygpO1xuICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgIUFycmF5LmlzQXJyYXkoc3RvcmVFbmhhbmNlcnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNikgOiBcImBlbmhhbmNlcnNgIGNhbGxiYWNrIG11c3QgcmV0dXJuIGFuIGFycmF5XCIpO1xuICB9XG4gIGlmICghSVNfUFJPRFVDVElPTiAmJiBzdG9yZUVuaGFuY2Vycy5zb21lKChpdGVtKSA9PiB0eXBlb2YgaXRlbSAhPT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDcpIDogXCJlYWNoIGVuaGFuY2VyIHByb3ZpZGVkIHRvIGNvbmZpZ3VyZVN0b3JlIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgfVxuICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgZmluYWxNaWRkbGV3YXJlLmxlbmd0aCAmJiAhc3RvcmVFbmhhbmNlcnMuaW5jbHVkZXMobWlkZGxld2FyZUVuaGFuY2VyKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJtaWRkbGV3YXJlcyB3ZXJlIHByb3ZpZGVkLCBidXQgbWlkZGxld2FyZSBlbmhhbmNlciB3YXMgbm90IGluY2x1ZGVkIGluIGZpbmFsIGVuaGFuY2VycyAtIG1ha2Ugc3VyZSB0byBjYWxsIGBnZXREZWZhdWx0RW5oYW5jZXJzYFwiKTtcbiAgfVxuICBjb25zdCBjb21wb3NlZEVuaGFuY2VyID0gZmluYWxDb21wb3NlKC4uLnN0b3JlRW5oYW5jZXJzKTtcbiAgcmV0dXJuIGNyZWF0ZVN0b3JlKHJvb3RSZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgY29tcG9zZWRFbmhhbmNlcik7XG59XG5cbi8vIHNyYy9jcmVhdGVSZWR1Y2VyLnRzXG5pbXBvcnQgeyBwcm9kdWNlIGFzIGNyZWF0ZU5leHRTdGF0ZTIsIGlzRHJhZnQgYXMgaXNEcmFmdDIsIGlzRHJhZnRhYmxlIGFzIGlzRHJhZnRhYmxlMiB9IGZyb20gXCJpbW1lclwiO1xuXG4vLyBzcmMvbWFwQnVpbGRlcnMudHNcbmZ1bmN0aW9uIGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrKGJ1aWxkZXJDYWxsYmFjaykge1xuICBjb25zdCBhY3Rpb25zTWFwID0ge307XG4gIGNvbnN0IGFjdGlvbk1hdGNoZXJzID0gW107XG4gIGxldCBkZWZhdWx0Q2FzZVJlZHVjZXI7XG4gIGNvbnN0IGJ1aWxkZXIgPSB7XG4gICAgYWRkQ2FzZSh0eXBlT3JBY3Rpb25DcmVhdG9yLCByZWR1Y2VyKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGlmIChhY3Rpb25NYXRjaGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjYpIDogXCJgYnVpbGRlci5hZGRDYXNlYCBzaG91bGQgb25seSBiZSBjYWxsZWQgYmVmb3JlIGNhbGxpbmcgYGJ1aWxkZXIuYWRkTWF0Y2hlcmBcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI3KSA6IFwiYGJ1aWxkZXIuYWRkQ2FzZWAgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBidWlsZGVyLmFkZERlZmF1bHRDYXNlYFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiB0eXBlT3JBY3Rpb25DcmVhdG9yID09PSBcInN0cmluZ1wiID8gdHlwZU9yQWN0aW9uQ3JlYXRvciA6IHR5cGVPckFjdGlvbkNyZWF0b3IudHlwZTtcbiAgICAgIGlmICghdHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyOCkgOiBcImBidWlsZGVyLmFkZENhc2VgIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBhbiBlbXB0eSBhY3Rpb24gdHlwZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlIGluIGFjdGlvbnNNYXApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjkpIDogYFxcYGJ1aWxkZXIuYWRkQ2FzZVxcYCBjYW5ub3QgYmUgY2FsbGVkIHdpdGggdHdvIHJlZHVjZXJzIGZvciB0aGUgc2FtZSBhY3Rpb24gdHlwZSAnJHt0eXBlfSdgKTtcbiAgICAgIH1cbiAgICAgIGFjdGlvbnNNYXBbdHlwZV0gPSByZWR1Y2VyO1xuICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgfSxcbiAgICBhZGRNYXRjaGVyKG1hdGNoZXIsIHJlZHVjZXIpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMwKSA6IFwiYGJ1aWxkZXIuYWRkTWF0Y2hlcmAgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBidWlsZGVyLmFkZERlZmF1bHRDYXNlYFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWN0aW9uTWF0Y2hlcnMucHVzaCh7XG4gICAgICAgIG1hdGNoZXIsXG4gICAgICAgIHJlZHVjZXJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGJ1aWxkZXI7XG4gICAgfSxcbiAgICBhZGREZWZhdWx0Q2FzZShyZWR1Y2VyKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGlmIChkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMSkgOiBcImBidWlsZGVyLmFkZERlZmF1bHRDYXNlYCBjYW4gb25seSBiZSBjYWxsZWQgb25jZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVmYXVsdENhc2VSZWR1Y2VyID0gcmVkdWNlcjtcbiAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH1cbiAgfTtcbiAgYnVpbGRlckNhbGxiYWNrKGJ1aWxkZXIpO1xuICByZXR1cm4gW2FjdGlvbnNNYXAsIGFjdGlvbk1hdGNoZXJzLCBkZWZhdWx0Q2FzZVJlZHVjZXJdO1xufVxuXG4vLyBzcmMvY3JlYXRlUmVkdWNlci50c1xuZnVuY3Rpb24gaXNTdGF0ZUZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWR1Y2VyKGluaXRpYWxTdGF0ZSwgbWFwT3JCdWlsZGVyQ2FsbGJhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICh0eXBlb2YgbWFwT3JCdWlsZGVyQ2FsbGJhY2sgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDgpIDogXCJUaGUgb2JqZWN0IG5vdGF0aW9uIGZvciBgY3JlYXRlUmVkdWNlcmAgaGFzIGJlZW4gcmVtb3ZlZC4gUGxlYXNlIHVzZSB0aGUgJ2J1aWxkZXIgY2FsbGJhY2snIG5vdGF0aW9uIGluc3RlYWQ6IGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvYXBpL2NyZWF0ZVJlZHVjZXJcIik7XG4gICAgfVxuICB9XG4gIGxldCBbYWN0aW9uc01hcCwgZmluYWxBY3Rpb25NYXRjaGVycywgZmluYWxEZWZhdWx0Q2FzZVJlZHVjZXJdID0gZXhlY3V0ZVJlZHVjZXJCdWlsZGVyQ2FsbGJhY2sobWFwT3JCdWlsZGVyQ2FsbGJhY2spO1xuICBsZXQgZ2V0SW5pdGlhbFN0YXRlO1xuICBpZiAoaXNTdGF0ZUZ1bmN0aW9uKGluaXRpYWxTdGF0ZSkpIHtcbiAgICBnZXRJbml0aWFsU3RhdGUgPSAoKSA9PiBmcmVlemVEcmFmdGFibGUoaW5pdGlhbFN0YXRlKCkpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGZyb3plbkluaXRpYWxTdGF0ZSA9IGZyZWV6ZURyYWZ0YWJsZShpbml0aWFsU3RhdGUpO1xuICAgIGdldEluaXRpYWxTdGF0ZSA9ICgpID0+IGZyb3plbkluaXRpYWxTdGF0ZTtcbiAgfVxuICBmdW5jdGlvbiByZWR1Y2VyKHN0YXRlID0gZ2V0SW5pdGlhbFN0YXRlKCksIGFjdGlvbikge1xuICAgIGxldCBjYXNlUmVkdWNlcnMgPSBbYWN0aW9uc01hcFthY3Rpb24udHlwZV0sIC4uLmZpbmFsQWN0aW9uTWF0Y2hlcnMuZmlsdGVyKCh7XG4gICAgICBtYXRjaGVyXG4gICAgfSkgPT4gbWF0Y2hlcihhY3Rpb24pKS5tYXAoKHtcbiAgICAgIHJlZHVjZXI6IHJlZHVjZXIyXG4gICAgfSkgPT4gcmVkdWNlcjIpXTtcbiAgICBpZiAoY2FzZVJlZHVjZXJzLmZpbHRlcigoY3IpID0+ICEhY3IpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY2FzZVJlZHVjZXJzID0gW2ZpbmFsRGVmYXVsdENhc2VSZWR1Y2VyXTtcbiAgICB9XG4gICAgcmV0dXJuIGNhc2VSZWR1Y2Vycy5yZWR1Y2UoKHByZXZpb3VzU3RhdGUsIGNhc2VSZWR1Y2VyKSA9PiB7XG4gICAgICBpZiAoY2FzZVJlZHVjZXIpIHtcbiAgICAgICAgaWYgKGlzRHJhZnQyKHByZXZpb3VzU3RhdGUpKSB7XG4gICAgICAgICAgY29uc3QgZHJhZnQgPSBwcmV2aW91c1N0YXRlO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNhc2VSZWR1Y2VyKGRyYWZ0LCBhY3Rpb24pO1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzRHJhZnRhYmxlMihwcmV2aW91c1N0YXRlKSkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNhc2VSZWR1Y2VyKHByZXZpb3VzU3RhdGUsIGFjdGlvbik7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gcHJldmlvdXNTdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDkpIDogXCJBIGNhc2UgcmVkdWNlciBvbiBhIG5vbi1kcmFmdGFibGUgdmFsdWUgbXVzdCBub3QgcmV0dXJuIHVuZGVmaW5lZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlTmV4dFN0YXRlMihwcmV2aW91c1N0YXRlLCAoZHJhZnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjYXNlUmVkdWNlcihkcmFmdCwgYWN0aW9uKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XG4gICAgfSwgc3RhdGUpO1xuICB9XG4gIHJlZHVjZXIuZ2V0SW5pdGlhbFN0YXRlID0gZ2V0SW5pdGlhbFN0YXRlO1xuICByZXR1cm4gcmVkdWNlcjtcbn1cblxuLy8gc3JjL25hbm9pZC50c1xudmFyIHVybEFscGhhYmV0ID0gXCJNb2R1bGVTeW1iaGFzT3duUHItMDEyMzQ1Njc4OUFCQ0RFRkdITlJWZmdjdGlVdnpfS3FZVEprTHhwWlhJalFXXCI7XG52YXIgbmFub2lkID0gKHNpemUgPSAyMSkgPT4ge1xuICBsZXQgaWQgPSBcIlwiO1xuICBsZXQgaSA9IHNpemU7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZCArPSB1cmxBbHBoYWJldFtNYXRoLnJhbmRvbSgpICogNjQgfCAwXTtcbiAgfVxuICByZXR1cm4gaWQ7XG59O1xuXG4vLyBzcmMvbWF0Y2hlcnMudHNcbnZhciBtYXRjaGVzID0gKG1hdGNoZXIsIGFjdGlvbikgPT4ge1xuICBpZiAoaGFzTWF0Y2hGdW5jdGlvbihtYXRjaGVyKSkge1xuICAgIHJldHVybiBtYXRjaGVyLm1hdGNoKGFjdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1hdGNoZXIoYWN0aW9uKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGlzQW55T2YoLi4ubWF0Y2hlcnMpIHtcbiAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICByZXR1cm4gbWF0Y2hlcnMuc29tZSgobWF0Y2hlcikgPT4gbWF0Y2hlcyhtYXRjaGVyLCBhY3Rpb24pKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQWxsT2YoLi4ubWF0Y2hlcnMpIHtcbiAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICByZXR1cm4gbWF0Y2hlcnMuZXZlcnkoKG1hdGNoZXIpID0+IG1hdGNoZXMobWF0Y2hlciwgYWN0aW9uKSk7XG4gIH07XG59XG5mdW5jdGlvbiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIHZhbGlkU3RhdHVzKSB7XG4gIGlmICghYWN0aW9uIHx8ICFhY3Rpb24ubWV0YSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGhhc1ZhbGlkUmVxdWVzdElkID0gdHlwZW9mIGFjdGlvbi5tZXRhLnJlcXVlc3RJZCA9PT0gXCJzdHJpbmdcIjtcbiAgY29uc3QgaGFzVmFsaWRSZXF1ZXN0U3RhdHVzID0gdmFsaWRTdGF0dXMuaW5kZXhPZihhY3Rpb24ubWV0YS5yZXF1ZXN0U3RhdHVzKSA+IC0xO1xuICByZXR1cm4gaGFzVmFsaWRSZXF1ZXN0SWQgJiYgaGFzVmFsaWRSZXF1ZXN0U3RhdHVzO1xufVxuZnVuY3Rpb24gaXNBc3luY1RodW5rQXJyYXkoYSkge1xuICByZXR1cm4gdHlwZW9mIGFbMF0gPT09IFwiZnVuY3Rpb25cIiAmJiBcInBlbmRpbmdcIiBpbiBhWzBdICYmIFwiZnVsZmlsbGVkXCIgaW4gYVswXSAmJiBcInJlamVjdGVkXCIgaW4gYVswXTtcbn1cbmZ1bmN0aW9uIGlzUGVuZGluZyguLi5hc3luY1RodW5rcykge1xuICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIChhY3Rpb24pID0+IGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicGVuZGluZ1wiXSk7XG4gIH1cbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcbiAgICByZXR1cm4gaXNQZW5kaW5nKCkoYXN5bmNUaHVua3NbMF0pO1xuICB9XG4gIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgY29uc3QgbWF0Y2hlcnMgPSBhc3luY1RodW5rcy5tYXAoKGFzeW5jVGh1bmspID0+IGFzeW5jVGh1bmsucGVuZGluZyk7XG4gICAgY29uc3QgY29tYmluZWRNYXRjaGVyID0gaXNBbnlPZiguLi5tYXRjaGVycyk7XG4gICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xuICB9O1xufVxuZnVuY3Rpb24gaXNSZWplY3RlZCguLi5hc3luY1RodW5rcykge1xuICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIChhY3Rpb24pID0+IGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicmVqZWN0ZWRcIl0pO1xuICB9XG4gIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XG4gICAgcmV0dXJuIGlzUmVqZWN0ZWQoKShhc3luY1RodW5rc1swXSk7XG4gIH1cbiAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICBjb25zdCBtYXRjaGVycyA9IGFzeW5jVGh1bmtzLm1hcCgoYXN5bmNUaHVuaykgPT4gYXN5bmNUaHVuay5yZWplY3RlZCk7XG4gICAgY29uc3QgY29tYmluZWRNYXRjaGVyID0gaXNBbnlPZiguLi5tYXRjaGVycyk7XG4gICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xuICB9O1xufVxuZnVuY3Rpb24gaXNSZWplY3RlZFdpdGhWYWx1ZSguLi5hc3luY1RodW5rcykge1xuICBjb25zdCBoYXNGbGFnID0gKGFjdGlvbikgPT4ge1xuICAgIHJldHVybiBhY3Rpb24gJiYgYWN0aW9uLm1ldGEgJiYgYWN0aW9uLm1ldGEucmVqZWN0ZWRXaXRoVmFsdWU7XG4gIH07XG4gIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gKGFjdGlvbikgPT4ge1xuICAgICAgY29uc3QgY29tYmluZWRNYXRjaGVyID0gaXNBbGxPZihpc1JlamVjdGVkKC4uLmFzeW5jVGh1bmtzKSwgaGFzRmxhZyk7XG4gICAgICByZXR1cm4gY29tYmluZWRNYXRjaGVyKGFjdGlvbik7XG4gICAgfTtcbiAgfVxuICBpZiAoIWlzQXN5bmNUaHVua0FycmF5KGFzeW5jVGh1bmtzKSkge1xuICAgIHJldHVybiBpc1JlamVjdGVkV2l0aFZhbHVlKCkoYXN5bmNUaHVua3NbMF0pO1xuICB9XG4gIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgY29uc3QgY29tYmluZWRNYXRjaGVyID0gaXNBbGxPZihpc1JlamVjdGVkKC4uLmFzeW5jVGh1bmtzKSwgaGFzRmxhZyk7XG4gICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xuICB9O1xufVxuZnVuY3Rpb24gaXNGdWxmaWxsZWQoLi4uYXN5bmNUaHVua3MpIHtcbiAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAoYWN0aW9uKSA9PiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcImZ1bGZpbGxlZFwiXSk7XG4gIH1cbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcbiAgICByZXR1cm4gaXNGdWxmaWxsZWQoKShhc3luY1RodW5rc1swXSk7XG4gIH1cbiAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICBjb25zdCBtYXRjaGVycyA9IGFzeW5jVGh1bmtzLm1hcCgoYXN5bmNUaHVuaykgPT4gYXN5bmNUaHVuay5mdWxmaWxsZWQpO1xuICAgIGNvbnN0IGNvbWJpbmVkTWF0Y2hlciA9IGlzQW55T2YoLi4ubWF0Y2hlcnMpO1xuICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQXN5bmNUaHVua0FjdGlvbiguLi5hc3luY1RodW5rcykge1xuICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIChhY3Rpb24pID0+IGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicGVuZGluZ1wiLCBcImZ1bGZpbGxlZFwiLCBcInJlamVjdGVkXCJdKTtcbiAgfVxuICBpZiAoIWlzQXN5bmNUaHVua0FycmF5KGFzeW5jVGh1bmtzKSkge1xuICAgIHJldHVybiBpc0FzeW5jVGh1bmtBY3Rpb24oKShhc3luY1RodW5rc1swXSk7XG4gIH1cbiAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICBjb25zdCBtYXRjaGVycyA9IFtdO1xuICAgIGZvciAoY29uc3QgYXN5bmNUaHVuayBvZiBhc3luY1RodW5rcykge1xuICAgICAgbWF0Y2hlcnMucHVzaChhc3luY1RodW5rLnBlbmRpbmcsIGFzeW5jVGh1bmsucmVqZWN0ZWQsIGFzeW5jVGh1bmsuZnVsZmlsbGVkKTtcbiAgICB9XG4gICAgY29uc3QgY29tYmluZWRNYXRjaGVyID0gaXNBbnlPZiguLi5tYXRjaGVycyk7XG4gICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xuICB9O1xufVxuXG4vLyBzcmMvY3JlYXRlQXN5bmNUaHVuay50c1xudmFyIGNvbW1vblByb3BlcnRpZXMgPSBbXCJuYW1lXCIsIFwibWVzc2FnZVwiLCBcInN0YWNrXCIsIFwiY29kZVwiXTtcbnZhciBSZWplY3RXaXRoVmFsdWUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHBheWxvYWQsIG1ldGEpIHtcbiAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgIHRoaXMubWV0YSA9IG1ldGE7XG4gIH1cbiAgLypcbiAgdHlwZS1vbmx5IHByb3BlcnR5IHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gUmVqZWN0V2l0aFZhbHVlIGFuZCBGdWxmaWxsV2l0aE1ldGFcbiAgZG9lcyBub3QgZXhpc3QgYXQgcnVudGltZVxuICAqL1xuICBfdHlwZTtcbn07XG52YXIgRnVsZmlsbFdpdGhNZXRhID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihwYXlsb2FkLCBtZXRhKSB7XG4gICAgdGhpcy5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICB0aGlzLm1ldGEgPSBtZXRhO1xuICB9XG4gIC8qXG4gIHR5cGUtb25seSBwcm9wZXJ0eSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIFJlamVjdFdpdGhWYWx1ZSBhbmQgRnVsZmlsbFdpdGhNZXRhXG4gIGRvZXMgbm90IGV4aXN0IGF0IHJ1bnRpbWVcbiAgKi9cbiAgX3R5cGU7XG59O1xudmFyIG1pbmlTZXJpYWxpemVFcnJvciA9ICh2YWx1ZSkgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgY29uc3Qgc2ltcGxlRXJyb3IgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIGNvbW1vblByb3BlcnRpZXMpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWVbcHJvcGVydHldID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHNpbXBsZUVycm9yW3Byb3BlcnR5XSA9IHZhbHVlW3Byb3BlcnR5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNpbXBsZUVycm9yO1xuICB9XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZTogU3RyaW5nKHZhbHVlKVxuICB9O1xufTtcbnZhciBjcmVhdGVBc3luY1RodW5rID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gIGZ1bmN0aW9uIGNyZWF0ZUFzeW5jVGh1bmsyKHR5cGVQcmVmaXgsIHBheWxvYWRDcmVhdG9yLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZnVsZmlsbGVkID0gY3JlYXRlQWN0aW9uKHR5cGVQcmVmaXggKyBcIi9mdWxmaWxsZWRcIiwgKHBheWxvYWQsIHJlcXVlc3RJZCwgYXJnLCBtZXRhKSA9PiAoe1xuICAgICAgcGF5bG9hZCxcbiAgICAgIG1ldGE6IHtcbiAgICAgICAgLi4ubWV0YSB8fCB7fSxcbiAgICAgICAgYXJnLFxuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIHJlcXVlc3RTdGF0dXM6IFwiZnVsZmlsbGVkXCJcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgY29uc3QgcGVuZGluZyA9IGNyZWF0ZUFjdGlvbih0eXBlUHJlZml4ICsgXCIvcGVuZGluZ1wiLCAocmVxdWVzdElkLCBhcmcsIG1ldGEpID0+ICh7XG4gICAgICBwYXlsb2FkOiB2b2lkIDAsXG4gICAgICBtZXRhOiB7XG4gICAgICAgIC4uLm1ldGEgfHwge30sXG4gICAgICAgIGFyZyxcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICByZXF1ZXN0U3RhdHVzOiBcInBlbmRpbmdcIlxuICAgICAgfVxuICAgIH0pKTtcbiAgICBjb25zdCByZWplY3RlZCA9IGNyZWF0ZUFjdGlvbih0eXBlUHJlZml4ICsgXCIvcmVqZWN0ZWRcIiwgKGVycm9yLCByZXF1ZXN0SWQsIGFyZywgcGF5bG9hZCwgbWV0YSkgPT4gKHtcbiAgICAgIHBheWxvYWQsXG4gICAgICBlcnJvcjogKG9wdGlvbnMgJiYgb3B0aW9ucy5zZXJpYWxpemVFcnJvciB8fCBtaW5pU2VyaWFsaXplRXJyb3IpKGVycm9yIHx8IFwiUmVqZWN0ZWRcIiksXG4gICAgICBtZXRhOiB7XG4gICAgICAgIC4uLm1ldGEgfHwge30sXG4gICAgICAgIGFyZyxcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICByZWplY3RlZFdpdGhWYWx1ZTogISFwYXlsb2FkLFxuICAgICAgICByZXF1ZXN0U3RhdHVzOiBcInJlamVjdGVkXCIsXG4gICAgICAgIGFib3J0ZWQ6IGVycm9yPy5uYW1lID09PSBcIkFib3J0RXJyb3JcIixcbiAgICAgICAgY29uZGl0aW9uOiBlcnJvcj8ubmFtZSA9PT0gXCJDb25kaXRpb25FcnJvclwiXG4gICAgICB9XG4gICAgfSkpO1xuICAgIGZ1bmN0aW9uIGFjdGlvbkNyZWF0b3IoYXJnKSB7XG4gICAgICByZXR1cm4gKGRpc3BhdGNoLCBnZXRTdGF0ZSwgZXh0cmEpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gb3B0aW9ucz8uaWRHZW5lcmF0b3IgPyBvcHRpb25zLmlkR2VuZXJhdG9yKGFyZykgOiBuYW5vaWQoKTtcbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBsZXQgYWJvcnRIYW5kbGVyO1xuICAgICAgICBsZXQgYWJvcnRSZWFzb247XG4gICAgICAgIGZ1bmN0aW9uIGFib3J0KHJlYXNvbikge1xuICAgICAgICAgIGFib3J0UmVhc29uID0gcmVhc29uO1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsZXQgZmluYWxBY3Rpb247XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBjb25kaXRpb25SZXN1bHQgPSBvcHRpb25zPy5jb25kaXRpb24/LihhcmcsIHtcbiAgICAgICAgICAgICAgZ2V0U3RhdGUsXG4gICAgICAgICAgICAgIGV4dHJhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpc1RoZW5hYmxlKGNvbmRpdGlvblJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgY29uZGl0aW9uUmVzdWx0ID0gYXdhaXQgY29uZGl0aW9uUmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmRpdGlvblJlc3VsdCA9PT0gZmFsc2UgfHwgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkNvbmRpdGlvbkVycm9yXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJBYm9ydGVkIGR1ZSB0byBjb25kaXRpb24gY2FsbGJhY2sgcmV0dXJuaW5nIGZhbHNlLlwiXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhYm9ydGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgYWJvcnRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICBuYW1lOiBcIkFib3J0RXJyb3JcIixcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGFib3J0UmVhc29uIHx8IFwiQWJvcnRlZFwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0SGFuZGxlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRpc3BhdGNoKHBlbmRpbmcocmVxdWVzdElkLCBhcmcsIG9wdGlvbnM/LmdldFBlbmRpbmdNZXRhPy4oe1xuICAgICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgIGFyZ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBnZXRTdGF0ZSxcbiAgICAgICAgICAgICAgZXh0cmFcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICBmaW5hbEFjdGlvbiA9IGF3YWl0IFByb21pc2UucmFjZShbYWJvcnRlZFByb21pc2UsIFByb21pc2UucmVzb2x2ZShwYXlsb2FkQ3JlYXRvcihhcmcsIHtcbiAgICAgICAgICAgICAgZGlzcGF0Y2gsXG4gICAgICAgICAgICAgIGdldFN0YXRlLFxuICAgICAgICAgICAgICBleHRyYSxcbiAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgICAgIGFib3J0LFxuICAgICAgICAgICAgICByZWplY3RXaXRoVmFsdWU6ICh2YWx1ZSwgbWV0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVqZWN0V2l0aFZhbHVlKHZhbHVlLCBtZXRhKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZnVsZmlsbFdpdGhWYWx1ZTogKHZhbHVlLCBtZXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGdWxmaWxsV2l0aE1ldGEodmFsdWUsIG1ldGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBSZWplY3RXaXRoVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyByZXN1bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEZ1bGZpbGxXaXRoTWV0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdWxmaWxsZWQocmVzdWx0LnBheWxvYWQsIHJlcXVlc3RJZCwgYXJnLCByZXN1bHQubWV0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bGZpbGxlZChyZXN1bHQsIHJlcXVlc3RJZCwgYXJnKTtcbiAgICAgICAgICAgIH0pXSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBmaW5hbEFjdGlvbiA9IGVyciBpbnN0YW5jZW9mIFJlamVjdFdpdGhWYWx1ZSA/IHJlamVjdGVkKG51bGwsIHJlcXVlc3RJZCwgYXJnLCBlcnIucGF5bG9hZCwgZXJyLm1ldGEpIDogcmVqZWN0ZWQoZXJyLCByZXF1ZXN0SWQsIGFyZyk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChhYm9ydEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnRIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc2tpcERpc3BhdGNoID0gb3B0aW9ucyAmJiAhb3B0aW9ucy5kaXNwYXRjaENvbmRpdGlvblJlamVjdGlvbiAmJiByZWplY3RlZC5tYXRjaChmaW5hbEFjdGlvbikgJiYgZmluYWxBY3Rpb24ubWV0YS5jb25kaXRpb247XG4gICAgICAgICAgaWYgKCFza2lwRGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKGZpbmFsQWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZpbmFsQWN0aW9uO1xuICAgICAgICB9KCk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHByb21pc2UsIHtcbiAgICAgICAgICBhYm9ydCxcbiAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgYXJnLFxuICAgICAgICAgIHVud3JhcCgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4odW53cmFwUmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYWN0aW9uQ3JlYXRvciwge1xuICAgICAgcGVuZGluZyxcbiAgICAgIHJlamVjdGVkLFxuICAgICAgZnVsZmlsbGVkLFxuICAgICAgc2V0dGxlZDogaXNBbnlPZihyZWplY3RlZCwgZnVsZmlsbGVkKSxcbiAgICAgIHR5cGVQcmVmaXhcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVBc3luY1RodW5rMi53aXRoVHlwZXMgPSAoKSA9PiBjcmVhdGVBc3luY1RodW5rMjtcbiAgcmV0dXJuIGNyZWF0ZUFzeW5jVGh1bmsyO1xufSkoKTtcbmZ1bmN0aW9uIHVud3JhcFJlc3VsdChhY3Rpb24pIHtcbiAgaWYgKGFjdGlvbi5tZXRhICYmIGFjdGlvbi5tZXRhLnJlamVjdGVkV2l0aFZhbHVlKSB7XG4gICAgdGhyb3cgYWN0aW9uLnBheWxvYWQ7XG4gIH1cbiAgaWYgKGFjdGlvbi5lcnJvcikge1xuICAgIHRocm93IGFjdGlvbi5lcnJvcjtcbiAgfVxuICByZXR1cm4gYWN0aW9uLnBheWxvYWQ7XG59XG5mdW5jdGlvbiBpc1RoZW5hYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuLy8gc3JjL2NyZWF0ZVNsaWNlLnRzXG52YXIgYXN5bmNUaHVua1N5bWJvbCA9IFN5bWJvbC5mb3IoXCJydGstc2xpY2UtY3JlYXRlYXN5bmN0aHVua1wiKTtcbnZhciBhc3luY1RodW5rQ3JlYXRvciA9IHtcbiAgW2FzeW5jVGh1bmtTeW1ib2xdOiBjcmVhdGVBc3luY1RodW5rXG59O1xudmFyIFJlZHVjZXJUeXBlID0gLyogQF9fUFVSRV9fICovICgoUmVkdWNlclR5cGUyKSA9PiB7XG4gIFJlZHVjZXJUeXBlMltcInJlZHVjZXJcIl0gPSBcInJlZHVjZXJcIjtcbiAgUmVkdWNlclR5cGUyW1wicmVkdWNlcldpdGhQcmVwYXJlXCJdID0gXCJyZWR1Y2VyV2l0aFByZXBhcmVcIjtcbiAgUmVkdWNlclR5cGUyW1wiYXN5bmNUaHVua1wiXSA9IFwiYXN5bmNUaHVua1wiO1xuICByZXR1cm4gUmVkdWNlclR5cGUyO1xufSkoUmVkdWNlclR5cGUgfHwge30pO1xuZnVuY3Rpb24gZ2V0VHlwZShzbGljZSwgYWN0aW9uS2V5KSB7XG4gIHJldHVybiBgJHtzbGljZX0vJHthY3Rpb25LZXl9YDtcbn1cbmZ1bmN0aW9uIGJ1aWxkQ3JlYXRlU2xpY2Uoe1xuICBjcmVhdG9yc1xufSA9IHt9KSB7XG4gIGNvbnN0IGNBVCA9IGNyZWF0b3JzPy5hc3luY1RodW5rPy5bYXN5bmNUaHVua1N5bWJvbF07XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVTbGljZTIob3B0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWUsXG4gICAgICByZWR1Y2VyUGF0aCA9IG5hbWVcbiAgICB9ID0gb3B0aW9ucztcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDExKSA6IFwiYG5hbWVgIGlzIGEgcmVxdWlyZWQgb3B0aW9uIGZvciBjcmVhdGVTbGljZVwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgIGlmIChvcHRpb25zLmluaXRpYWxTdGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJZb3UgbXVzdCBwcm92aWRlIGFuIGBpbml0aWFsU3RhdGVgIHZhbHVlIHRoYXQgaXMgbm90IGB1bmRlZmluZWRgLiBZb3UgbWF5IGhhdmUgbWlzc3BlbGxlZCBgaW5pdGlhbFN0YXRlYFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVkdWNlcnMgPSAodHlwZW9mIG9wdGlvbnMucmVkdWNlcnMgPT09IFwiZnVuY3Rpb25cIiA/IG9wdGlvbnMucmVkdWNlcnMoYnVpbGRSZWR1Y2VyQ3JlYXRvcnMoKSkgOiBvcHRpb25zLnJlZHVjZXJzKSB8fCB7fTtcbiAgICBjb25zdCByZWR1Y2VyTmFtZXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIHNsaWNlQ2FzZVJlZHVjZXJzQnlOYW1lOiB7fSxcbiAgICAgIHNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlOiB7fSxcbiAgICAgIGFjdGlvbkNyZWF0b3JzOiB7fSxcbiAgICAgIHNsaWNlTWF0Y2hlcnM6IFtdXG4gICAgfTtcbiAgICBjb25zdCBjb250ZXh0TWV0aG9kcyA9IHtcbiAgICAgIGFkZENhc2UodHlwZU9yQWN0aW9uQ3JlYXRvciwgcmVkdWNlcjIpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiB0eXBlT3JBY3Rpb25DcmVhdG9yID09PSBcInN0cmluZ1wiID8gdHlwZU9yQWN0aW9uQ3JlYXRvciA6IHR5cGVPckFjdGlvbkNyZWF0b3IudHlwZTtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTIpIDogXCJgY29udGV4dC5hZGRDYXNlYCBjYW5ub3QgYmUgY2FsbGVkIHdpdGggYW4gZW1wdHkgYWN0aW9uIHR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgaW4gY29udGV4dC5zbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEzKSA6IFwiYGNvbnRleHQuYWRkQ2FzZWAgY2Fubm90IGJlIGNhbGxlZCB3aXRoIHR3byByZWR1Y2VycyBmb3IgdGhlIHNhbWUgYWN0aW9uIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5zbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZVt0eXBlXSA9IHJlZHVjZXIyO1xuICAgICAgICByZXR1cm4gY29udGV4dE1ldGhvZHM7XG4gICAgICB9LFxuICAgICAgYWRkTWF0Y2hlcihtYXRjaGVyLCByZWR1Y2VyMikge1xuICAgICAgICBjb250ZXh0LnNsaWNlTWF0Y2hlcnMucHVzaCh7XG4gICAgICAgICAgbWF0Y2hlcixcbiAgICAgICAgICByZWR1Y2VyOiByZWR1Y2VyMlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRNZXRob2RzO1xuICAgICAgfSxcbiAgICAgIGV4cG9zZUFjdGlvbihuYW1lMiwgYWN0aW9uQ3JlYXRvcikge1xuICAgICAgICBjb250ZXh0LmFjdGlvbkNyZWF0b3JzW25hbWUyXSA9IGFjdGlvbkNyZWF0b3I7XG4gICAgICAgIHJldHVybiBjb250ZXh0TWV0aG9kcztcbiAgICAgIH0sXG4gICAgICBleHBvc2VDYXNlUmVkdWNlcihuYW1lMiwgcmVkdWNlcjIpIHtcbiAgICAgICAgY29udGV4dC5zbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZVtuYW1lMl0gPSByZWR1Y2VyMjtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRNZXRob2RzO1xuICAgICAgfVxuICAgIH07XG4gICAgcmVkdWNlck5hbWVzLmZvckVhY2goKHJlZHVjZXJOYW1lKSA9PiB7XG4gICAgICBjb25zdCByZWR1Y2VyRGVmaW5pdGlvbiA9IHJlZHVjZXJzW3JlZHVjZXJOYW1lXTtcbiAgICAgIGNvbnN0IHJlZHVjZXJEZXRhaWxzID0ge1xuICAgICAgICByZWR1Y2VyTmFtZSxcbiAgICAgICAgdHlwZTogZ2V0VHlwZShuYW1lLCByZWR1Y2VyTmFtZSksXG4gICAgICAgIGNyZWF0ZU5vdGF0aW9uOiB0eXBlb2Ygb3B0aW9ucy5yZWR1Y2VycyA9PT0gXCJmdW5jdGlvblwiXG4gICAgICB9O1xuICAgICAgaWYgKGlzQXN5bmNUaHVua1NsaWNlUmVkdWNlckRlZmluaXRpb24ocmVkdWNlckRlZmluaXRpb24pKSB7XG4gICAgICAgIGhhbmRsZVRodW5rQ2FzZVJlZHVjZXJEZWZpbml0aW9uKHJlZHVjZXJEZXRhaWxzLCByZWR1Y2VyRGVmaW5pdGlvbiwgY29udGV4dE1ldGhvZHMsIGNBVCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVOb3JtYWxSZWR1Y2VyRGVmaW5pdGlvbihyZWR1Y2VyRGV0YWlscywgcmVkdWNlckRlZmluaXRpb24sIGNvbnRleHRNZXRob2RzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmdW5jdGlvbiBidWlsZFJlZHVjZXIoKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5leHRyYVJlZHVjZXJzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTQpIDogXCJUaGUgb2JqZWN0IG5vdGF0aW9uIGZvciBgY3JlYXRlU2xpY2UuZXh0cmFSZWR1Y2Vyc2AgaGFzIGJlZW4gcmVtb3ZlZC4gUGxlYXNlIHVzZSB0aGUgJ2J1aWxkZXIgY2FsbGJhY2snIG5vdGF0aW9uIGluc3RlYWQ6IGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvYXBpL2NyZWF0ZVNsaWNlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBbZXh0cmFSZWR1Y2VycyA9IHt9LCBhY3Rpb25NYXRjaGVycyA9IFtdLCBkZWZhdWx0Q2FzZVJlZHVjZXIgPSB2b2lkIDBdID0gdHlwZW9mIG9wdGlvbnMuZXh0cmFSZWR1Y2VycyA9PT0gXCJmdW5jdGlvblwiID8gZXhlY3V0ZVJlZHVjZXJCdWlsZGVyQ2FsbGJhY2sob3B0aW9ucy5leHRyYVJlZHVjZXJzKSA6IFtvcHRpb25zLmV4dHJhUmVkdWNlcnNdO1xuICAgICAgY29uc3QgZmluYWxDYXNlUmVkdWNlcnMgPSB7XG4gICAgICAgIC4uLmV4dHJhUmVkdWNlcnMsXG4gICAgICAgIC4uLmNvbnRleHQuc2xpY2VDYXNlUmVkdWNlcnNCeVR5cGVcbiAgICAgIH07XG4gICAgICByZXR1cm4gY3JlYXRlUmVkdWNlcihvcHRpb25zLmluaXRpYWxTdGF0ZSwgKGJ1aWxkZXIpID0+IHtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIGZpbmFsQ2FzZVJlZHVjZXJzKSB7XG4gICAgICAgICAgYnVpbGRlci5hZGRDYXNlKGtleSwgZmluYWxDYXNlUmVkdWNlcnNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgc00gb2YgY29udGV4dC5zbGljZU1hdGNoZXJzKSB7XG4gICAgICAgICAgYnVpbGRlci5hZGRNYXRjaGVyKHNNLm1hdGNoZXIsIHNNLnJlZHVjZXIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IG0gb2YgYWN0aW9uTWF0Y2hlcnMpIHtcbiAgICAgICAgICBidWlsZGVyLmFkZE1hdGNoZXIobS5tYXRjaGVyLCBtLnJlZHVjZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcbiAgICAgICAgICBidWlsZGVyLmFkZERlZmF1bHRDYXNlKGRlZmF1bHRDYXNlUmVkdWNlcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3RTZWxmID0gKHN0YXRlKSA9PiBzdGF0ZTtcbiAgICBjb25zdCBpbmplY3RlZFNlbGVjdG9yQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGxldCBfcmVkdWNlcjtcbiAgICBmdW5jdGlvbiByZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgIGlmICghX3JlZHVjZXIpXG4gICAgICAgIF9yZWR1Y2VyID0gYnVpbGRSZWR1Y2VyKCk7XG4gICAgICByZXR1cm4gX3JlZHVjZXIoc3RhdGUsIGFjdGlvbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgICAgIGlmICghX3JlZHVjZXIpXG4gICAgICAgIF9yZWR1Y2VyID0gYnVpbGRSZWR1Y2VyKCk7XG4gICAgICByZXR1cm4gX3JlZHVjZXIuZ2V0SW5pdGlhbFN0YXRlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VTZWxlY3RvclByb3BzKHJlZHVjZXJQYXRoMiwgaW5qZWN0ZWQgPSBmYWxzZSkge1xuICAgICAgZnVuY3Rpb24gc2VsZWN0U2xpY2Uoc3RhdGUpIHtcbiAgICAgICAgbGV0IHNsaWNlU3RhdGUgPSBzdGF0ZVtyZWR1Y2VyUGF0aDJdO1xuICAgICAgICBpZiAodHlwZW9mIHNsaWNlU3RhdGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBpZiAoaW5qZWN0ZWQpIHtcbiAgICAgICAgICAgIHNsaWNlU3RhdGUgPSBnZXRJbml0aWFsU3RhdGUoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTUpIDogXCJzZWxlY3RTbGljZSByZXR1cm5lZCB1bmRlZmluZWQgZm9yIGFuIHVuaW5qZWN0ZWQgc2xpY2UgcmVkdWNlclwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNsaWNlU3RhdGU7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBnZXRTZWxlY3RvcnMoc2VsZWN0U3RhdGUgPSBzZWxlY3RTZWxmKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yQ2FjaGUgPSBlbXBsYWNlKGluamVjdGVkU2VsZWN0b3JDYWNoZSwgaW5qZWN0ZWQsIHtcbiAgICAgICAgICBpbnNlcnQ6ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZW1wbGFjZShzZWxlY3RvckNhY2hlLCBzZWxlY3RTdGF0ZSwge1xuICAgICAgICAgIGluc2VydDogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWFwID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lMiwgc2VsZWN0b3JdIG9mIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMuc2VsZWN0b3JzID8/IHt9KSkge1xuICAgICAgICAgICAgICBtYXBbbmFtZTJdID0gd3JhcFNlbGVjdG9yKHNlbGVjdG9yLCBzZWxlY3RTdGF0ZSwgZ2V0SW5pdGlhbFN0YXRlLCBpbmplY3RlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWR1Y2VyUGF0aDogcmVkdWNlclBhdGgyLFxuICAgICAgICBnZXRTZWxlY3RvcnMsXG4gICAgICAgIGdldCBzZWxlY3RvcnMoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldFNlbGVjdG9ycyhzZWxlY3RTbGljZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNlbGVjdFNsaWNlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzbGljZSA9IHtcbiAgICAgIG5hbWUsXG4gICAgICByZWR1Y2VyLFxuICAgICAgYWN0aW9uczogY29udGV4dC5hY3Rpb25DcmVhdG9ycyxcbiAgICAgIGNhc2VSZWR1Y2VyczogY29udGV4dC5zbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZSxcbiAgICAgIGdldEluaXRpYWxTdGF0ZSxcbiAgICAgIC4uLm1ha2VTZWxlY3RvclByb3BzKHJlZHVjZXJQYXRoKSxcbiAgICAgIGluamVjdEludG8oaW5qZWN0YWJsZSwge1xuICAgICAgICByZWR1Y2VyUGF0aDogcGF0aE9wdCxcbiAgICAgICAgLi4uY29uZmlnXG4gICAgICB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgbmV3UmVkdWNlclBhdGggPSBwYXRoT3B0ID8/IHJlZHVjZXJQYXRoO1xuICAgICAgICBpbmplY3RhYmxlLmluamVjdCh7XG4gICAgICAgICAgcmVkdWNlclBhdGg6IG5ld1JlZHVjZXJQYXRoLFxuICAgICAgICAgIHJlZHVjZXJcbiAgICAgICAgfSwgY29uZmlnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5zbGljZSxcbiAgICAgICAgICAuLi5tYWtlU2VsZWN0b3JQcm9wcyhuZXdSZWR1Y2VyUGF0aCwgdHJ1ZSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBzbGljZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHdyYXBTZWxlY3RvcihzZWxlY3Rvciwgc2VsZWN0U3RhdGUsIGdldEluaXRpYWxTdGF0ZSwgaW5qZWN0ZWQpIHtcbiAgZnVuY3Rpb24gd3JhcHBlcihyb290U3RhdGUsIC4uLmFyZ3MpIHtcbiAgICBsZXQgc2xpY2VTdGF0ZSA9IHNlbGVjdFN0YXRlKHJvb3RTdGF0ZSk7XG4gICAgaWYgKHR5cGVvZiBzbGljZVN0YXRlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAoaW5qZWN0ZWQpIHtcbiAgICAgICAgc2xpY2VTdGF0ZSA9IGdldEluaXRpYWxTdGF0ZSgpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTYpIDogXCJzZWxlY3RTdGF0ZSByZXR1cm5lZCB1bmRlZmluZWQgZm9yIGFuIHVuaW5qZWN0ZWQgc2xpY2UgcmVkdWNlclwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdG9yKHNsaWNlU3RhdGUsIC4uLmFyZ3MpO1xuICB9XG4gIHdyYXBwZXIudW53cmFwcGVkID0gc2VsZWN0b3I7XG4gIHJldHVybiB3cmFwcGVyO1xufVxudmFyIGNyZWF0ZVNsaWNlID0gYnVpbGRDcmVhdGVTbGljZSgpO1xuZnVuY3Rpb24gYnVpbGRSZWR1Y2VyQ3JlYXRvcnMoKSB7XG4gIGZ1bmN0aW9uIGFzeW5jVGh1bmsocGF5bG9hZENyZWF0b3IsIGNvbmZpZykge1xuICAgIHJldHVybiB7XG4gICAgICBfcmVkdWNlckRlZmluaXRpb25UeXBlOiBcImFzeW5jVGh1bmtcIiAvKiBhc3luY1RodW5rICovLFxuICAgICAgcGF5bG9hZENyZWF0b3IsXG4gICAgICAuLi5jb25maWdcbiAgICB9O1xuICB9XG4gIGFzeW5jVGh1bmsud2l0aFR5cGVzID0gKCkgPT4gYXN5bmNUaHVuaztcbiAgcmV0dXJuIHtcbiAgICByZWR1Y2VyKGNhc2VSZWR1Y2VyKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIC8vIGhhY2sgc28gdGhlIHdyYXBwaW5nIGZ1bmN0aW9uIGhhcyB0aGUgc2FtZSBuYW1lIGFzIHRoZSBvcmlnaW5hbFxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGNyZWF0ZSBhIHdyYXBwZXIgc28gdGhlIGByZWR1Y2VyRGVmaW5pdGlvblR5cGVgIGlzIG5vdCBhc3NpZ25lZCB0byB0aGUgb3JpZ2luYWxcbiAgICAgICAgW2Nhc2VSZWR1Y2VyLm5hbWVdKC4uLmFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gY2FzZVJlZHVjZXIoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1bY2FzZVJlZHVjZXIubmFtZV0sIHtcbiAgICAgICAgX3JlZHVjZXJEZWZpbml0aW9uVHlwZTogXCJyZWR1Y2VyXCIgLyogcmVkdWNlciAqL1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBwcmVwYXJlZFJlZHVjZXIocHJlcGFyZSwgcmVkdWNlcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX3JlZHVjZXJEZWZpbml0aW9uVHlwZTogXCJyZWR1Y2VyV2l0aFByZXBhcmVcIiAvKiByZWR1Y2VyV2l0aFByZXBhcmUgKi8sXG4gICAgICAgIHByZXBhcmUsXG4gICAgICAgIHJlZHVjZXJcbiAgICAgIH07XG4gICAgfSxcbiAgICBhc3luY1RodW5rXG4gIH07XG59XG5mdW5jdGlvbiBoYW5kbGVOb3JtYWxSZWR1Y2VyRGVmaW5pdGlvbih7XG4gIHR5cGUsXG4gIHJlZHVjZXJOYW1lLFxuICBjcmVhdGVOb3RhdGlvblxufSwgbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUsIGNvbnRleHQpIHtcbiAgbGV0IGNhc2VSZWR1Y2VyO1xuICBsZXQgcHJlcGFyZUNhbGxiYWNrO1xuICBpZiAoXCJyZWR1Y2VyXCIgaW4gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUpIHtcbiAgICBpZiAoY3JlYXRlTm90YXRpb24gJiYgIWlzQ2FzZVJlZHVjZXJXaXRoUHJlcGFyZURlZmluaXRpb24obWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNykgOiBcIlBsZWFzZSB1c2UgdGhlIGBjcmVhdGUucHJlcGFyZWRSZWR1Y2VyYCBub3RhdGlvbiBmb3IgcHJlcGFyZWQgYWN0aW9uIGNyZWF0b3JzIHdpdGggdGhlIGBjcmVhdGVgIG5vdGF0aW9uLlwiKTtcbiAgICB9XG4gICAgY2FzZVJlZHVjZXIgPSBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZS5yZWR1Y2VyO1xuICAgIHByZXBhcmVDYWxsYmFjayA9IG1heWJlUmVkdWNlcldpdGhQcmVwYXJlLnByZXBhcmU7XG4gIH0gZWxzZSB7XG4gICAgY2FzZVJlZHVjZXIgPSBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZTtcbiAgfVxuICBjb250ZXh0LmFkZENhc2UodHlwZSwgY2FzZVJlZHVjZXIpLmV4cG9zZUNhc2VSZWR1Y2VyKHJlZHVjZXJOYW1lLCBjYXNlUmVkdWNlcikuZXhwb3NlQWN0aW9uKHJlZHVjZXJOYW1lLCBwcmVwYXJlQ2FsbGJhY2sgPyBjcmVhdGVBY3Rpb24odHlwZSwgcHJlcGFyZUNhbGxiYWNrKSA6IGNyZWF0ZUFjdGlvbih0eXBlKSk7XG59XG5mdW5jdGlvbiBpc0FzeW5jVGh1bmtTbGljZVJlZHVjZXJEZWZpbml0aW9uKHJlZHVjZXJEZWZpbml0aW9uKSB7XG4gIHJldHVybiByZWR1Y2VyRGVmaW5pdGlvbi5fcmVkdWNlckRlZmluaXRpb25UeXBlID09PSBcImFzeW5jVGh1bmtcIiAvKiBhc3luY1RodW5rICovO1xufVxuZnVuY3Rpb24gaXNDYXNlUmVkdWNlcldpdGhQcmVwYXJlRGVmaW5pdGlvbihyZWR1Y2VyRGVmaW5pdGlvbikge1xuICByZXR1cm4gcmVkdWNlckRlZmluaXRpb24uX3JlZHVjZXJEZWZpbml0aW9uVHlwZSA9PT0gXCJyZWR1Y2VyV2l0aFByZXBhcmVcIiAvKiByZWR1Y2VyV2l0aFByZXBhcmUgKi87XG59XG5mdW5jdGlvbiBoYW5kbGVUaHVua0Nhc2VSZWR1Y2VyRGVmaW5pdGlvbih7XG4gIHR5cGUsXG4gIHJlZHVjZXJOYW1lXG59LCByZWR1Y2VyRGVmaW5pdGlvbiwgY29udGV4dCwgY0FUKSB7XG4gIGlmICghY0FUKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTgpIDogXCJDYW5ub3QgdXNlIGBjcmVhdGUuYXN5bmNUaHVua2AgaW4gdGhlIGJ1aWx0LWluIGBjcmVhdGVTbGljZWAuIFVzZSBgYnVpbGRDcmVhdGVTbGljZSh7IGNyZWF0b3JzOiB7IGFzeW5jVGh1bms6IGFzeW5jVGh1bmtDcmVhdG9yIH0gfSlgIHRvIGNyZWF0ZSBhIGN1c3RvbWlzZWQgdmVyc2lvbiBvZiBgY3JlYXRlU2xpY2VgLlwiKTtcbiAgfVxuICBjb25zdCB7XG4gICAgcGF5bG9hZENyZWF0b3IsXG4gICAgZnVsZmlsbGVkLFxuICAgIHBlbmRpbmcsXG4gICAgcmVqZWN0ZWQsXG4gICAgc2V0dGxlZCxcbiAgICBvcHRpb25zXG4gIH0gPSByZWR1Y2VyRGVmaW5pdGlvbjtcbiAgY29uc3QgdGh1bmsgPSBjQVQodHlwZSwgcGF5bG9hZENyZWF0b3IsIG9wdGlvbnMpO1xuICBjb250ZXh0LmV4cG9zZUFjdGlvbihyZWR1Y2VyTmFtZSwgdGh1bmspO1xuICBpZiAoZnVsZmlsbGVkKSB7XG4gICAgY29udGV4dC5hZGRDYXNlKHRodW5rLmZ1bGZpbGxlZCwgZnVsZmlsbGVkKTtcbiAgfVxuICBpZiAocGVuZGluZykge1xuICAgIGNvbnRleHQuYWRkQ2FzZSh0aHVuay5wZW5kaW5nLCBwZW5kaW5nKTtcbiAgfVxuICBpZiAocmVqZWN0ZWQpIHtcbiAgICBjb250ZXh0LmFkZENhc2UodGh1bmsucmVqZWN0ZWQsIHJlamVjdGVkKTtcbiAgfVxuICBpZiAoc2V0dGxlZCkge1xuICAgIGNvbnRleHQuYWRkTWF0Y2hlcih0aHVuay5zZXR0bGVkLCBzZXR0bGVkKTtcbiAgfVxuICBjb250ZXh0LmV4cG9zZUNhc2VSZWR1Y2VyKHJlZHVjZXJOYW1lLCB7XG4gICAgZnVsZmlsbGVkOiBmdWxmaWxsZWQgfHwgbm9vcCxcbiAgICBwZW5kaW5nOiBwZW5kaW5nIHx8IG5vb3AsXG4gICAgcmVqZWN0ZWQ6IHJlamVjdGVkIHx8IG5vb3AsXG4gICAgc2V0dGxlZDogc2V0dGxlZCB8fCBub29wXG4gIH0pO1xufVxuZnVuY3Rpb24gbm9vcCgpIHtcbn1cblxuLy8gc3JjL2VudGl0aWVzL2VudGl0eV9zdGF0ZS50c1xuZnVuY3Rpb24gZ2V0SW5pdGlhbEVudGl0eVN0YXRlKCkge1xuICByZXR1cm4ge1xuICAgIGlkczogW10sXG4gICAgZW50aXRpZXM6IHt9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVJbml0aWFsU3RhdGVGYWN0b3J5KCkge1xuICBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoYWRkaXRpb25hbFN0YXRlID0ge30pIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihnZXRJbml0aWFsRW50aXR5U3RhdGUoKSwgYWRkaXRpb25hbFN0YXRlKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldEluaXRpYWxTdGF0ZVxuICB9O1xufVxuXG4vLyBzcmMvZW50aXRpZXMvc3RhdGVfc2VsZWN0b3JzLnRzXG5mdW5jdGlvbiBjcmVhdGVTZWxlY3RvcnNGYWN0b3J5KCkge1xuICBmdW5jdGlvbiBnZXRTZWxlY3RvcnMoc2VsZWN0U3RhdGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNyZWF0ZVNlbGVjdG9yOiBjcmVhdGVTZWxlY3RvcjIgPSBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvclxuICAgIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHNlbGVjdElkcyA9IChzdGF0ZSkgPT4gc3RhdGUuaWRzO1xuICAgIGNvbnN0IHNlbGVjdEVudGl0aWVzID0gKHN0YXRlKSA9PiBzdGF0ZS5lbnRpdGllcztcbiAgICBjb25zdCBzZWxlY3RBbGwgPSBjcmVhdGVTZWxlY3RvcjIoc2VsZWN0SWRzLCBzZWxlY3RFbnRpdGllcywgKGlkcywgZW50aXRpZXMpID0+IGlkcy5tYXAoKGlkKSA9PiBlbnRpdGllc1tpZF0pKTtcbiAgICBjb25zdCBzZWxlY3RJZCA9IChfLCBpZCkgPT4gaWQ7XG4gICAgY29uc3Qgc2VsZWN0QnlJZCA9IChlbnRpdGllcywgaWQpID0+IGVudGl0aWVzW2lkXTtcbiAgICBjb25zdCBzZWxlY3RUb3RhbCA9IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RJZHMsIChpZHMpID0+IGlkcy5sZW5ndGgpO1xuICAgIGlmICghc2VsZWN0U3RhdGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlbGVjdElkcyxcbiAgICAgICAgc2VsZWN0RW50aXRpZXMsXG4gICAgICAgIHNlbGVjdEFsbCxcbiAgICAgICAgc2VsZWN0VG90YWwsXG4gICAgICAgIHNlbGVjdEJ5SWQ6IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RFbnRpdGllcywgc2VsZWN0SWQsIHNlbGVjdEJ5SWQpXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3RHbG9iYWxpemVkRW50aXRpZXMgPSBjcmVhdGVTZWxlY3RvcjIoc2VsZWN0U3RhdGUsIHNlbGVjdEVudGl0aWVzKTtcbiAgICByZXR1cm4ge1xuICAgICAgc2VsZWN0SWRzOiBjcmVhdGVTZWxlY3RvcjIoc2VsZWN0U3RhdGUsIHNlbGVjdElkcyksXG4gICAgICBzZWxlY3RFbnRpdGllczogc2VsZWN0R2xvYmFsaXplZEVudGl0aWVzLFxuICAgICAgc2VsZWN0QWxsOiBjcmVhdGVTZWxlY3RvcjIoc2VsZWN0U3RhdGUsIHNlbGVjdEFsbCksXG4gICAgICBzZWxlY3RUb3RhbDogY3JlYXRlU2VsZWN0b3IyKHNlbGVjdFN0YXRlLCBzZWxlY3RUb3RhbCksXG4gICAgICBzZWxlY3RCeUlkOiBjcmVhdGVTZWxlY3RvcjIoc2VsZWN0R2xvYmFsaXplZEVudGl0aWVzLCBzZWxlY3RJZCwgc2VsZWN0QnlJZClcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0U2VsZWN0b3JzXG4gIH07XG59XG5cbi8vIHNyYy9lbnRpdGllcy9zdGF0ZV9hZGFwdGVyLnRzXG5pbXBvcnQgeyBwcm9kdWNlIGFzIGNyZWF0ZU5leHRTdGF0ZTMsIGlzRHJhZnQgYXMgaXNEcmFmdDMgfSBmcm9tIFwiaW1tZXJcIjtcbnZhciBpc0RyYWZ0VHlwZWQgPSBpc0RyYWZ0MztcbmZ1bmN0aW9uIGNyZWF0ZVNpbmdsZUFyZ3VtZW50U3RhdGVPcGVyYXRvcihtdXRhdG9yKSB7XG4gIGNvbnN0IG9wZXJhdG9yID0gY3JlYXRlU3RhdGVPcGVyYXRvcigoXywgc3RhdGUpID0+IG11dGF0b3Ioc3RhdGUpKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIG9wZXJhdGlvbihzdGF0ZSkge1xuICAgIHJldHVybiBvcGVyYXRvcihzdGF0ZSwgdm9pZCAwKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRlT3BlcmF0b3IobXV0YXRvcikge1xuICByZXR1cm4gZnVuY3Rpb24gb3BlcmF0aW9uKHN0YXRlLCBhcmcpIHtcbiAgICBmdW5jdGlvbiBpc1BheWxvYWRBY3Rpb25Bcmd1bWVudChhcmcyKSB7XG4gICAgICByZXR1cm4gaXNGU0EoYXJnMik7XG4gICAgfVxuICAgIGNvbnN0IHJ1bk11dGF0b3IgPSAoZHJhZnQpID0+IHtcbiAgICAgIGlmIChpc1BheWxvYWRBY3Rpb25Bcmd1bWVudChhcmcpKSB7XG4gICAgICAgIG11dGF0b3IoYXJnLnBheWxvYWQsIGRyYWZ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG11dGF0b3IoYXJnLCBkcmFmdCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNEcmFmdFR5cGVkKHN0YXRlKSkge1xuICAgICAgcnVuTXV0YXRvcihzdGF0ZSk7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVOZXh0U3RhdGUzKHN0YXRlLCBydW5NdXRhdG9yKTtcbiAgfTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL3V0aWxzLnRzXG5mdW5jdGlvbiBzZWxlY3RJZFZhbHVlKGVudGl0eSwgc2VsZWN0SWQpIHtcbiAgY29uc3Qga2V5ID0gc2VsZWN0SWQoZW50aXR5KTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBrZXkgPT09IHZvaWQgMCkge1xuICAgIGNvbnNvbGUud2FybihcIlRoZSBlbnRpdHkgcGFzc2VkIHRvIHRoZSBgc2VsZWN0SWRgIGltcGxlbWVudGF0aW9uIHJldHVybmVkIHVuZGVmaW5lZC5cIiwgXCJZb3Ugc2hvdWxkIHByb2JhYmx5IHByb3ZpZGUgeW91ciBvd24gYHNlbGVjdElkYCBpbXBsZW1lbnRhdGlvbi5cIiwgXCJUaGUgZW50aXR5IHRoYXQgd2FzIHBhc3NlZDpcIiwgZW50aXR5LCBcIlRoZSBgc2VsZWN0SWRgIGltcGxlbWVudGF0aW9uOlwiLCBzZWxlY3RJZC50b1N0cmluZygpKTtcbiAgfVxuICByZXR1cm4ga2V5O1xufVxuZnVuY3Rpb24gZW5zdXJlRW50aXRpZXNBcnJheShlbnRpdGllcykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZW50aXRpZXMpKSB7XG4gICAgZW50aXRpZXMgPSBPYmplY3QudmFsdWVzKGVudGl0aWVzKTtcbiAgfVxuICByZXR1cm4gZW50aXRpZXM7XG59XG5mdW5jdGlvbiBzcGxpdEFkZGVkVXBkYXRlZEVudGl0aWVzKG5ld0VudGl0aWVzLCBzZWxlY3RJZCwgc3RhdGUpIHtcbiAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgY29uc3QgYWRkZWQgPSBbXTtcbiAgY29uc3QgdXBkYXRlZCA9IFtdO1xuICBmb3IgKGNvbnN0IGVudGl0eSBvZiBuZXdFbnRpdGllcykge1xuICAgIGNvbnN0IGlkID0gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKTtcbiAgICBpZiAoaWQgaW4gc3RhdGUuZW50aXRpZXMpIHtcbiAgICAgIHVwZGF0ZWQucHVzaCh7XG4gICAgICAgIGlkLFxuICAgICAgICBjaGFuZ2VzOiBlbnRpdHlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZGRlZC5wdXNoKGVudGl0eSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBbYWRkZWQsIHVwZGF0ZWRdO1xufVxuXG4vLyBzcmMvZW50aXRpZXMvdW5zb3J0ZWRfc3RhdGVfYWRhcHRlci50c1xuZnVuY3Rpb24gY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQpIHtcbiAgZnVuY3Rpb24gYWRkT25lTXV0YWJseShlbnRpdHksIHN0YXRlKSB7XG4gICAgY29uc3Qga2V5ID0gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKTtcbiAgICBpZiAoa2V5IGluIHN0YXRlLmVudGl0aWVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0YXRlLmlkcy5wdXNoKGtleSk7XG4gICAgc3RhdGUuZW50aXRpZXNba2V5XSA9IGVudGl0eTtcbiAgfVxuICBmdW5jdGlvbiBhZGRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIG5ld0VudGl0aWVzKSB7XG4gICAgICBhZGRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICBjb25zdCBrZXkgPSBzZWxlY3RJZFZhbHVlKGVudGl0eSwgc2VsZWN0SWQpO1xuICAgIGlmICghKGtleSBpbiBzdGF0ZS5lbnRpdGllcykpIHtcbiAgICAgIHN0YXRlLmlkcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHN0YXRlLmVudGl0aWVzW2tleV0gPSBlbnRpdHk7XG4gIH1cbiAgZnVuY3Rpb24gc2V0TWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBuZXdFbnRpdGllcykge1xuICAgICAgc2V0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2V0QWxsTXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICAgIHN0YXRlLmlkcyA9IFtdO1xuICAgIHN0YXRlLmVudGl0aWVzID0ge307XG4gICAgYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVPbmVNdXRhYmx5KGtleSwgc3RhdGUpIHtcbiAgICByZXR1cm4gcmVtb3ZlTWFueU11dGFibHkoW2tleV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVNYW55TXV0YWJseShrZXlzLCBzdGF0ZSkge1xuICAgIGxldCBkaWRNdXRhdGUgPSBmYWxzZTtcbiAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKGtleSBpbiBzdGF0ZS5lbnRpdGllcykge1xuICAgICAgICBkZWxldGUgc3RhdGUuZW50aXRpZXNba2V5XTtcbiAgICAgICAgZGlkTXV0YXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoZGlkTXV0YXRlKSB7XG4gICAgICBzdGF0ZS5pZHMgPSBzdGF0ZS5pZHMuZmlsdGVyKChpZCkgPT4gaWQgaW4gc3RhdGUuZW50aXRpZXMpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZW1vdmVBbGxNdXRhYmx5KHN0YXRlKSB7XG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZSwge1xuICAgICAgaWRzOiBbXSxcbiAgICAgIGVudGl0aWVzOiB7fVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHRha2VOZXdLZXkoa2V5cywgdXBkYXRlLCBzdGF0ZSkge1xuICAgIGNvbnN0IG9yaWdpbmFsMyA9IHN0YXRlLmVudGl0aWVzW3VwZGF0ZS5pZF07XG4gICAgaWYgKG9yaWdpbmFsMyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZWQgPSBPYmplY3QuYXNzaWduKHt9LCBvcmlnaW5hbDMsIHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICBjb25zdCBuZXdLZXkgPSBzZWxlY3RJZFZhbHVlKHVwZGF0ZWQsIHNlbGVjdElkKTtcbiAgICBjb25zdCBoYXNOZXdLZXkgPSBuZXdLZXkgIT09IHVwZGF0ZS5pZDtcbiAgICBpZiAoaGFzTmV3S2V5KSB7XG4gICAgICBrZXlzW3VwZGF0ZS5pZF0gPSBuZXdLZXk7XG4gICAgICBkZWxldGUgc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXTtcbiAgICB9XG4gICAgc3RhdGUuZW50aXRpZXNbbmV3S2V5XSA9IHVwZGF0ZWQ7XG4gICAgcmV0dXJuIGhhc05ld0tleTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVPbmVNdXRhYmx5KHVwZGF0ZSwgc3RhdGUpIHtcbiAgICByZXR1cm4gdXBkYXRlTWFueU11dGFibHkoW3VwZGF0ZV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVzLCBzdGF0ZSkge1xuICAgIGNvbnN0IG5ld0tleXMgPSB7fTtcbiAgICBjb25zdCB1cGRhdGVzUGVyRW50aXR5ID0ge307XG4gICAgdXBkYXRlcy5mb3JFYWNoKCh1cGRhdGUpID0+IHtcbiAgICAgIGlmICh1cGRhdGUuaWQgaW4gc3RhdGUuZW50aXRpZXMpIHtcbiAgICAgICAgdXBkYXRlc1BlckVudGl0eVt1cGRhdGUuaWRdID0ge1xuICAgICAgICAgIGlkOiB1cGRhdGUuaWQsXG4gICAgICAgICAgLy8gU3ByZWFkcyBpZ25vcmUgZmFsc3kgdmFsdWVzLCBzbyB0aGlzIHdvcmtzIGV2ZW4gaWYgdGhlcmUgaXNuJ3RcbiAgICAgICAgICAvLyBhbiBleGlzdGluZyB1cGRhdGUgYWxyZWFkeSBhdCB0aGlzIGtleVxuICAgICAgICAgIGNoYW5nZXM6IHtcbiAgICAgICAgICAgIC4uLnVwZGF0ZXNQZXJFbnRpdHlbdXBkYXRlLmlkXSA/IHVwZGF0ZXNQZXJFbnRpdHlbdXBkYXRlLmlkXS5jaGFuZ2VzIDogbnVsbCxcbiAgICAgICAgICAgIC4uLnVwZGF0ZS5jaGFuZ2VzXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHVwZGF0ZXMgPSBPYmplY3QudmFsdWVzKHVwZGF0ZXNQZXJFbnRpdHkpO1xuICAgIGNvbnN0IGRpZE11dGF0ZUVudGl0aWVzID0gdXBkYXRlcy5sZW5ndGggPiAwO1xuICAgIGlmIChkaWRNdXRhdGVFbnRpdGllcykge1xuICAgICAgY29uc3QgZGlkTXV0YXRlSWRzID0gdXBkYXRlcy5maWx0ZXIoKHVwZGF0ZSkgPT4gdGFrZU5ld0tleShuZXdLZXlzLCB1cGRhdGUsIHN0YXRlKSkubGVuZ3RoID4gMDtcbiAgICAgIGlmIChkaWRNdXRhdGVJZHMpIHtcbiAgICAgICAgc3RhdGUuaWRzID0gT2JqZWN0LnZhbHVlcyhzdGF0ZS5lbnRpdGllcykubWFwKChlKSA9PiBzZWxlY3RJZFZhbHVlKGUsIHNlbGVjdElkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVwc2VydE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIHJldHVybiB1cHNlcnRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHVwc2VydE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIGNvbnN0IFthZGRlZCwgdXBkYXRlZF0gPSBzcGxpdEFkZGVkVXBkYXRlZEVudGl0aWVzKG5ld0VudGl0aWVzLCBzZWxlY3RJZCwgc3RhdGUpO1xuICAgIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZWQsIHN0YXRlKTtcbiAgICBhZGRNYW55TXV0YWJseShhZGRlZCwgc3RhdGUpO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVtb3ZlQWxsOiBjcmVhdGVTaW5nbGVBcmd1bWVudFN0YXRlT3BlcmF0b3IocmVtb3ZlQWxsTXV0YWJseSksXG4gICAgYWRkT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE9uZU11dGFibHkpLFxuICAgIGFkZE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkTWFueU11dGFibHkpLFxuICAgIHNldE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRPbmVNdXRhYmx5KSxcbiAgICBzZXRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE1hbnlNdXRhYmx5KSxcbiAgICBzZXRBbGw6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0QWxsTXV0YWJseSksXG4gICAgdXBkYXRlT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU9uZU11dGFibHkpLFxuICAgIHVwZGF0ZU1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlTWFueU11dGFibHkpLFxuICAgIHVwc2VydE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRPbmVNdXRhYmx5KSxcbiAgICB1cHNlcnRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE1hbnlNdXRhYmx5KSxcbiAgICByZW1vdmVPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IocmVtb3ZlT25lTXV0YWJseSksXG4gICAgcmVtb3ZlTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihyZW1vdmVNYW55TXV0YWJseSlcbiAgfTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL3NvcnRlZF9zdGF0ZV9hZGFwdGVyLnRzXG5mdW5jdGlvbiBjcmVhdGVTb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQsIHNvcnQpIHtcbiAgY29uc3Qge1xuICAgIHJlbW92ZU9uZSxcbiAgICByZW1vdmVNYW55LFxuICAgIHJlbW92ZUFsbFxuICB9ID0gY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQpO1xuICBmdW5jdGlvbiBhZGRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICByZXR1cm4gYWRkTWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiBhZGRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICAgIGNvbnN0IG1vZGVscyA9IG5ld0VudGl0aWVzLmZpbHRlcigobW9kZWwpID0+ICEoc2VsZWN0SWRWYWx1ZShtb2RlbCwgc2VsZWN0SWQpIGluIHN0YXRlLmVudGl0aWVzKSk7XG4gICAgaWYgKG1vZGVscy5sZW5ndGggIT09IDApIHtcbiAgICAgIG1lcmdlKG1vZGVscywgc3RhdGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICByZXR1cm4gc2V0TWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiBzZXRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICAgIGlmIChuZXdFbnRpdGllcy5sZW5ndGggIT09IDApIHtcbiAgICAgIG1lcmdlKG5ld0VudGl0aWVzLCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldEFsbE11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgICBzdGF0ZS5lbnRpdGllcyA9IHt9O1xuICAgIHN0YXRlLmlkcyA9IFtdO1xuICAgIGFkZE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlT25lTXV0YWJseSh1cGRhdGUsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHVwZGF0ZU1hbnlNdXRhYmx5KFt1cGRhdGVdLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlTWFueU11dGFibHkodXBkYXRlcywgc3RhdGUpIHtcbiAgICBsZXQgYXBwbGllZFVwZGF0ZXMgPSBmYWxzZTtcbiAgICBmb3IgKGxldCB1cGRhdGUgb2YgdXBkYXRlcykge1xuICAgICAgY29uc3QgZW50aXR5ID0gc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXTtcbiAgICAgIGlmICghZW50aXR5KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYXBwbGllZFVwZGF0ZXMgPSB0cnVlO1xuICAgICAgT2JqZWN0LmFzc2lnbihlbnRpdHksIHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgIGNvbnN0IG5ld0lkID0gc2VsZWN0SWQoZW50aXR5KTtcbiAgICAgIGlmICh1cGRhdGUuaWQgIT09IG5ld0lkKSB7XG4gICAgICAgIGRlbGV0ZSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xuICAgICAgICBzdGF0ZS5lbnRpdGllc1tuZXdJZF0gPSBlbnRpdHk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhcHBsaWVkVXBkYXRlcykge1xuICAgICAgcmVzb3J0RW50aXRpZXMoc3RhdGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1cHNlcnRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICByZXR1cm4gdXBzZXJ0TWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiB1cHNlcnRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBjb25zdCBbYWRkZWQsIHVwZGF0ZWRdID0gc3BsaXRBZGRlZFVwZGF0ZWRFbnRpdGllcyhuZXdFbnRpdGllcywgc2VsZWN0SWQsIHN0YXRlKTtcbiAgICB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVkLCBzdGF0ZSk7XG4gICAgYWRkTWFueU11dGFibHkoYWRkZWQsIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiBhcmVBcnJheXNFcXVhbChhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoICYmIGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYVtpXSA9PT0gYltpXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2UobW9kZWxzLCBzdGF0ZSkge1xuICAgIG1vZGVscy5mb3JFYWNoKChtb2RlbCkgPT4ge1xuICAgICAgc3RhdGUuZW50aXRpZXNbc2VsZWN0SWQobW9kZWwpXSA9IG1vZGVsO1xuICAgIH0pO1xuICAgIHJlc29ydEVudGl0aWVzKHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiByZXNvcnRFbnRpdGllcyhzdGF0ZSkge1xuICAgIGNvbnN0IGFsbEVudGl0aWVzID0gT2JqZWN0LnZhbHVlcyhzdGF0ZS5lbnRpdGllcyk7XG4gICAgYWxsRW50aXRpZXMuc29ydChzb3J0KTtcbiAgICBjb25zdCBuZXdTb3J0ZWRJZHMgPSBhbGxFbnRpdGllcy5tYXAoc2VsZWN0SWQpO1xuICAgIGNvbnN0IHtcbiAgICAgIGlkc1xuICAgIH0gPSBzdGF0ZTtcbiAgICBpZiAoIWFyZUFycmF5c0VxdWFsKGlkcywgbmV3U29ydGVkSWRzKSkge1xuICAgICAgc3RhdGUuaWRzID0gbmV3U29ydGVkSWRzO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHJlbW92ZU9uZSxcbiAgICByZW1vdmVNYW55LFxuICAgIHJlbW92ZUFsbCxcbiAgICBhZGRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkT25lTXV0YWJseSksXG4gICAgdXBkYXRlT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU9uZU11dGFibHkpLFxuICAgIHVwc2VydE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRPbmVNdXRhYmx5KSxcbiAgICBzZXRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0T25lTXV0YWJseSksXG4gICAgc2V0TWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRNYW55TXV0YWJseSksXG4gICAgc2V0QWxsOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldEFsbE11dGFibHkpLFxuICAgIGFkZE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkTWFueU11dGFibHkpLFxuICAgIHVwZGF0ZU1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlTWFueU11dGFibHkpLFxuICAgIHVwc2VydE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0TWFueU11dGFibHkpXG4gIH07XG59XG5cbi8vIHNyYy9lbnRpdGllcy9jcmVhdGVfYWRhcHRlci50c1xuZnVuY3Rpb24gY3JlYXRlRW50aXR5QWRhcHRlcihvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHNlbGVjdElkLFxuICAgIHNvcnRDb21wYXJlclxuICB9ID0ge1xuICAgIHNvcnRDb21wYXJlcjogZmFsc2UsXG4gICAgc2VsZWN0SWQ6IChpbnN0YW5jZSkgPT4gaW5zdGFuY2UuaWQsXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICBjb25zdCBzdGF0ZUZhY3RvcnkgPSBjcmVhdGVJbml0aWFsU3RhdGVGYWN0b3J5KCk7XG4gIGNvbnN0IHNlbGVjdG9yc0ZhY3RvcnkgPSBjcmVhdGVTZWxlY3RvcnNGYWN0b3J5KCk7XG4gIGNvbnN0IHN0YXRlQWRhcHRlciA9IHNvcnRDb21wYXJlciA/IGNyZWF0ZVNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCwgc29ydENvbXBhcmVyKSA6IGNyZWF0ZVVuc29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkKTtcbiAgcmV0dXJuIHtcbiAgICBzZWxlY3RJZCxcbiAgICBzb3J0Q29tcGFyZXIsXG4gICAgLi4uc3RhdGVGYWN0b3J5LFxuICAgIC4uLnNlbGVjdG9yc0ZhY3RvcnksXG4gICAgLi4uc3RhdGVBZGFwdGVyXG4gIH07XG59XG5cbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvaW5kZXgudHNcbmltcG9ydCB7IGlzQWN0aW9uIGFzIGlzQWN0aW9uMyB9IGZyb20gXCJyZWR1eFwiO1xuXG4vLyBzcmMvbGlzdGVuZXJNaWRkbGV3YXJlL2V4Y2VwdGlvbnMudHNcbnZhciB0YXNrID0gXCJ0YXNrXCI7XG52YXIgbGlzdGVuZXIgPSBcImxpc3RlbmVyXCI7XG52YXIgY29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcbnZhciBjYW5jZWxsZWQgPSBcImNhbmNlbGxlZFwiO1xudmFyIHRhc2tDYW5jZWxsZWQgPSBgdGFzay0ke2NhbmNlbGxlZH1gO1xudmFyIHRhc2tDb21wbGV0ZWQgPSBgdGFzay0ke2NvbXBsZXRlZH1gO1xudmFyIGxpc3RlbmVyQ2FuY2VsbGVkID0gYCR7bGlzdGVuZXJ9LSR7Y2FuY2VsbGVkfWA7XG52YXIgbGlzdGVuZXJDb21wbGV0ZWQgPSBgJHtsaXN0ZW5lcn0tJHtjb21wbGV0ZWR9YDtcbnZhciBUYXNrQWJvcnRFcnJvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY29kZSkge1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5tZXNzYWdlID0gYCR7dGFza30gJHtjYW5jZWxsZWR9IChyZWFzb246ICR7Y29kZX0pYDtcbiAgfVxuICBuYW1lID0gXCJUYXNrQWJvcnRFcnJvclwiO1xuICBtZXNzYWdlO1xufTtcblxuLy8gc3JjL2xpc3RlbmVyTWlkZGxld2FyZS91dGlscy50c1xudmFyIGFzc2VydEZ1bmN0aW9uID0gKGZ1bmMsIGV4cGVjdGVkKSA9PiB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzIpIDogYCR7ZXhwZWN0ZWR9IGlzIG5vdCBhIGZ1bmN0aW9uYCk7XG4gIH1cbn07XG52YXIgbm9vcDIgPSAoKSA9PiB7XG59O1xudmFyIGNhdGNoUmVqZWN0aW9uID0gKHByb21pc2UsIG9uRXJyb3IgPSBub29wMikgPT4ge1xuICBwcm9taXNlLmNhdGNoKG9uRXJyb3IpO1xuICByZXR1cm4gcHJvbWlzZTtcbn07XG52YXIgYWRkQWJvcnRTaWduYWxMaXN0ZW5lciA9IChhYm9ydFNpZ25hbCwgY2FsbGJhY2spID0+IHtcbiAgYWJvcnRTaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGNhbGxiYWNrLCB7XG4gICAgb25jZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuICgpID0+IGFib3J0U2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBjYWxsYmFjayk7XG59O1xudmFyIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24gPSAoYWJvcnRDb250cm9sbGVyLCByZWFzb24pID0+IHtcbiAgY29uc3Qgc2lnbmFsID0gYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcbiAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghKFwicmVhc29uXCIgaW4gc2lnbmFsKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaWduYWwsIFwicmVhc29uXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogcmVhc29uLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICA7XG4gIGFib3J0Q29udHJvbGxlci5hYm9ydChyZWFzb24pO1xufTtcblxuLy8gc3JjL2xpc3RlbmVyTWlkZGxld2FyZS90YXNrLnRzXG52YXIgdmFsaWRhdGVBY3RpdmUgPSAoc2lnbmFsKSA9PiB7XG4gIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlYXNvblxuICAgIH0gPSBzaWduYWw7XG4gICAgdGhyb3cgbmV3IFRhc2tBYm9ydEVycm9yKHJlYXNvbik7XG4gIH1cbn07XG5mdW5jdGlvbiByYWNlV2l0aFNpZ25hbChzaWduYWwsIHByb21pc2UpIHtcbiAgbGV0IGNsZWFudXAgPSBub29wMjtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBub3RpZnlSZWplY3Rpb24gPSAoKSA9PiByZWplY3QobmV3IFRhc2tBYm9ydEVycm9yKHNpZ25hbC5yZWFzb24pKTtcbiAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIG5vdGlmeVJlamVjdGlvbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjbGVhbnVwID0gYWRkQWJvcnRTaWduYWxMaXN0ZW5lcihzaWduYWwsIG5vdGlmeVJlamVjdGlvbik7XG4gICAgcHJvbWlzZS5maW5hbGx5KCgpID0+IGNsZWFudXAoKSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICBjbGVhbnVwID0gbm9vcDI7XG4gIH0pO1xufVxudmFyIHJ1blRhc2sgPSBhc3luYyAodGFzazIsIGNsZWFuVXApID0+IHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHRhc2syKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogXCJva1wiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6IGVycm9yIGluc3RhbmNlb2YgVGFza0Fib3J0RXJyb3IgPyBcImNhbmNlbGxlZFwiIDogXCJyZWplY3RlZFwiLFxuICAgICAgZXJyb3JcbiAgICB9O1xuICB9IGZpbmFsbHkge1xuICAgIGNsZWFuVXA/LigpO1xuICB9XG59O1xudmFyIGNyZWF0ZVBhdXNlID0gKHNpZ25hbCkgPT4ge1xuICByZXR1cm4gKHByb21pc2UpID0+IHtcbiAgICByZXR1cm4gY2F0Y2hSZWplY3Rpb24ocmFjZVdpdGhTaWduYWwoc2lnbmFsLCBwcm9taXNlKS50aGVuKChvdXRwdXQpID0+IHtcbiAgICAgIHZhbGlkYXRlQWN0aXZlKHNpZ25hbCk7XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0pKTtcbiAgfTtcbn07XG52YXIgY3JlYXRlRGVsYXkgPSAoc2lnbmFsKSA9PiB7XG4gIGNvbnN0IHBhdXNlID0gY3JlYXRlUGF1c2Uoc2lnbmFsKTtcbiAgcmV0dXJuICh0aW1lb3V0TXMpID0+IHtcbiAgICByZXR1cm4gcGF1c2UobmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dE1zKSkpO1xuICB9O1xufTtcblxuLy8gc3JjL2xpc3RlbmVyTWlkZGxld2FyZS9pbmRleC50c1xudmFyIHtcbiAgYXNzaWduXG59ID0gT2JqZWN0O1xudmFyIElOVEVSTkFMX05JTF9UT0tFTiA9IHt9O1xudmFyIGFsbSA9IFwibGlzdGVuZXJNaWRkbGV3YXJlXCI7XG52YXIgY3JlYXRlRm9yayA9IChwYXJlbnRBYm9ydFNpZ25hbCwgcGFyZW50QmxvY2tpbmdQcm9taXNlcykgPT4ge1xuICBjb25zdCBsaW5rQ29udHJvbGxlcnMgPSAoY29udHJvbGxlcikgPT4gYWRkQWJvcnRTaWduYWxMaXN0ZW5lcihwYXJlbnRBYm9ydFNpZ25hbCwgKCkgPT4gYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjb250cm9sbGVyLCBwYXJlbnRBYm9ydFNpZ25hbC5yZWFzb24pKTtcbiAgcmV0dXJuICh0YXNrRXhlY3V0b3IsIG9wdHMpID0+IHtcbiAgICBhc3NlcnRGdW5jdGlvbih0YXNrRXhlY3V0b3IsIFwidGFza0V4ZWN1dG9yXCIpO1xuICAgIGNvbnN0IGNoaWxkQWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGxpbmtDb250cm9sbGVycyhjaGlsZEFib3J0Q29udHJvbGxlcik7XG4gICAgY29uc3QgcmVzdWx0ID0gcnVuVGFzayhhc3luYyAoKSA9PiB7XG4gICAgICB2YWxpZGF0ZUFjdGl2ZShwYXJlbnRBYm9ydFNpZ25hbCk7XG4gICAgICB2YWxpZGF0ZUFjdGl2ZShjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWwpO1xuICAgICAgY29uc3QgcmVzdWx0MiA9IGF3YWl0IHRhc2tFeGVjdXRvcih7XG4gICAgICAgIHBhdXNlOiBjcmVhdGVQYXVzZShjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWwpLFxuICAgICAgICBkZWxheTogY3JlYXRlRGVsYXkoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKSxcbiAgICAgICAgc2lnbmFsOiBjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICAgIH0pO1xuICAgICAgdmFsaWRhdGVBY3RpdmUoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICAgIHJldHVybiByZXN1bHQyO1xuICAgIH0sICgpID0+IGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY2hpbGRBYm9ydENvbnRyb2xsZXIsIHRhc2tDb21wbGV0ZWQpKTtcbiAgICBpZiAob3B0cz8uYXV0b0pvaW4pIHtcbiAgICAgIHBhcmVudEJsb2NraW5nUHJvbWlzZXMucHVzaChyZXN1bHQuY2F0Y2gobm9vcDIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdDogY3JlYXRlUGF1c2UocGFyZW50QWJvcnRTaWduYWwpKHJlc3VsdCksXG4gICAgICBjYW5jZWwoKSB7XG4gICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY2hpbGRBYm9ydENvbnRyb2xsZXIsIHRhc2tDYW5jZWxsZWQpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59O1xudmFyIGNyZWF0ZVRha2VQYXR0ZXJuID0gKHN0YXJ0TGlzdGVuaW5nLCBzaWduYWwpID0+IHtcbiAgY29uc3QgdGFrZSA9IGFzeW5jIChwcmVkaWNhdGUsIHRpbWVvdXQpID0+IHtcbiAgICB2YWxpZGF0ZUFjdGl2ZShzaWduYWwpO1xuICAgIGxldCB1bnN1YnNjcmliZSA9ICgpID0+IHtcbiAgICB9O1xuICAgIGNvbnN0IHR1cGxlUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCBzdG9wTGlzdGVuaW5nID0gc3RhcnRMaXN0ZW5pbmcoe1xuICAgICAgICBwcmVkaWNhdGUsXG4gICAgICAgIGVmZmVjdDogKGFjdGlvbiwgbGlzdGVuZXJBcGkpID0+IHtcbiAgICAgICAgICBsaXN0ZW5lckFwaS51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIHJlc29sdmUoW2FjdGlvbiwgbGlzdGVuZXJBcGkuZ2V0U3RhdGUoKSwgbGlzdGVuZXJBcGkuZ2V0T3JpZ2luYWxTdGF0ZSgpXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdW5zdWJzY3JpYmUgPSAoKSA9PiB7XG4gICAgICAgIHN0b3BMaXN0ZW5pbmcoKTtcbiAgICAgICAgcmVqZWN0KCk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHByb21pc2VzID0gW3R1cGxlUHJvbWlzZV07XG4gICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgcHJvbWlzZXMucHVzaChuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aW1lb3V0LCBudWxsKSkpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgcmFjZVdpdGhTaWduYWwoc2lnbmFsLCBQcm9taXNlLnJhY2UocHJvbWlzZXMpKTtcbiAgICAgIHZhbGlkYXRlQWN0aXZlKHNpZ25hbCk7XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB1bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIChwcmVkaWNhdGUsIHRpbWVvdXQpID0+IGNhdGNoUmVqZWN0aW9uKHRha2UocHJlZGljYXRlLCB0aW1lb3V0KSk7XG59O1xudmFyIGdldExpc3RlbmVyRW50cnlQcm9wc0Zyb20gPSAob3B0aW9ucykgPT4ge1xuICBsZXQge1xuICAgIHR5cGUsXG4gICAgYWN0aW9uQ3JlYXRvcixcbiAgICBtYXRjaGVyLFxuICAgIHByZWRpY2F0ZSxcbiAgICBlZmZlY3RcbiAgfSA9IG9wdGlvbnM7XG4gIGlmICh0eXBlKSB7XG4gICAgcHJlZGljYXRlID0gY3JlYXRlQWN0aW9uKHR5cGUpLm1hdGNoO1xuICB9IGVsc2UgaWYgKGFjdGlvbkNyZWF0b3IpIHtcbiAgICB0eXBlID0gYWN0aW9uQ3JlYXRvci50eXBlO1xuICAgIHByZWRpY2F0ZSA9IGFjdGlvbkNyZWF0b3IubWF0Y2g7XG4gIH0gZWxzZSBpZiAobWF0Y2hlcikge1xuICAgIHByZWRpY2F0ZSA9IG1hdGNoZXI7XG4gIH0gZWxzZSBpZiAocHJlZGljYXRlKSB7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjEpIDogXCJDcmVhdGluZyBvciByZW1vdmluZyBhIGxpc3RlbmVyIHJlcXVpcmVzIG9uZSBvZiB0aGUga25vd24gZmllbGRzIGZvciBtYXRjaGluZyBhbiBhY3Rpb25cIik7XG4gIH1cbiAgYXNzZXJ0RnVuY3Rpb24oZWZmZWN0LCBcIm9wdGlvbnMubGlzdGVuZXJcIik7XG4gIHJldHVybiB7XG4gICAgcHJlZGljYXRlLFxuICAgIHR5cGUsXG4gICAgZWZmZWN0XG4gIH07XG59O1xudmFyIGNyZWF0ZUxpc3RlbmVyRW50cnkgPSBPYmplY3QuYXNzaWduKChvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHtcbiAgICB0eXBlLFxuICAgIHByZWRpY2F0ZSxcbiAgICBlZmZlY3RcbiAgfSA9IGdldExpc3RlbmVyRW50cnlQcm9wc0Zyb20ob3B0aW9ucyk7XG4gIGNvbnN0IGlkID0gbmFub2lkKCk7XG4gIGNvbnN0IGVudHJ5ID0ge1xuICAgIGlkLFxuICAgIGVmZmVjdCxcbiAgICB0eXBlLFxuICAgIHByZWRpY2F0ZSxcbiAgICBwZW5kaW5nOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgIHVuc3Vic2NyaWJlOiAoKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyMikgOiBcIlVuc3Vic2NyaWJlIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBlbnRyeTtcbn0sIHtcbiAgd2l0aFR5cGVzOiAoKSA9PiBjcmVhdGVMaXN0ZW5lckVudHJ5XG59KTtcbnZhciBjYW5jZWxBY3RpdmVMaXN0ZW5lcnMgPSAoZW50cnkpID0+IHtcbiAgZW50cnkucGVuZGluZy5mb3JFYWNoKChjb250cm9sbGVyKSA9PiB7XG4gICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjb250cm9sbGVyLCBsaXN0ZW5lckNhbmNlbGxlZCk7XG4gIH0pO1xufTtcbnZhciBjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZSA9IChsaXN0ZW5lck1hcCkgPT4ge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGxpc3RlbmVyTWFwLmZvckVhY2goY2FuY2VsQWN0aXZlTGlzdGVuZXJzKTtcbiAgICBsaXN0ZW5lck1hcC5jbGVhcigpO1xuICB9O1xufTtcbnZhciBzYWZlbHlOb3RpZnlFcnJvciA9IChlcnJvckhhbmRsZXIsIGVycm9yVG9Ob3RpZnksIGVycm9ySW5mbykgPT4ge1xuICB0cnkge1xuICAgIGVycm9ySGFuZGxlcihlcnJvclRvTm90aWZ5LCBlcnJvckluZm8pO1xuICB9IGNhdGNoIChlcnJvckhhbmRsZXJFcnJvcikge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhyb3cgZXJyb3JIYW5kbGVyRXJyb3I7XG4gICAgfSwgMCk7XG4gIH1cbn07XG52YXIgYWRkTGlzdGVuZXIgPSBPYmplY3QuYXNzaWduKGNyZWF0ZUFjdGlvbihgJHthbG19L2FkZGApLCB7XG4gIHdpdGhUeXBlczogKCkgPT4gYWRkTGlzdGVuZXJcbn0pO1xudmFyIGNsZWFyQWxsTGlzdGVuZXJzID0gY3JlYXRlQWN0aW9uKGAke2FsbX0vcmVtb3ZlQWxsYCk7XG52YXIgcmVtb3ZlTGlzdGVuZXIgPSBPYmplY3QuYXNzaWduKGNyZWF0ZUFjdGlvbihgJHthbG19L3JlbW92ZWApLCB7XG4gIHdpdGhUeXBlczogKCkgPT4gcmVtb3ZlTGlzdGVuZXJcbn0pO1xudmFyIGRlZmF1bHRFcnJvckhhbmRsZXIgPSAoLi4uYXJncykgPT4ge1xuICBjb25zb2xlLmVycm9yKGAke2FsbX0vZXJyb3JgLCAuLi5hcmdzKTtcbn07XG52YXIgY3JlYXRlTGlzdGVuZXJNaWRkbGV3YXJlID0gKG1pZGRsZXdhcmVPcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgbGlzdGVuZXJNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCB7XG4gICAgZXh0cmEsXG4gICAgb25FcnJvciA9IGRlZmF1bHRFcnJvckhhbmRsZXJcbiAgfSA9IG1pZGRsZXdhcmVPcHRpb25zO1xuICBhc3NlcnRGdW5jdGlvbihvbkVycm9yLCBcIm9uRXJyb3JcIik7XG4gIGNvbnN0IGluc2VydEVudHJ5ID0gKGVudHJ5KSA9PiB7XG4gICAgZW50cnkudW5zdWJzY3JpYmUgPSAoKSA9PiBsaXN0ZW5lck1hcC5kZWxldGUoZW50cnkuaWQpO1xuICAgIGxpc3RlbmVyTWFwLnNldChlbnRyeS5pZCwgZW50cnkpO1xuICAgIHJldHVybiAoY2FuY2VsT3B0aW9ucykgPT4ge1xuICAgICAgZW50cnkudW5zdWJzY3JpYmUoKTtcbiAgICAgIGlmIChjYW5jZWxPcHRpb25zPy5jYW5jZWxBY3RpdmUpIHtcbiAgICAgICAgY2FuY2VsQWN0aXZlTGlzdGVuZXJzKGVudHJ5KTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICBjb25zdCBzdGFydExpc3RlbmluZyA9IChvcHRpb25zKSA9PiB7XG4gICAgbGV0IGVudHJ5ID0gZmluZChBcnJheS5mcm9tKGxpc3RlbmVyTWFwLnZhbHVlcygpKSwgKGV4aXN0aW5nRW50cnkpID0+IGV4aXN0aW5nRW50cnkuZWZmZWN0ID09PSBvcHRpb25zLmVmZmVjdCk7XG4gICAgaWYgKCFlbnRyeSkge1xuICAgICAgZW50cnkgPSBjcmVhdGVMaXN0ZW5lckVudHJ5KG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gaW5zZXJ0RW50cnkoZW50cnkpO1xuICB9O1xuICBPYmplY3QuYXNzaWduKHN0YXJ0TGlzdGVuaW5nLCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiBzdGFydExpc3RlbmluZ1xuICB9KTtcbiAgY29uc3Qgc3RvcExpc3RlbmluZyA9IChvcHRpb25zKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIGVmZmVjdCxcbiAgICAgIHByZWRpY2F0ZVxuICAgIH0gPSBnZXRMaXN0ZW5lckVudHJ5UHJvcHNGcm9tKG9wdGlvbnMpO1xuICAgIGNvbnN0IGVudHJ5ID0gZmluZChBcnJheS5mcm9tKGxpc3RlbmVyTWFwLnZhbHVlcygpKSwgKGVudHJ5MikgPT4ge1xuICAgICAgY29uc3QgbWF0Y2hQcmVkaWNhdGVPclR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gXCJzdHJpbmdcIiA/IGVudHJ5Mi50eXBlID09PSB0eXBlIDogZW50cnkyLnByZWRpY2F0ZSA9PT0gcHJlZGljYXRlO1xuICAgICAgcmV0dXJuIG1hdGNoUHJlZGljYXRlT3JUeXBlICYmIGVudHJ5Mi5lZmZlY3QgPT09IGVmZmVjdDtcbiAgICB9KTtcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGVudHJ5LnVuc3Vic2NyaWJlKCk7XG4gICAgICBpZiAob3B0aW9ucy5jYW5jZWxBY3RpdmUpIHtcbiAgICAgICAgY2FuY2VsQWN0aXZlTGlzdGVuZXJzKGVudHJ5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICEhZW50cnk7XG4gIH07XG4gIE9iamVjdC5hc3NpZ24oc3RvcExpc3RlbmluZywge1xuICAgIHdpdGhUeXBlczogKCkgPT4gc3RvcExpc3RlbmluZ1xuICB9KTtcbiAgY29uc3Qgbm90aWZ5TGlzdGVuZXIgPSBhc3luYyAoZW50cnksIGFjdGlvbiwgYXBpLCBnZXRPcmlnaW5hbFN0YXRlKSA9PiB7XG4gICAgY29uc3QgaW50ZXJuYWxUYXNrQ29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCB0YWtlID0gY3JlYXRlVGFrZVBhdHRlcm4oc3RhcnRMaXN0ZW5pbmcsIGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICBjb25zdCBhdXRvSm9pblByb21pc2VzID0gW107XG4gICAgdHJ5IHtcbiAgICAgIGVudHJ5LnBlbmRpbmcuYWRkKGludGVybmFsVGFza0NvbnRyb2xsZXIpO1xuICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKGVudHJ5LmVmZmVjdChcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICAvLyBVc2UgYXNzaWduKCkgcmF0aGVyIHRoYW4gLi4uIHRvIGF2b2lkIGV4dHJhIGhlbHBlciBmdW5jdGlvbnMgYWRkZWQgdG8gYnVuZGxlXG4gICAgICAgIGFzc2lnbih7fSwgYXBpLCB7XG4gICAgICAgICAgZ2V0T3JpZ2luYWxTdGF0ZSxcbiAgICAgICAgICBjb25kaXRpb246IChwcmVkaWNhdGUsIHRpbWVvdXQpID0+IHRha2UocHJlZGljYXRlLCB0aW1lb3V0KS50aGVuKEJvb2xlYW4pLFxuICAgICAgICAgIHRha2UsXG4gICAgICAgICAgZGVsYXk6IGNyZWF0ZURlbGF5KGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKSxcbiAgICAgICAgICBwYXVzZTogY3JlYXRlUGF1c2UoaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwpLFxuICAgICAgICAgIGV4dHJhLFxuICAgICAgICAgIHNpZ25hbDogaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgZm9yazogY3JlYXRlRm9yayhpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCwgYXV0b0pvaW5Qcm9taXNlcyksXG4gICAgICAgICAgdW5zdWJzY3JpYmU6IGVudHJ5LnVuc3Vic2NyaWJlLFxuICAgICAgICAgIHN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICAgICAgbGlzdGVuZXJNYXAuc2V0KGVudHJ5LmlkLCBlbnRyeSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYW5jZWxBY3RpdmVMaXN0ZW5lcnM6ICgpID0+IHtcbiAgICAgICAgICAgIGVudHJ5LnBlbmRpbmcuZm9yRWFjaCgoY29udHJvbGxlciwgXywgc2V0KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChjb250cm9sbGVyICE9PSBpbnRlcm5hbFRhc2tDb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjb250cm9sbGVyLCBsaXN0ZW5lckNhbmNlbGxlZCk7XG4gICAgICAgICAgICAgICAgc2V0LmRlbGV0ZShjb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYW5jZWw6ICgpID0+IHtcbiAgICAgICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oaW50ZXJuYWxUYXNrQ29udHJvbGxlciwgbGlzdGVuZXJDYW5jZWxsZWQpO1xuICAgICAgICAgICAgZW50cnkucGVuZGluZy5kZWxldGUoaW50ZXJuYWxUYXNrQ29udHJvbGxlcik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkOiAoKSA9PiB7XG4gICAgICAgICAgICB2YWxpZGF0ZUFjdGl2ZShpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKSk7XG4gICAgfSBjYXRjaCAobGlzdGVuZXJFcnJvcikge1xuICAgICAgaWYgKCEobGlzdGVuZXJFcnJvciBpbnN0YW5jZW9mIFRhc2tBYm9ydEVycm9yKSkge1xuICAgICAgICBzYWZlbHlOb3RpZnlFcnJvcihvbkVycm9yLCBsaXN0ZW5lckVycm9yLCB7XG4gICAgICAgICAgcmFpc2VkQnk6IFwiZWZmZWN0XCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGF1dG9Kb2luUHJvbWlzZXMpO1xuICAgICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihpbnRlcm5hbFRhc2tDb250cm9sbGVyLCBsaXN0ZW5lckNvbXBsZXRlZCk7XG4gICAgICBlbnRyeS5wZW5kaW5nLmRlbGV0ZShpbnRlcm5hbFRhc2tDb250cm9sbGVyKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlID0gY3JlYXRlQ2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUobGlzdGVuZXJNYXApO1xuICBjb25zdCBtaWRkbGV3YXJlID0gKGFwaSkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IHtcbiAgICBpZiAoIWlzQWN0aW9uMyhhY3Rpb24pKSB7XG4gICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgIH1cbiAgICBpZiAoYWRkTGlzdGVuZXIubWF0Y2goYWN0aW9uKSkge1xuICAgICAgcmV0dXJuIHN0YXJ0TGlzdGVuaW5nKGFjdGlvbi5wYXlsb2FkKTtcbiAgICB9XG4gICAgaWYgKGNsZWFyQWxsTGlzdGVuZXJzLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIGNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyZW1vdmVMaXN0ZW5lci5tYXRjaChhY3Rpb24pKSB7XG4gICAgICByZXR1cm4gc3RvcExpc3RlbmluZyhhY3Rpb24ucGF5bG9hZCk7XG4gICAgfVxuICAgIGxldCBvcmlnaW5hbFN0YXRlID0gYXBpLmdldFN0YXRlKCk7XG4gICAgY29uc3QgZ2V0T3JpZ2luYWxTdGF0ZSA9ICgpID0+IHtcbiAgICAgIGlmIChvcmlnaW5hbFN0YXRlID09PSBJTlRFUk5BTF9OSUxfVE9LRU4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjMpIDogYCR7YWxtfTogZ2V0T3JpZ2luYWxTdGF0ZSBjYW4gb25seSBiZSBjYWxsZWQgc3luY2hyb25vdXNseWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdpbmFsU3RhdGU7XG4gICAgfTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBuZXh0KGFjdGlvbik7XG4gICAgICBpZiAobGlzdGVuZXJNYXAuc2l6ZSA+IDApIHtcbiAgICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gYXBpLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyRW50cmllcyA9IEFycmF5LmZyb20obGlzdGVuZXJNYXAudmFsdWVzKCkpO1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGxpc3RlbmVyRW50cmllcykge1xuICAgICAgICAgIGxldCBydW5MaXN0ZW5lciA9IGZhbHNlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBydW5MaXN0ZW5lciA9IGVudHJ5LnByZWRpY2F0ZShhY3Rpb24sIGN1cnJlbnRTdGF0ZSwgb3JpZ2luYWxTdGF0ZSk7XG4gICAgICAgICAgfSBjYXRjaCAocHJlZGljYXRlRXJyb3IpIHtcbiAgICAgICAgICAgIHJ1bkxpc3RlbmVyID0gZmFsc2U7XG4gICAgICAgICAgICBzYWZlbHlOb3RpZnlFcnJvcihvbkVycm9yLCBwcmVkaWNhdGVFcnJvciwge1xuICAgICAgICAgICAgICByYWlzZWRCeTogXCJwcmVkaWNhdGVcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcnVuTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub3RpZnlMaXN0ZW5lcihlbnRyeSwgYWN0aW9uLCBhcGksIGdldE9yaWdpbmFsU3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIG9yaWdpbmFsU3RhdGUgPSBJTlRFUk5BTF9OSUxfVE9LRU47XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbWlkZGxld2FyZSxcbiAgICBzdGFydExpc3RlbmluZyxcbiAgICBzdG9wTGlzdGVuaW5nLFxuICAgIGNsZWFyTGlzdGVuZXJzOiBjbGVhckxpc3RlbmVyTWlkZGxld2FyZVxuICB9O1xufTtcblxuLy8gc3JjL2R5bmFtaWNNaWRkbGV3YXJlL2luZGV4LnRzXG5pbXBvcnQgeyBjb21wb3NlIGFzIGNvbXBvc2UzIH0gZnJvbSBcInJlZHV4XCI7XG52YXIgY3JlYXRlTWlkZGxld2FyZUVudHJ5ID0gKG1pZGRsZXdhcmUpID0+ICh7XG4gIGlkOiBuYW5vaWQoKSxcbiAgbWlkZGxld2FyZSxcbiAgYXBwbGllZDogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxufSk7XG52YXIgbWF0Y2hJbnN0YW5jZSA9IChpbnN0YW5jZUlkKSA9PiAoYWN0aW9uKSA9PiBhY3Rpb24/Lm1ldGE/Lmluc3RhbmNlSWQgPT09IGluc3RhbmNlSWQ7XG52YXIgY3JlYXRlRHluYW1pY01pZGRsZXdhcmUgPSAoKSA9PiB7XG4gIGNvbnN0IGluc3RhbmNlSWQgPSBuYW5vaWQoKTtcbiAgY29uc3QgbWlkZGxld2FyZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHdpdGhNaWRkbGV3YXJlID0gT2JqZWN0LmFzc2lnbihjcmVhdGVBY3Rpb24oXCJkeW5hbWljTWlkZGxld2FyZS9hZGRcIiwgKC4uLm1pZGRsZXdhcmVzKSA9PiAoe1xuICAgIHBheWxvYWQ6IG1pZGRsZXdhcmVzLFxuICAgIG1ldGE6IHtcbiAgICAgIGluc3RhbmNlSWRcbiAgICB9XG4gIH0pKSwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gd2l0aE1pZGRsZXdhcmVcbiAgfSk7XG4gIGNvbnN0IGFkZE1pZGRsZXdhcmUgPSBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIGFkZE1pZGRsZXdhcmUyKC4uLm1pZGRsZXdhcmVzKSB7XG4gICAgbWlkZGxld2FyZXMuZm9yRWFjaCgobWlkZGxld2FyZTIpID0+IHtcbiAgICAgIGxldCBlbnRyeSA9IGZpbmQoQXJyYXkuZnJvbShtaWRkbGV3YXJlTWFwLnZhbHVlcygpKSwgKGVudHJ5MikgPT4gZW50cnkyLm1pZGRsZXdhcmUgPT09IG1pZGRsZXdhcmUyKTtcbiAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgZW50cnkgPSBjcmVhdGVNaWRkbGV3YXJlRW50cnkobWlkZGxld2FyZTIpO1xuICAgICAgfVxuICAgICAgbWlkZGxld2FyZU1hcC5zZXQoZW50cnkuaWQsIGVudHJ5KTtcbiAgICB9KTtcbiAgfSwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gYWRkTWlkZGxld2FyZVxuICB9KTtcbiAgY29uc3QgZ2V0RmluYWxNaWRkbGV3YXJlID0gKGFwaSkgPT4ge1xuICAgIGNvbnN0IGFwcGxpZWRNaWRkbGV3YXJlID0gQXJyYXkuZnJvbShtaWRkbGV3YXJlTWFwLnZhbHVlcygpKS5tYXAoKGVudHJ5KSA9PiBlbXBsYWNlKGVudHJ5LmFwcGxpZWQsIGFwaSwge1xuICAgICAgaW5zZXJ0OiAoKSA9PiBlbnRyeS5taWRkbGV3YXJlKGFwaSlcbiAgICB9KSk7XG4gICAgcmV0dXJuIGNvbXBvc2UzKC4uLmFwcGxpZWRNaWRkbGV3YXJlKTtcbiAgfTtcbiAgY29uc3QgaXNXaXRoTWlkZGxld2FyZSA9IGlzQWxsT2Yod2l0aE1pZGRsZXdhcmUsIG1hdGNoSW5zdGFuY2UoaW5zdGFuY2VJZCkpO1xuICBjb25zdCBtaWRkbGV3YXJlID0gKGFwaSkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IHtcbiAgICBpZiAoaXNXaXRoTWlkZGxld2FyZShhY3Rpb24pKSB7XG4gICAgICBhZGRNaWRkbGV3YXJlKC4uLmFjdGlvbi5wYXlsb2FkKTtcbiAgICAgIHJldHVybiBhcGkuZGlzcGF0Y2g7XG4gICAgfVxuICAgIHJldHVybiBnZXRGaW5hbE1pZGRsZXdhcmUoYXBpKShuZXh0KShhY3Rpb24pO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG1pZGRsZXdhcmUsXG4gICAgYWRkTWlkZGxld2FyZSxcbiAgICB3aXRoTWlkZGxld2FyZSxcbiAgICBpbnN0YW5jZUlkXG4gIH07XG59O1xuXG4vLyBzcmMvY29tYmluZVNsaWNlcy50c1xuaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIGFzIGNvbWJpbmVSZWR1Y2VyczIgfSBmcm9tIFwicmVkdXhcIjtcbnZhciBpc1NsaWNlTGlrZSA9IChtYXliZVNsaWNlTGlrZSkgPT4gXCJyZWR1Y2VyUGF0aFwiIGluIG1heWJlU2xpY2VMaWtlICYmIHR5cGVvZiBtYXliZVNsaWNlTGlrZS5yZWR1Y2VyUGF0aCA9PT0gXCJzdHJpbmdcIjtcbnZhciBnZXRSZWR1Y2VycyA9IChzbGljZXMpID0+IHNsaWNlcy5mbGF0TWFwKChzbGljZU9yTWFwKSA9PiBpc1NsaWNlTGlrZShzbGljZU9yTWFwKSA/IFtbc2xpY2VPck1hcC5yZWR1Y2VyUGF0aCwgc2xpY2VPck1hcC5yZWR1Y2VyXV0gOiBPYmplY3QuZW50cmllcyhzbGljZU9yTWFwKSk7XG52YXIgT1JJR0lOQUxfU1RBVEUgPSBTeW1ib2wuZm9yKFwicnRrLXN0YXRlLXByb3h5LW9yaWdpbmFsXCIpO1xudmFyIGlzU3RhdGVQcm94eSA9ICh2YWx1ZSkgPT4gISF2YWx1ZSAmJiAhIXZhbHVlW09SSUdJTkFMX1NUQVRFXTtcbnZhciBzdGF0ZVByb3h5TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgY3JlYXRlU3RhdGVQcm94eSA9IChzdGF0ZSwgcmVkdWNlck1hcCkgPT4gZW1wbGFjZShzdGF0ZVByb3h5TWFwLCBzdGF0ZSwge1xuICBpbnNlcnQ6ICgpID0+IG5ldyBQcm94eShzdGF0ZSwge1xuICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IHtcbiAgICAgIGlmIChwcm9wID09PSBPUklHSU5BTF9TVEFURSlcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgY29uc3QgcmVkdWNlciA9IHJlZHVjZXJNYXBbcHJvcC50b1N0cmluZygpXTtcbiAgICAgICAgaWYgKHJlZHVjZXIpIHtcbiAgICAgICAgICBjb25zdCByZWR1Y2VyUmVzdWx0ID0gcmVkdWNlcih2b2lkIDAsIHtcbiAgICAgICAgICAgIHR5cGU6IG5hbm9pZCgpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHR5cGVvZiByZWR1Y2VyUmVzdWx0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyNCkgOiBgVGhlIHNsaWNlIHJlZHVjZXIgZm9yIGtleSBcIiR7cHJvcC50b1N0cmluZygpfVwiIHJldHVybmVkIHVuZGVmaW5lZCB3aGVuIGNhbGxlZCBmb3Igc2VsZWN0b3IoKS4gSWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGUgcmVkdWNlciBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IGV4cGxpY2l0bHkgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgbm90IGJlIHVuZGVmaW5lZC4gSWYgeW91IGRvbid0IHdhbnQgdG8gc2V0IGEgdmFsdWUgZm9yIHRoaXMgcmVkdWNlciwgeW91IGNhbiB1c2UgbnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZC5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlZHVjZXJSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9KVxufSk7XG52YXIgb3JpZ2luYWwgPSAoc3RhdGUpID0+IHtcbiAgaWYgKCFpc1N0YXRlUHJveHkoc3RhdGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjUpIDogXCJvcmlnaW5hbCBtdXN0IGJlIHVzZWQgb24gc3RhdGUgUHJveHlcIik7XG4gIH1cbiAgcmV0dXJuIHN0YXRlW09SSUdJTkFMX1NUQVRFXTtcbn07XG5mdW5jdGlvbiBjb21iaW5lU2xpY2VzKC4uLnNsaWNlcykge1xuICBjb25zdCByZWR1Y2VyTWFwID0gT2JqZWN0LmZyb21FbnRyaWVzKGdldFJlZHVjZXJzKHNsaWNlcykpO1xuICBjb25zdCBnZXRSZWR1Y2VyID0gKCkgPT4gY29tYmluZVJlZHVjZXJzMihyZWR1Y2VyTWFwKTtcbiAgbGV0IHJlZHVjZXIgPSBnZXRSZWR1Y2VyKCk7XG4gIGZ1bmN0aW9uIGNvbWJpbmVkUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgcmV0dXJuIHJlZHVjZXIoc3RhdGUsIGFjdGlvbik7XG4gIH1cbiAgY29tYmluZWRSZWR1Y2VyLndpdGhMYXp5TG9hZGVkU2xpY2VzID0gKCkgPT4gY29tYmluZWRSZWR1Y2VyO1xuICBjb25zdCBpbmplY3QgPSAoc2xpY2UsIGNvbmZpZyA9IHt9KSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgcmVkdWNlclBhdGgsXG4gICAgICByZWR1Y2VyOiByZWR1Y2VyVG9JbmplY3RcbiAgICB9ID0gc2xpY2U7XG4gICAgY29uc3QgY3VycmVudFJlZHVjZXIgPSByZWR1Y2VyTWFwW3JlZHVjZXJQYXRoXTtcbiAgICBpZiAoIWNvbmZpZy5vdmVycmlkZUV4aXN0aW5nICYmIGN1cnJlbnRSZWR1Y2VyICYmIGN1cnJlbnRSZWR1Y2VyICE9PSByZWR1Y2VyVG9JbmplY3QpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYGNhbGxlZCBcXGBpbmplY3RcXGAgdG8gb3ZlcnJpZGUgYWxyZWFkeS1leGlzdGluZyByZWR1Y2VyICR7cmVkdWNlclBhdGh9IHdpdGhvdXQgc3BlY2lmeWluZyBcXGBvdmVycmlkZUV4aXN0aW5nOiB0cnVlXFxgYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tYmluZWRSZWR1Y2VyO1xuICAgIH1cbiAgICByZWR1Y2VyTWFwW3JlZHVjZXJQYXRoXSA9IHJlZHVjZXJUb0luamVjdDtcbiAgICByZWR1Y2VyID0gZ2V0UmVkdWNlcigpO1xuICAgIHJldHVybiBjb21iaW5lZFJlZHVjZXI7XG4gIH07XG4gIGNvbnN0IHNlbGVjdG9yID0gT2JqZWN0LmFzc2lnbihmdW5jdGlvbiBtYWtlU2VsZWN0b3Ioc2VsZWN0b3JGbiwgc2VsZWN0U3RhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gc2VsZWN0b3IyKHN0YXRlLCAuLi5hcmdzKSB7XG4gICAgICByZXR1cm4gc2VsZWN0b3JGbihjcmVhdGVTdGF0ZVByb3h5KHNlbGVjdFN0YXRlID8gc2VsZWN0U3RhdGUoc3RhdGUsIC4uLmFyZ3MpIDogc3RhdGUsIHJlZHVjZXJNYXApLCAuLi5hcmdzKTtcbiAgICB9O1xuICB9LCB7XG4gICAgb3JpZ2luYWxcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKGNvbWJpbmVkUmVkdWNlciwge1xuICAgIGluamVjdCxcbiAgICBzZWxlY3RvclxuICB9KTtcbn1cblxuLy8gc3JjL2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UudHNcbmZ1bmN0aW9uIGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoY29kZSkge1xuICByZXR1cm4gYE1pbmlmaWVkIFJlZHV4IFRvb2xraXQgZXJyb3IgIyR7Y29kZX07IHZpc2l0IGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvRXJyb3JzP2NvZGU9JHtjb2RlfSBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIGZ1bGwgZXJyb3JzLiBgO1xufVxuZXhwb3J0IHtcbiAgUmVkdWNlclR5cGUsXG4gIFNIT1VMRF9BVVRPQkFUQ0gsXG4gIFRhc2tBYm9ydEVycm9yLFxuICBUdXBsZSxcbiAgYWRkTGlzdGVuZXIsXG4gIGFzeW5jVGh1bmtDcmVhdG9yLFxuICBhdXRvQmF0Y2hFbmhhbmNlcixcbiAgYnVpbGRDcmVhdGVTbGljZSxcbiAgY2xlYXJBbGxMaXN0ZW5lcnMsXG4gIGNvbWJpbmVTbGljZXMsXG4gIGNvbmZpZ3VyZVN0b3JlLFxuICBjcmVhdGVBY3Rpb24sXG4gIGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlLFxuICBjcmVhdGVBc3luY1RodW5rLFxuICBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvcixcbiAgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3JDcmVhdG9yLFxuICBjcmVhdGVEeW5hbWljTWlkZGxld2FyZSxcbiAgY3JlYXRlRW50aXR5QWRhcHRlcixcbiAgY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLFxuICBjcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmUsXG4gIHByb2R1Y2UgYXMgY3JlYXRlTmV4dFN0YXRlLFxuICBjcmVhdGVSZWR1Y2VyLFxuICBjcmVhdGVTZWxlY3RvcixcbiAgY3JlYXRlU2VsZWN0b3JDcmVhdG9yMiBhcyBjcmVhdGVTZWxlY3RvckNyZWF0b3IsXG4gIGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZSxcbiAgY3JlYXRlU2xpY2UsXG4gIGN1cnJlbnQyIGFzIGN1cnJlbnQsXG4gIGZpbmROb25TZXJpYWxpemFibGVWYWx1ZSxcbiAgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSxcbiAgZnJlZXplLFxuICBpc0FjdGlvbkNyZWF0b3IsXG4gIGlzQWxsT2YsXG4gIGlzQW55T2YsXG4gIGlzQXN5bmNUaHVua0FjdGlvbixcbiAgaXNEcmFmdDQgYXMgaXNEcmFmdCxcbiAgaXNGU0EgYXMgaXNGbHV4U3RhbmRhcmRBY3Rpb24sXG4gIGlzRnVsZmlsbGVkLFxuICBpc0ltbXV0YWJsZURlZmF1bHQsXG4gIGlzUGVuZGluZyxcbiAgaXNQbGFpbixcbiAgaXNSZWplY3RlZCxcbiAgaXNSZWplY3RlZFdpdGhWYWx1ZSxcbiAgbHJ1TWVtb2l6ZSxcbiAgbWluaVNlcmlhbGl6ZUVycm9yLFxuICBuYW5vaWQsXG4gIG9yaWdpbmFsMiBhcyBvcmlnaW5hbCxcbiAgcHJlcGFyZUF1dG9CYXRjaGVkLFxuICByZW1vdmVMaXN0ZW5lcixcbiAgdW53cmFwUmVzdWx0LFxuICB3ZWFrTWFwTWVtb2l6ZTIgYXMgd2Vha01hcE1lbW9pemVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWR1eC10b29sa2l0Lm1vZGVybi5tanMubWFwIl0sIm5hbWVzIjpbInByb2R1Y2UiLCJjdXJyZW50IiwiY3VycmVudDIiLCJmcmVlemUiLCJvcmlnaW5hbCIsIm9yaWdpbmFsMiIsImlzRHJhZnQiLCJpc0RyYWZ0NCIsImNyZWF0ZVNlbGVjdG9yIiwiY3JlYXRlU2VsZWN0b3JDcmVhdG9yIiwiY3JlYXRlU2VsZWN0b3JDcmVhdG9yMiIsImxydU1lbW9pemUiLCJ3ZWFrTWFwTWVtb2l6ZSIsIndlYWtNYXBNZW1vaXplMiIsImNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yQ3JlYXRvciIsImFyZ3MiLCJjcmVhdGVTZWxlY3RvcjIiLCJjcmVhdGVEcmFmdFNhZmVTZWxlY3RvcjIiLCJPYmplY3QiLCJhc3NpZ24iLCJhcmdzMiIsInNlbGVjdG9yIiwid3JhcHBlZFNlbGVjdG9yIiwidmFsdWUiLCJyZXN0Iiwid2l0aFR5cGVzIiwiY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IiLCJhcHBseU1pZGRsZXdhcmUiLCJjcmVhdGVTdG9yZSIsImNvbXBvc2UiLCJjb21wb3NlMiIsImNvbWJpbmVSZWR1Y2VycyIsImlzUGxhaW5PYmplY3QiLCJpc1BsYWluT2JqZWN0MiIsImNvbXBvc2VXaXRoRGV2VG9vbHMiLCJ3aW5kb3ciLCJfX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcHBseSIsImRldlRvb2xzRW5oYW5jZXIiLCJfX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fIiwibm9vcDMiLCJ0aHVuayIsInRodW5rTWlkZGxld2FyZSIsIndpdGhFeHRyYUFyZ3VtZW50IiwiaXNBY3Rpb24iLCJoYXNNYXRjaEZ1bmN0aW9uIiwidiIsIm1hdGNoIiwiY3JlYXRlQWN0aW9uIiwidHlwZSIsInByZXBhcmVBY3Rpb24iLCJhY3Rpb25DcmVhdG9yIiwicHJlcGFyZWQiLCJFcnJvciIsInByb2Nlc3MiLCJmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIiwicGF5bG9hZCIsIm1ldGEiLCJlcnJvciIsInRvU3RyaW5nIiwiYWN0aW9uIiwiaXNBY3Rpb25DcmVhdG9yIiwiaXNGU0EiLCJrZXlzIiwiZXZlcnkiLCJpc1ZhbGlkS2V5Iiwia2V5IiwiaW5kZXhPZiIsImdldE1lc3NhZ2UiLCJzcGxpdFR5cGUiLCJzcGxpdCIsImFjdGlvbk5hbWUiLCJjcmVhdGVBY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZSIsIm9wdGlvbnMiLCJuZXh0IiwiaXNBY3Rpb25DcmVhdG9yMiIsImNvbnNvbGUiLCJ3YXJuIiwiY3JlYXRlTmV4dFN0YXRlIiwiaXNEcmFmdGFibGUiLCJnZXRUaW1lTWVhc3VyZVV0aWxzIiwibWF4RGVsYXkiLCJmbk5hbWUiLCJlbGFwc2VkIiwibWVhc3VyZVRpbWUiLCJmbiIsInN0YXJ0ZWQiLCJEYXRlIiwibm93IiwiZmluaXNoZWQiLCJ3YXJuSWZFeGNlZWRlZCIsImZpbmQiLCJpdGVyYWJsZSIsImNvbXBhcmF0b3IiLCJlbnRyeSIsIlR1cGxlIiwiX1R1cGxlIiwiQXJyYXkiLCJjb25zdHJ1Y3RvciIsIml0ZW1zIiwic2V0UHJvdG90eXBlT2YiLCJwcm90b3R5cGUiLCJTeW1ib2wiLCJzcGVjaWVzIiwiY29uY2F0IiwiYXJyIiwicHJlcGVuZCIsImlzQXJyYXkiLCJmcmVlemVEcmFmdGFibGUiLCJ2YWwiLCJlbXBsYWNlIiwibWFwIiwiaGFuZGxlciIsImhhcyIsImdldCIsInVwZGF0ZSIsInNldCIsImluc2VydCIsImluc2VydGVkIiwiaXNJbW11dGFibGVEZWZhdWx0IiwiaXNGcm96ZW4iLCJ0cmFja0Zvck11dGF0aW9ucyIsImlzSW1tdXRhYmxlIiwiaWdub3JlUGF0aHMiLCJvYmoiLCJ0cmFja2VkUHJvcGVydGllcyIsInRyYWNrUHJvcGVydGllcyIsImRldGVjdE11dGF0aW9ucyIsInBhdGgiLCJjaGVja2VkT2JqZWN0cyIsIlNldCIsInRyYWNrZWQiLCJhZGQiLCJjaGlsZHJlbiIsImNoaWxkUGF0aCIsImlnbm9yZWRQYXRocyIsInRyYWNrZWRQcm9wZXJ0eSIsInNhbWVQYXJlbnRSZWYiLCJwcmV2T2JqIiwic2FtZVJlZiIsIk51bWJlciIsImlzTmFOIiwid2FzTXV0YXRlZCIsImtleXNUb0RldGVjdCIsImhhc0lnbm9yZWRQYXRocyIsIm5lc3RlZFBhdGgiLCJoYXNNYXRjaGVzIiwic29tZSIsImlnbm9yZWQiLCJSZWdFeHAiLCJ0ZXN0IiwicmVzdWx0IiwiY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlIiwic3RyaW5naWZ5MiIsInNlcmlhbGl6ZXIiLCJpbmRlbnQiLCJkZWN5Y2xlciIsIkpTT04iLCJzdHJpbmdpZnkiLCJnZXRTZXJpYWxpemUyIiwic3RhY2siLCJfIiwic2xpY2UiLCJqb2luIiwidGhpc1BvcyIsInNwbGljZSIsInB1c2giLCJJbmZpbml0eSIsImNhbGwiLCJnZXRTZXJpYWxpemUiLCJ3YXJuQWZ0ZXIiLCJ0cmFjayIsImJpbmQiLCJnZXRTdGF0ZSIsInN0YXRlIiwidHJhY2tlciIsIm1lYXN1cmVVdGlscyIsImRpc3BhdGNoZWRBY3Rpb24iLCJpc0FjdGlvbjIiLCJpc1BsYWluIiwiZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlIiwiaXNTZXJpYWxpemFibGUiLCJnZXRFbnRyaWVzIiwiY2FjaGUiLCJmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZSIsImtleVBhdGgiLCJlbnRyaWVzIiwibmVzdGVkVmFsdWUiLCJpc05lc3RlZEZyb3plbiIsInZhbHVlcyIsImNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZSIsImlnbm9yZWRBY3Rpb25zIiwiaWdub3JlZEFjdGlvblBhdGhzIiwiaWdub3JlU3RhdGUiLCJpZ25vcmVBY3Rpb25zIiwiZGlzYWJsZUNhY2hlIiwiV2Vha1NldCIsInN0b3JlQVBJIiwiZm91bmRBY3Rpb25Ob25TZXJpYWxpemFibGVWYWx1ZSIsImZvdW5kU3RhdGVOb25TZXJpYWxpemFibGVWYWx1ZSIsImlzQm9vbGVhbiIsIngiLCJidWlsZEdldERlZmF1bHRNaWRkbGV3YXJlIiwiZ2V0RGVmYXVsdE1pZGRsZXdhcmUiLCJpbW11dGFibGVDaGVjayIsInNlcmlhbGl6YWJsZUNoZWNrIiwiYWN0aW9uQ3JlYXRvckNoZWNrIiwibWlkZGxld2FyZUFycmF5IiwiZXh0cmFBcmd1bWVudCIsImltbXV0YWJsZU9wdGlvbnMiLCJ1bnNoaWZ0Iiwic2VyaWFsaXphYmxlT3B0aW9ucyIsImFjdGlvbkNyZWF0b3JPcHRpb25zIiwiU0hPVUxEX0FVVE9CQVRDSCIsInByZXBhcmVBdXRvQmF0Y2hlZCIsImNyZWF0ZVF1ZXVlV2l0aFRpbWVyIiwidGltZW91dCIsIm5vdGlmeSIsInNldFRpbWVvdXQiLCJyQUYiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJhdXRvQmF0Y2hFbmhhbmNlciIsInN0b3JlIiwibm90aWZ5aW5nIiwic2hvdWxkTm90aWZ5QXRFbmRPZlRpY2siLCJub3RpZmljYXRpb25RdWV1ZWQiLCJsaXN0ZW5lcnMiLCJxdWV1ZUNhbGxiYWNrIiwicXVldWVNaWNyb3Rhc2siLCJxdWV1ZU5vdGlmaWNhdGlvbiIsIm5vdGlmeUxpc3RlbmVycyIsImZvckVhY2giLCJsIiwic3Vic2NyaWJlIiwibGlzdGVuZXIyIiwid3JhcHBlZExpc3RlbmVyIiwidW5zdWJzY3JpYmUiLCJkZWxldGUiLCJkaXNwYXRjaCIsImJ1aWxkR2V0RGVmYXVsdEVuaGFuY2VycyIsIm1pZGRsZXdhcmVFbmhhbmNlciIsImdldERlZmF1bHRFbmhhbmNlcnMiLCJhdXRvQmF0Y2giLCJlbmhhbmNlckFycmF5IiwiSVNfUFJPRFVDVElPTiIsImNvbmZpZ3VyZVN0b3JlIiwicmVkdWNlciIsIm1pZGRsZXdhcmUiLCJkZXZUb29scyIsInByZWxvYWRlZFN0YXRlIiwiZW5oYW5jZXJzIiwicm9vdFJlZHVjZXIiLCJmaW5hbE1pZGRsZXdhcmUiLCJpdGVtIiwiZmluYWxDb21wb3NlIiwidHJhY2UiLCJzdG9yZUVuaGFuY2VycyIsImluY2x1ZGVzIiwiY29tcG9zZWRFbmhhbmNlciIsImNyZWF0ZU5leHRTdGF0ZTIiLCJpc0RyYWZ0MiIsImlzRHJhZnRhYmxlMiIsImV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrIiwiYnVpbGRlckNhbGxiYWNrIiwiYWN0aW9uc01hcCIsImFjdGlvbk1hdGNoZXJzIiwiZGVmYXVsdENhc2VSZWR1Y2VyIiwiYnVpbGRlciIsImFkZENhc2UiLCJ0eXBlT3JBY3Rpb25DcmVhdG9yIiwiYWRkTWF0Y2hlciIsIm1hdGNoZXIiLCJhZGREZWZhdWx0Q2FzZSIsImlzU3RhdGVGdW5jdGlvbiIsImNyZWF0ZVJlZHVjZXIiLCJpbml0aWFsU3RhdGUiLCJtYXBPckJ1aWxkZXJDYWxsYmFjayIsImZpbmFsQWN0aW9uTWF0Y2hlcnMiLCJmaW5hbERlZmF1bHRDYXNlUmVkdWNlciIsImdldEluaXRpYWxTdGF0ZSIsImZyb3plbkluaXRpYWxTdGF0ZSIsImNhc2VSZWR1Y2VycyIsImZpbHRlciIsInJlZHVjZXIyIiwiY3IiLCJyZWR1Y2UiLCJwcmV2aW91c1N0YXRlIiwiY2FzZVJlZHVjZXIiLCJkcmFmdCIsInVybEFscGhhYmV0IiwibmFub2lkIiwic2l6ZSIsImlkIiwiaSIsIk1hdGgiLCJyYW5kb20iLCJtYXRjaGVzIiwiaXNBbnlPZiIsIm1hdGNoZXJzIiwiaXNBbGxPZiIsImhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhIiwidmFsaWRTdGF0dXMiLCJoYXNWYWxpZFJlcXVlc3RJZCIsInJlcXVlc3RJZCIsImhhc1ZhbGlkUmVxdWVzdFN0YXR1cyIsInJlcXVlc3RTdGF0dXMiLCJpc0FzeW5jVGh1bmtBcnJheSIsImEiLCJpc1BlbmRpbmciLCJhc3luY1RodW5rcyIsImFzeW5jVGh1bmsiLCJwZW5kaW5nIiwiY29tYmluZWRNYXRjaGVyIiwiaXNSZWplY3RlZCIsInJlamVjdGVkIiwiaXNSZWplY3RlZFdpdGhWYWx1ZSIsImhhc0ZsYWciLCJyZWplY3RlZFdpdGhWYWx1ZSIsImlzRnVsZmlsbGVkIiwiZnVsZmlsbGVkIiwiaXNBc3luY1RodW5rQWN0aW9uIiwiY29tbW9uUHJvcGVydGllcyIsIlJlamVjdFdpdGhWYWx1ZSIsIkZ1bGZpbGxXaXRoTWV0YSIsIm1pbmlTZXJpYWxpemVFcnJvciIsInNpbXBsZUVycm9yIiwicHJvcGVydHkiLCJtZXNzYWdlIiwiU3RyaW5nIiwiY3JlYXRlQXN5bmNUaHVuayIsImNyZWF0ZUFzeW5jVGh1bmsyIiwidHlwZVByZWZpeCIsInBheWxvYWRDcmVhdG9yIiwiYXJnIiwic2VyaWFsaXplRXJyb3IiLCJhYm9ydGVkIiwibmFtZSIsImNvbmRpdGlvbiIsImV4dHJhIiwiaWRHZW5lcmF0b3IiLCJhYm9ydENvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJhYm9ydEhhbmRsZXIiLCJhYm9ydFJlYXNvbiIsImFib3J0IiwicmVhc29uIiwicHJvbWlzZSIsImZpbmFsQWN0aW9uIiwiY29uZGl0aW9uUmVzdWx0IiwiaXNUaGVuYWJsZSIsInNpZ25hbCIsImFib3J0ZWRQcm9taXNlIiwiUHJvbWlzZSIsInJlamVjdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJnZXRQZW5kaW5nTWV0YSIsInJhY2UiLCJyZXNvbHZlIiwicmVqZWN0V2l0aFZhbHVlIiwiZnVsZmlsbFdpdGhWYWx1ZSIsInRoZW4iLCJlcnIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic2tpcERpc3BhdGNoIiwiZGlzcGF0Y2hDb25kaXRpb25SZWplY3Rpb24iLCJ1bndyYXAiLCJ1bndyYXBSZXN1bHQiLCJzZXR0bGVkIiwiYXN5bmNUaHVua1N5bWJvbCIsImZvciIsImFzeW5jVGh1bmtDcmVhdG9yIiwiUmVkdWNlclR5cGUiLCJSZWR1Y2VyVHlwZTIiLCJnZXRUeXBlIiwiYWN0aW9uS2V5IiwiYnVpbGRDcmVhdGVTbGljZSIsImNyZWF0b3JzIiwiY0FUIiwiY3JlYXRlU2xpY2UyIiwicmVkdWNlclBhdGgiLCJyZWR1Y2VycyIsImJ1aWxkUmVkdWNlckNyZWF0b3JzIiwicmVkdWNlck5hbWVzIiwiY29udGV4dCIsInNsaWNlQ2FzZVJlZHVjZXJzQnlOYW1lIiwic2xpY2VDYXNlUmVkdWNlcnNCeVR5cGUiLCJhY3Rpb25DcmVhdG9ycyIsInNsaWNlTWF0Y2hlcnMiLCJjb250ZXh0TWV0aG9kcyIsImV4cG9zZUFjdGlvbiIsIm5hbWUyIiwiZXhwb3NlQ2FzZVJlZHVjZXIiLCJyZWR1Y2VyTmFtZSIsInJlZHVjZXJEZWZpbml0aW9uIiwicmVkdWNlckRldGFpbHMiLCJjcmVhdGVOb3RhdGlvbiIsImlzQXN5bmNUaHVua1NsaWNlUmVkdWNlckRlZmluaXRpb24iLCJoYW5kbGVUaHVua0Nhc2VSZWR1Y2VyRGVmaW5pdGlvbiIsImhhbmRsZU5vcm1hbFJlZHVjZXJEZWZpbml0aW9uIiwiYnVpbGRSZWR1Y2VyIiwiZXh0cmFSZWR1Y2VycyIsImZpbmFsQ2FzZVJlZHVjZXJzIiwic00iLCJtIiwic2VsZWN0U2VsZiIsImluamVjdGVkU2VsZWN0b3JDYWNoZSIsIk1hcCIsIl9yZWR1Y2VyIiwibWFrZVNlbGVjdG9yUHJvcHMiLCJyZWR1Y2VyUGF0aDIiLCJpbmplY3RlZCIsInNlbGVjdFNsaWNlIiwic2xpY2VTdGF0ZSIsImdldFNlbGVjdG9ycyIsInNlbGVjdFN0YXRlIiwic2VsZWN0b3JDYWNoZSIsIldlYWtNYXAiLCJzZWxlY3RvcnMiLCJ3cmFwU2VsZWN0b3IiLCJhY3Rpb25zIiwiaW5qZWN0SW50byIsImluamVjdGFibGUiLCJwYXRoT3B0IiwiY29uZmlnIiwibmV3UmVkdWNlclBhdGgiLCJpbmplY3QiLCJ3cmFwcGVyIiwicm9vdFN0YXRlIiwidW53cmFwcGVkIiwiY3JlYXRlU2xpY2UiLCJfcmVkdWNlckRlZmluaXRpb25UeXBlIiwicHJlcGFyZWRSZWR1Y2VyIiwicHJlcGFyZSIsIm1heWJlUmVkdWNlcldpdGhQcmVwYXJlIiwicHJlcGFyZUNhbGxiYWNrIiwiaXNDYXNlUmVkdWNlcldpdGhQcmVwYXJlRGVmaW5pdGlvbiIsIm5vb3AiLCJnZXRJbml0aWFsRW50aXR5U3RhdGUiLCJpZHMiLCJlbnRpdGllcyIsImNyZWF0ZUluaXRpYWxTdGF0ZUZhY3RvcnkiLCJhZGRpdGlvbmFsU3RhdGUiLCJjcmVhdGVTZWxlY3RvcnNGYWN0b3J5Iiwic2VsZWN0SWRzIiwic2VsZWN0RW50aXRpZXMiLCJzZWxlY3RBbGwiLCJzZWxlY3RJZCIsInNlbGVjdEJ5SWQiLCJzZWxlY3RUb3RhbCIsInNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcyIsImNyZWF0ZU5leHRTdGF0ZTMiLCJpc0RyYWZ0MyIsImlzRHJhZnRUeXBlZCIsImNyZWF0ZVNpbmdsZUFyZ3VtZW50U3RhdGVPcGVyYXRvciIsIm11dGF0b3IiLCJvcGVyYXRvciIsImNyZWF0ZVN0YXRlT3BlcmF0b3IiLCJvcGVyYXRpb24iLCJpc1BheWxvYWRBY3Rpb25Bcmd1bWVudCIsImFyZzIiLCJydW5NdXRhdG9yIiwic2VsZWN0SWRWYWx1ZSIsImVudGl0eSIsImVuc3VyZUVudGl0aWVzQXJyYXkiLCJzcGxpdEFkZGVkVXBkYXRlZEVudGl0aWVzIiwibmV3RW50aXRpZXMiLCJhZGRlZCIsInVwZGF0ZWQiLCJjaGFuZ2VzIiwiY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIiLCJhZGRPbmVNdXRhYmx5IiwiYWRkTWFueU11dGFibHkiLCJzZXRPbmVNdXRhYmx5Iiwic2V0TWFueU11dGFibHkiLCJzZXRBbGxNdXRhYmx5IiwicmVtb3ZlT25lTXV0YWJseSIsInJlbW92ZU1hbnlNdXRhYmx5IiwiZGlkTXV0YXRlIiwicmVtb3ZlQWxsTXV0YWJseSIsInRha2VOZXdLZXkiLCJvcmlnaW5hbDMiLCJuZXdLZXkiLCJoYXNOZXdLZXkiLCJ1cGRhdGVPbmVNdXRhYmx5IiwidXBkYXRlTWFueU11dGFibHkiLCJ1cGRhdGVzIiwibmV3S2V5cyIsInVwZGF0ZXNQZXJFbnRpdHkiLCJkaWRNdXRhdGVFbnRpdGllcyIsImRpZE11dGF0ZUlkcyIsImUiLCJ1cHNlcnRPbmVNdXRhYmx5IiwidXBzZXJ0TWFueU11dGFibHkiLCJyZW1vdmVBbGwiLCJhZGRPbmUiLCJhZGRNYW55Iiwic2V0T25lIiwic2V0TWFueSIsInNldEFsbCIsInVwZGF0ZU9uZSIsInVwZGF0ZU1hbnkiLCJ1cHNlcnRPbmUiLCJ1cHNlcnRNYW55IiwicmVtb3ZlT25lIiwicmVtb3ZlTWFueSIsImNyZWF0ZVNvcnRlZFN0YXRlQWRhcHRlciIsInNvcnQiLCJtb2RlbHMiLCJtb2RlbCIsIm1lcmdlIiwiYXBwbGllZFVwZGF0ZXMiLCJuZXdJZCIsInJlc29ydEVudGl0aWVzIiwiYXJlQXJyYXlzRXF1YWwiLCJiIiwiYWxsRW50aXRpZXMiLCJuZXdTb3J0ZWRJZHMiLCJjcmVhdGVFbnRpdHlBZGFwdGVyIiwic29ydENvbXBhcmVyIiwiaW5zdGFuY2UiLCJzdGF0ZUZhY3RvcnkiLCJzZWxlY3RvcnNGYWN0b3J5Iiwic3RhdGVBZGFwdGVyIiwiaXNBY3Rpb24zIiwidGFzayIsImxpc3RlbmVyIiwiY29tcGxldGVkIiwiY2FuY2VsbGVkIiwidGFza0NhbmNlbGxlZCIsInRhc2tDb21wbGV0ZWQiLCJsaXN0ZW5lckNhbmNlbGxlZCIsImxpc3RlbmVyQ29tcGxldGVkIiwiVGFza0Fib3J0RXJyb3IiLCJjb2RlIiwiYXNzZXJ0RnVuY3Rpb24iLCJmdW5jIiwiZXhwZWN0ZWQiLCJub29wMiIsImNhdGNoUmVqZWN0aW9uIiwib25FcnJvciIsImNhdGNoIiwiYWRkQWJvcnRTaWduYWxMaXN0ZW5lciIsImFib3J0U2lnbmFsIiwiY2FsbGJhY2siLCJvbmNlIiwiYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbiIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwidmFsaWRhdGVBY3RpdmUiLCJyYWNlV2l0aFNpZ25hbCIsImNsZWFudXAiLCJub3RpZnlSZWplY3Rpb24iLCJmaW5hbGx5IiwicnVuVGFzayIsInRhc2syIiwiY2xlYW5VcCIsInN0YXR1cyIsImNyZWF0ZVBhdXNlIiwib3V0cHV0IiwiY3JlYXRlRGVsYXkiLCJwYXVzZSIsInRpbWVvdXRNcyIsIklOVEVSTkFMX05JTF9UT0tFTiIsImFsbSIsImNyZWF0ZUZvcmsiLCJwYXJlbnRBYm9ydFNpZ25hbCIsInBhcmVudEJsb2NraW5nUHJvbWlzZXMiLCJsaW5rQ29udHJvbGxlcnMiLCJjb250cm9sbGVyIiwidGFza0V4ZWN1dG9yIiwib3B0cyIsImNoaWxkQWJvcnRDb250cm9sbGVyIiwicmVzdWx0MiIsImRlbGF5IiwiYXV0b0pvaW4iLCJjYW5jZWwiLCJjcmVhdGVUYWtlUGF0dGVybiIsInN0YXJ0TGlzdGVuaW5nIiwidGFrZSIsInByZWRpY2F0ZSIsInR1cGxlUHJvbWlzZSIsInN0b3BMaXN0ZW5pbmciLCJlZmZlY3QiLCJsaXN0ZW5lckFwaSIsImdldE9yaWdpbmFsU3RhdGUiLCJwcm9taXNlcyIsImdldExpc3RlbmVyRW50cnlQcm9wc0Zyb20iLCJjcmVhdGVMaXN0ZW5lckVudHJ5IiwiY2FuY2VsQWN0aXZlTGlzdGVuZXJzIiwiY3JlYXRlQ2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUiLCJsaXN0ZW5lck1hcCIsImNsZWFyIiwic2FmZWx5Tm90aWZ5RXJyb3IiLCJlcnJvckhhbmRsZXIiLCJlcnJvclRvTm90aWZ5IiwiZXJyb3JJbmZvIiwiZXJyb3JIYW5kbGVyRXJyb3IiLCJhZGRMaXN0ZW5lciIsImNsZWFyQWxsTGlzdGVuZXJzIiwicmVtb3ZlTGlzdGVuZXIiLCJkZWZhdWx0RXJyb3JIYW5kbGVyIiwiY3JlYXRlTGlzdGVuZXJNaWRkbGV3YXJlIiwibWlkZGxld2FyZU9wdGlvbnMiLCJpbnNlcnRFbnRyeSIsImNhbmNlbE9wdGlvbnMiLCJjYW5jZWxBY3RpdmUiLCJmcm9tIiwiZXhpc3RpbmdFbnRyeSIsImVudHJ5MiIsIm1hdGNoUHJlZGljYXRlT3JUeXBlIiwibm90aWZ5TGlzdGVuZXIiLCJhcGkiLCJpbnRlcm5hbFRhc2tDb250cm9sbGVyIiwiYXV0b0pvaW5Qcm9taXNlcyIsIkJvb2xlYW4iLCJmb3JrIiwidGhyb3dJZkNhbmNlbGxlZCIsImxpc3RlbmVyRXJyb3IiLCJyYWlzZWRCeSIsImFsbCIsImNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlIiwib3JpZ2luYWxTdGF0ZSIsImN1cnJlbnRTdGF0ZSIsImxpc3RlbmVyRW50cmllcyIsInJ1bkxpc3RlbmVyIiwicHJlZGljYXRlRXJyb3IiLCJjbGVhckxpc3RlbmVycyIsImNvbXBvc2UzIiwiY3JlYXRlTWlkZGxld2FyZUVudHJ5IiwiYXBwbGllZCIsIm1hdGNoSW5zdGFuY2UiLCJpbnN0YW5jZUlkIiwiY3JlYXRlRHluYW1pY01pZGRsZXdhcmUiLCJtaWRkbGV3YXJlTWFwIiwid2l0aE1pZGRsZXdhcmUiLCJtaWRkbGV3YXJlcyIsImFkZE1pZGRsZXdhcmUiLCJhZGRNaWRkbGV3YXJlMiIsIm1pZGRsZXdhcmUyIiwiZ2V0RmluYWxNaWRkbGV3YXJlIiwiYXBwbGllZE1pZGRsZXdhcmUiLCJpc1dpdGhNaWRkbGV3YXJlIiwiY29tYmluZVJlZHVjZXJzMiIsImlzU2xpY2VMaWtlIiwibWF5YmVTbGljZUxpa2UiLCJnZXRSZWR1Y2VycyIsInNsaWNlcyIsImZsYXRNYXAiLCJzbGljZU9yTWFwIiwiT1JJR0lOQUxfU1RBVEUiLCJpc1N0YXRlUHJveHkiLCJzdGF0ZVByb3h5TWFwIiwiY3JlYXRlU3RhdGVQcm94eSIsInJlZHVjZXJNYXAiLCJQcm94eSIsInRhcmdldCIsInByb3AiLCJyZWNlaXZlciIsIlJlZmxlY3QiLCJyZWR1Y2VyUmVzdWx0IiwiY29tYmluZVNsaWNlcyIsImZyb21FbnRyaWVzIiwiZ2V0UmVkdWNlciIsImNvbWJpbmVkUmVkdWNlciIsIndpdGhMYXp5TG9hZGVkU2xpY2VzIiwicmVkdWNlclRvSW5qZWN0IiwiY3VycmVudFJlZHVjZXIiLCJvdmVycmlkZUV4aXN0aW5nIiwibWFrZVNlbGVjdG9yIiwic2VsZWN0b3JGbiIsInNlbGVjdG9yMiIsImlzRmx1eFN0YW5kYXJkQWN0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\n");

/***/ })

};
;